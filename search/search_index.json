{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Reviews","text":"<p>Collapse All/Expand All Code</p>"},{"location":"#chapter-2","title":"Chapter 2","text":"01. What are the modules of C++ programs called?  They are called functions   02. What does the following preprocessor directive do?  <pre><code>#include &lt;iostream&gt;\n</code></pre>  It causes the contents of the iostream file to be substituted for this directive before final compilation.   03. What does the following statement do?  <pre><code>using namespace std;\n</code></pre>  It makes definitions made in the std namespace available to a program.   04. What statement would you use to print the phrase \u201cHello, world\u201d and then start a new line?  <pre><code>cout &lt;&lt; \"Hello, world\\n\";\n</code></pre>  or  <pre><code>cout &lt;&lt; \"Hello, world\" &lt;&lt; endl;\n</code></pre>  05. What statement would you use to create an integer variable with the name cheeses ?  <pre><code>int cheeses;\n</code></pre>  06. What statement would you use to assign the value 32 to the variable cheeses?  <pre><code>cheeses = 32;\n</code></pre>  07. What statement would you use to read a value from keyboard input into the \u2003 variable cheeses ?  <pre><code>cin &gt;&gt; cheeses;\n</code></pre>  08. What statement would you use to print \u201cWe have X varieties of cheese,\u201d \u2003 where the current value of the cheeses variable replaces X ?   <pre><code>cout &lt;&lt; \"We have \" &lt;&lt; cheeses &lt;&lt; \" varieties of cheese\\n\";\n</code></pre>  09. What do the following function prototypes tell you about the functions?  <pre><code>int prune(void);\nint froop(double t);\nvoid rattle(int n);\n</code></pre>   The function froop() expects to be called with one argument, which will be type double, and that the function will return a type int value. For instance, it could be used as follows: <code> int gval = froop(3.14159); </code>  The function rattle() has no return value and expects an int argument. For instance, it could be used as follows: <code> rattle(37); </code>  The function prune() returns an int and expects to be used without an argument. For instance, it could be used as follows: <code> int residue = prune(); </code>  10.  When do you not have to use the keyword return when you define a function?   You don\u2019t have to use return in a function when the function has the return type <code>void</code>. However, you can use it if you don\u2019t give a return value: <code> return; </code>  11. Suppose your main() function has the following line:  <pre><code>cout &lt;&lt; \"Please enter your PIN: \";\n</code></pre>  And suppose the compiler complains that cout is an unknown identifier. What is the likely cause of this complaint, and what are three ways to fix the problem?   Lack of caller for std library.  Use directive:  <pre><code>using namespace std;\n</code></pre>  or  <pre><code>using std::cout\n</code></pre>  for only <code>cout</code> or call library with <code>std::cout</code> instead of <code>cout</code>"},{"location":"#chapter-3","title":"Chapter 3","text":"01. Why does C++ have more than one integer type?   Having more than one integer type lets you choose the type that is best suited to a particular need. For example, you could use <code>short</code> to conserve space or <code>long</code> to guarantee storage capacity or to find that a particular type speeds up a particular calculation.    02. Declare variables matching the following descriptions: \u00a0\u00a0\u00a0\u00a0\u00a0 a. A short integer with the value 80 \u00a0\u00a0\u00a0\u00a0\u00a0 b. An unsigned int integer with the value 42, 110 \u00a0\u00a0\u00a0\u00a0\u00a0 c. An integer with the value 3, 000, 000, 000   <pre><code>short rbis = 80; // or short int rbis = 80;\nunsigned int q = 42110; // or unsigned q = 42110;\nunsigned long ants = 3000000000;\n// or long long ants = 3000000000;\n\n//Note: Don\u2019t count on int being large enough to hold 3,000,000,000.Also if your\n//system supports universal list-initialization, you could use it:\nshort rbis = {80}; // = is optional\nunsigned int q {42110}; // could use = {42110}\nlong long ants {3000000000};\n</code></pre>  03. What safeguards does C++ provide to keep you from exceeding the limits of an integer type?    C++ provides no automatic safeguards to keep you from exceeding integer limits; you can use the <code>climits</code> header file to determine what the limits are.   04. What is the distinction between <code>33L</code> and <code>33</code>?    The constant <code>33L</code> is type long, whereas the constant <code>33</code> is type <code>int</code>.   05. Consider the two C++ statements that follow:  <pre><code>char grade = 65;\nchar grade = 'A';\n</code></pre>  Are they equivalent?    The two statements are not really equivalent, although they have the same effect on some systems. Most importantly, the first statement assigns the letter <code>A</code> to grade only on a system using the <code>ASCII</code> code, while the second statement also works for other codes. Second, <code>65</code> is a type int constant, whereas <code>'A'</code> is a type char constant.   06. How could you use C++ to find out which character the code 88 represents? Come up with at least two ways.    Here are four ways:  <pre><code>char c = 88;\ncout &lt;&lt; c &lt;&lt; endl;              // char type prints as character\ncout.put(char(88));             // put() prints char as character\ncout &lt;&lt; char(88) &lt;&lt; endl;       // new-style type cast value to char\ncout &lt;&lt; (char)88 &lt;&lt; endl;       // old-style type cast value to char\n</code></pre>  07. Assigning a <code>long</code> value to a <code>float</code> can result in a rounding error. What about assigning <code>long</code> to <code>double</code> ? <code>long long</code> to <code>double</code> ?    The answer depends on how large the two types are. If <code>long</code> is 4 bytes, there is no loss. That\u2019s because the largest <code>long</code> value would be about 2 billion, which is 10 digits. Because <code>double</code> provides at least 13 significant figures, no rounding would be needed. The <code>long long</code> type, on the other hand, can reach 19 digits, which exceeds the 13 significant figures guaranteed for <code>double</code> .   08. Evaluate the following expressions as C++ would:  <pre><code>a. 8 * 9 + 2 \nb. 6 * 3 / 4 \nc. 3 / 4 * 6 \nd. 6.0 * 3 / 4 \ne. 15 % 4 \n</code></pre> <pre><code>a. 8 * 9 + 2 is 72 + 2 is 74\nb. 6 * 3 / 4 is 18 / 4 is 4\nc. 3 / 4 * 6 is 0 * 6 is 0\nd. 6.0 * 3 / 4 is 18.0 / 4 is 4.5\ne. 15 % 4 is 3\n</code></pre>  09.  Suppose <code>x1</code> and <code>x2</code> are two type <code>double</code> variables that you want to add as <code>integers</code> and assign to an <code>integer</code> variable. Construct a C++ statement for doing so. What if you want to add them as type <code>double</code> and then convert to <code>int</code> ?    Either of the following would work for the first task:  <pre><code>int pos = (int) x1 + (int) x2;\nint pos = int(x1) + int(x2);\n</code></pre>  To add them as type double and then convert, you could do either of the following:  <pre><code>int pos = (int) (x1 + x2);\nint pos = int(x1 + x2);\n</code></pre>  10.  What is the variable type for each of the following declarations?  <pre><code>a. `auto cars = 15;`\n\nb. `auto iou = 150.37f;`\nc. `auto level = 'B';`\n\nd. `auto crat = U'/U00002155';`\n\ne. `auto fract = 8.25f/2.5;`\n</code></pre> <pre><code>a. int\nb. float\nc. char\nd. char32_t\ne. double\n</code></pre>"},{"location":"#chapter-4","title":"Chapter 4","text":"01. How would you declare each of the following?  <pre><code>a. actors is an array of 30 char.\nb. betsie is an array of 100 short.\nc. chuck is an array of 13 float.\nd. dipsea is an array of 64 long double.\n</code></pre> <pre><code>char actors[30];\nshort betsie[100];\nfloat chuck[13];\nlong double dipsea[64];\n</code></pre>  02. Do Chapter Review Question 1 and use the array template class instead of built-in arrays.   <pre><code>array&lt;char, 30&gt; actors;\narray&lt;short, 100&gt; betsie;\narray&lt;float, 13&gt; chuck;\narray&lt;long double, 64&gt; dipsea;\n</code></pre>  03. Declare an array of five ints and initialize it to the first five odd positive integers   <pre><code>int oddly[5] = {1, 3, 5, 7, 9};\narray&lt;int, 5&gt; at {1, 3, 5, 7, 9}; // also correct\n</code></pre>  04. Write a statement that assigns the sum of the first and last elements of the array in Question 3 to the variable even.   <pre><code>int even = array[0] + array[4]; \n</code></pre>  05. Write a statement that displays the value of the second element in the float array ideas.   <pre><code>std::cout &lt;&lt; ideas[1];\n</code></pre>  06. Declare an array of char and initialize it to the string \"cheeseburger\".   <pre><code>char food[] {\"cheeseburger\"};\n// or\nchar lunch[13] = \"cheeseburger\"; // number of characters + 1\n</code></pre>  07. Declare a string object and initialize it to the string \"Waldorf Salad\".   <pre><code>std::string obj = \"Waldorf Salad\";\n</code></pre>  08. Devise a structure declaration that describes a fish. The structure should include the kind, the weight in whole ounces, and the length in fractional inches.   <pre><code>struct fish {\n    char kind[20];\n    int weight;\n    float length;\n};\n</code></pre>  09. Declare a variable of the type defined in Question 8 and initialize it.   <pre><code>fish petes =\n{\n    \"trout\",\n    12,\n    26.25\n};\n\n// OR\n\nfish flounder;\nflounder.kind = \"fishy\";\nflounder.weight = 21;\nflounder.length = 21;\n</code></pre>  10.  Use enum to define a type called Response with the possible values <code>Yes</code>, <code>No</code>, and <code>Maybe</code>. <code>Yes</code> should be <code>1</code>, <code>No</code> should be <code>0</code>, and <code>Maybe</code> should be <code>2</code>.   <pre><code>enum response {No, Yes, Maybe};\n</code></pre>  11.  Suppose ted is a double variable. Declare a pointer that points to ted and use the pointer to display ted\u2019s value.   <pre><code>double *ptrTed = &amp;ted;\nstd::cout &lt;&lt; *ptrTed;\n</code></pre>  12.  Suppose treacle is an array of 10 floats. Declare a pointer that points to the first element of treacle and use the pointer to display the first and last elements of the array.   <pre><code>float *ptrTreacle = treacle; // or = &amp;treacle[0]\ncout &lt;&lt; pf[0] &lt;&lt; \" \" &lt;&lt; pf[9] &lt;&lt; \"\\n\";\n\nstd::cout &lt;&lt; ptrTreacle[0] &lt;&lt; \"last\" &lt;&lt; ptrTreacle[9];\n// or use:\nstd::cout &lt;&lt; *(ptrTreacle + 1) &lt;&lt; \"last\" &lt;&lt; *(ptrTreacle + 9);\n</code></pre>  13. Write a code fragment that asks the user to enter a positive integer and then creates a dynamic array of that many ints. Do this by using <code>new</code>, then again using a <code>vector</code> object.   <pre><code>unsigned int iUsr {};\ncout &lt;&lt; \"Enter a positive integer: \";\nstd::cin &gt;&gt; iUsr;\n\nint *sth = new int[iUsr];\nvector&lt;int&gt; sth(iUsr);\n</code></pre>  14. Is the following valid code? If so, what does it print?  <pre><code>cout &lt;&lt; (int *) \u201cHome of the jolly bytes\u201d;\n</code></pre>   //Yes //Start of memory of this Literal  Yes, it is valid. The expression \"Home of the jolly bytes\" is a string constant; hence it evaluates as the address of the beginning of the string. The cout object interprets the address of a char as an invitation to print a string, but the type cast (int *) converts the address to type pointer-to-int, which is then printed as an address. In short, the statement prints the address of the string, assuming the int type is wide enough to hold an address.   15. Write a code fragment that dynamically allocates a structure of the type described in Question 8 and then reads a value for the <code>kind</code> member of the structure.   <pre><code>struct fish\n{\n    char kind[20];\n    int weight;\n    float length;\n};\n\nint main(){\n    fish * pole = new fish;    \n\n    std::cout &lt;&lt; \"Enter kind of fish: \";\n    std::cin &gt;&gt; pole-&gt;kind;\n}\n</code></pre>  16. Listing 4.6 (numstr.cpp) illustrates a problem created by following numeric input with line-oriented string input. How would replacing:  <pre><code>// this:\ncin.getline(address,80);\n\n// with this:\ncin &gt;&gt; address;\n\n// affect the working of this program?\n</code></pre> <code>cin &gt;&gt; address</code> will read from user only to the space. Data after space will be in the queue; Using <code>cin &gt;&gt; address</code> causes a program to skip over whitespace until it finds non-whitespace. It then reads characters until it encounters whitespace again. Thus, it will skip over the newline following the numeric input, avoiding that problem. On the other hand, it will read just a single word, not an entire line.   17. Declare a vector object of 10 string objects and an array object of 10 string objects. Show the necessary header files and don\u2019t use using. Do use a const for the number of strings.  <pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;array&gt;\n\n// Like this\nvector&lt;string&gt; vSth(10);\narray&lt;string, 10&gt; aSth;\n\n\n// Solution in a book\nconst int Str_num {10}; // or = 10\n\n... \n\nstd::vector&lt;std::string&gt; vstr(Str_num);\nstd::array&lt;std::string, Str_num&gt; astr;\n</code></pre>"},{"location":"#chapter-5","title":"Chapter 5","text":"01. What\u2019s the difference between an entry-condition loop and an exit-condition loop? Which kind is each of the C++ loops?    // entry-condition loop - check condition before entering the loop  // exit-condition loop -  check condition at the end of loop, making at least 1 loop  An entry-condition loop evaluates a test expression before entering the body of the loop. If the condition is initially false, the loop never executes its body. An exitcondition loop evaluates a test expression after processing the body of the loop. Thus, the loop body is executed once, even if the test expression is initially false. The for and while loops are entry-condition loops, and the do while loop is an exit-condition loop   02. What would the following code fragment print if it were part of a valid program?  <pre><code>int i;\nfor (i = 0; i &lt; 5; i++)\n    cout &lt;&lt; i;\n    cout &lt;&lt; endl;\n</code></pre>  It would print the following: <pre><code>01234\n</code></pre>  Note that <code>cout &lt;&lt; endl;</code> is not part of the loop body (because there are no braces).   03. What would the following code fragment print if it were part of a valid program?  <pre><code>int j;\nfor (j = 0; j &lt; 11; j += 3)\n    cout &lt;&lt; j;\ncout &lt;&lt; endl &lt;&lt; j &lt;&lt; endl;\n</code></pre>  It would print the following:  <pre><code>0369\n12\n</code></pre>  04. What would the following code fragment print if it were part of a valid program?  <pre><code>int j = 5;\nwhile ( ++j &lt; 9)\n    cout &lt;&lt; j++ &lt;&lt; endl;\n</code></pre>  It would print the following:  <pre><code>6\n8\n</code></pre>  05. What would the following code fragment print if it were part of a valid program?  <pre><code>int k = 8;\ndo\n    cout &lt;&lt;\" k = \" &lt;&lt; k &lt;&lt; endl;\nwhile (k++ &lt; 5);\n</code></pre>  It would print the following:  <pre><code>k = 8\n</code></pre>  06. Write a <code>for</code> loop that prints the values <code>1 2 4 8 16 32 64</code> by increasing the value of a counting variable by a factor of two in each cycle.    It\u2019s simplest to use the <code>*=</code> operator: <pre><code>for(int i {}; i &lt; 65; i *= 2)\n    cout &lt;&lt; i &lt;&lt; \" \";\n</code></pre>  07. How do you make a loop body include more than one statement?    //add curly braces <code>{}</code>   You enclose the statements within paired braces to form a single compound statement, or block.   08. Is the following statement valid? If not, why not? If so, what does it do?  <pre><code>int x = (1,024);\n</code></pre>  What about the following?  <pre><code>int y;\ny = 1,024;\n</code></pre>  //1st is valid, but 1 will be assigned to x due to precedence and first value will do nothing  //in 2nd 1 will be assigned to y, and 024 will do nothing, but confuse.   Yes, the first statement is valid. The expression 1, 024 consists of two expressions \u2014 1 and 024 \u2014 joined by a comma operator. The value is the value of the right-hand expression. This is 024, which is octal for 20, so the declaration assigns the value 20 to x. The second statement is also valid. However, operator precedence causes it to be evaluated as follows:  <pre><code>(y = 1), 024;\n</code></pre>  That is, the left expression sets y to 1, and the value of the entire expression, which isn\u2019t used, is <code>024</code> , or <code>20</code> .    09. How does <code>cin &gt;&gt; ch</code> differ from <code>cin.get(ch)</code> and <code>ch=cin.get()</code> in how it views input?   // My answer <code>cin&gt;&gt;ch</code> will omit spaces, <code>cin.get(ch)</code> will return <code>bool</code> true, false if EOF, <code>ch=cin.get()</code> will assign <code>int</code> value and EOF if EOF   // Answer in the book The <code>cin &gt;&gt; ch</code> form skips over spaces, newlines, and tabs when it encounters them. The other two forms read those characters"},{"location":"#chapter-6","title":"Chapter 6","text":"01. Consider the following two code fragments for counting spaces and newlines  <pre><code>// Version 1\nwhile (cin.get(ch)) // quit on eof\n{\n    if (ch == ' ')\n        spaces++;\n    if (ch == '\\n')\n        newlines++;\n}\n// Version 2\nwhile (cin.get(ch)) // quit on eof\n{\n    if (ch == ' ')\n        spaces++;\n    else if (ch == '\\n')\n        newlines++;\n}\n</code></pre>  What advantages, if any, does the second form have over the first?  // My answer Because version 1 checks every times both conditions, thus it's less efficient. Version 2 checks 2 condition only if first is not true.  // Answer in the book Both versions give the same answers, but the if else version is more efficient. Consider what happens, for example, when ch is a space. Version 1, after incrementing spaces, tests whether the character is a newline. This wastes time because the program has already established that ch is a space and hence could not be a newline. Version 2, in the same situation, skips the newline test.   02. In Listing 6.2, what is the effect of replacing <code>++ch</code> with <code>ch+1</code>?  <pre><code>Listing 6.2 ifelse.cpp\n// ifelse.cpp -- using the if else statement\n#include &lt;iostream&gt;\n    int\n    main()\n{\n    char ch;\n    std::cout &lt;&lt; \"Type, and I shall repeat.\\n\";\n    std::cin.get(ch);\n    while (ch != '.')\n    {\n        if (ch == '\\n')\n            std::cout &lt;&lt; ch; // done if newline\n        else\n            std::cout &lt;&lt; ++ch; // done otherwise\n        std::cin.get(ch);\n    }\n    std::cout &lt;&lt; \"\\nPlease excuse the slight confusion.\\n\";\n    return 0;\n}\n</code></pre>   // My answer The <code>char</code> is promoted to <code>int</code> , and display numbers  // Answer in the book Both <code>++ch</code> and <code>ch + 1</code> have the same numerical value. But <code>++ch</code> is type char and prints as a character, while <code>ch + 1</code> , because it adds a <code>char</code> to an <code>int</code> , is type <code>int</code> and prints as a number.    03. Carefully consider the following program:  <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    char ch;\n    int ct1, ct2;\n    ct1 = ct2 = 0;\n    while ((ch = cin.get()) != '$')\n    {\n        cout &lt;&lt; ch;\n        ct1++;\n        if (ch = '$')\n            ct2++;\n        cout &lt;&lt; ch;\n    }\n    cout &lt;&lt; \"ct1 = \" &lt;&lt; ct1 &lt;&lt; \", ct2 = \" &lt;&lt; ct2 &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>  Suppose you provide the following input, pressing the Enter key at the end of each line:  <pre><code>Hi!\nSend $10 or $20 now!\n</code></pre>  What is the output? (Recall that input is buffered.)    // My answer <pre><code>// Program print after every read character `$` and if in input is `$` , the while loop will end.\n// `Hi!`\n\n// `H$i$!$`\n\n// `$Send $10 or $20 now!`\n\n// `S$e$n$d$ $ct1 = 8, ct2 = 8` // `$` is added even newline, and `ct` is added with it, I didn't include that\n</code></pre>  // Answer in the book Because the program uses <code>ch = `$` </code> instead of <code>ch == `$`</code> , the combined input and output looks like this:  <pre><code>Hi!\nH$i$!$\n$Send $10 or $20 now!\nS$e$n$d$ $ct1 = 9, ct2 = 9\n</code></pre>  Each character is converted to the <code>$</code> character before being printed the second time. Also the value of the expression <code>ch = $</code> is the code for the <code>$</code> character, hence nonzero, hence <code>true</code> ; so <code>ct2</code> is incremented each time.   04. Construct logical expressions to represent the following conditions:  <pre><code>    a. weight is greater than or equal to 115 but less than 125.\n    b. ch is q or Q.\n    c. x is even but is not 26.\n    d. x is even but is not a multiple of 26.\n    e. donation is in the range 1,000\u20132,000 or guest is 1.\n    f. ch is a lowercase letter or an uppercase letter. (Assume, as is true for ASCII, \n    that lowercase letters are coded sequentially and that uppercase letters are coded \n    sequentially but that there is a gap in the code between uppercase and lowercase.)\n</code></pre> <pre><code>weight &gt;= 115 &amp;&amp; weight &lt; 125                           //a\nch == `q` || ch == `Q`                                  //b\nx % 2 == 0 &amp;&amp; x != 26                                   //c\n\nx % 2 == 0 &amp;&amp; x % 26 != 0                               //d\nx % 2 == 0 &amp;&amp; !(x % 26 == 0)                            //d\ndonation &gt;= 1000 &amp;&amp; donation &lt;= 2000 || guest == 1      //e\n\n(ch =&gt; `a` &amp;&amp; ch &lt;= z) || (ch &gt;= `A` &amp;&amp; ch &lt;= `Z`)      //f\nisalpha(ch)                                             //f\n</code></pre>  05. In English, the statement \u201cI will not not speak\u201d means the same as \u201cI will speak.\u201d In C++, is <code>!!x</code> the same as <code>x</code>?   //My answer No. Return from `!!x` is boolean/int, while `x` have defined type by programmer  // Answer in the book Not necessarily. For example, if `x` is 10, then `!x` is 0 and `!!x` is 1. However, if `x` is a `bool` variable, then `!!x` is `x` .   06. Construct a conditional expression that is equal to the absolute value of a variable. That is, if a variable x is positive, the value of the expression is just x, but if x is negative, the value of the expression is -x, which is positive.   <pre><code>// x &gt; 0 ? x : -x\n\n(x &lt; 0)? -x : x\n// or\n(x &gt;= 0)? x : -x;\n</code></pre>  07. Rewrite the following fragment using switch:  <pre><code>if (ch == 'A')\n    a_grade++;\nelse if (ch == 'B')\n    b_grade++;\nelse if (ch == 'C')\n    c_grade++;\nelse if (ch == 'D')\n    d_grade++;\nelse\n    f_grade++;\n</code></pre> <pre><code>switch (ch)\n{\n    case `A`:   a_grade++;\n                break;\n    case `B`:   b_grade++;\n                break;\n    case `C`:   c_grade++;\n                break;\n    case `D`:   d_grade++;\n                break;\n    default:    f_grade++;\n                break;\n}\n</code></pre>  08. In Listing 6.10, what advantage would there be in using character labels, such as a and c, instead of numbers for the menu choices and switch cases? (Hint: Think about what happens if the user types q in either case and what happens if the user types 5 in either case.)  <pre><code>Listing 6.10 switch.cpp\n// switch.cpp -- using the switch statement\n#include &lt;iostream&gt;\n    using namespace std;\nvoid showmenu(); // function prototypes\nvoid report();\nvoid comfort();\nint main()\n{\n    showmenu();\n    int choice;\n    cin &gt;&gt; choice;\n    while (choice != 5)\n    {\n        switch (choice)\n        {\n        case 1:\n            cout &lt;&lt; \"\\a\\n\";\n            break;\n        case 2:\n            report();\n            break;\n        case 3:\n            cout &lt;&lt; \"The boss was in all day.\\n\";\n            break;\n        case 4:\n            comfort();\n            break;\n        default:\n            cout &lt;&lt; \"That's not a choice.\\n\";\n        }\n        showmenu();\n        cin &gt;&gt; choice;\n    }\n    cout &lt;&lt; \"Bye!\\n\";\n    return 0;\n}\nvoid showmenu()\n{\n    cout &lt;&lt; \"Please enter 1, 2, 3, 4, or 5:\\n\"\n            \"1) alarm 2) report\\n\"\n            \"3) alibi 4) comfort\\n\"\n            \"5) quit\\n\";\n}\nvoid report()\n{\n    cout &lt;&lt; \"It's been an excellent week for business.\\n\"\n            \"Sales are up 120%. Expenses are down 35%.\\n\";\n}\nvoid comfort()\n{\n    cout &lt;&lt; \"Your employees think you are the finest CEO\\n\"\n            \"in the industry. The board of directors think\\n\"\n            \"you are the finest CEO in the industry.\\n\";\n}\n</code></pre>  // Character labels would be more resistant to invalid input (characters promoted to int instead numbers);  // It would also not go into infinite loop due to buffered characters from user input    If you use integer labels and the user types a noninteger such as q, the program hangs because integer input can\u2019t process a character. But if you use character labels and the user types an integer such as 5, character input will process 5 as a character. Then the default part of the switch can suggest entering another character.   09. Consider the following code fragment:  <pre><code>int line = 0;\nchar ch;\nwhile (cin.get(ch))\n{\n    if (ch == 'Q')\n        break;\n    if (ch != '\\n')\n        continue;\n    line++;\n}\n</code></pre>  Rewrite this code without using break or continue.   <pre><code>int line = 0;\nchar ch;\nwhile (cin.get(ch) &amp;&amp; ch != 'Q')\n{\n    if (ch == '\\n')\n        line++;\n}\n</code></pre>"},{"location":"#chapter-7","title":"Chapter 7","text":"01. What are the three steps in using a function?  <pre><code>// Definition\n// Prototype\n// Caller\n</code></pre>  The three steps are defining the function, providing a prototype, and calling the function.    02. Construct function prototypes that match the following descriptions:  - <code>igor()</code> takes no arguments and has no return value. - <code>tofu()</code> takes an int argument and returns a float. - <code>mpg()</code> takes two type double arguments and returns a double. - <code>summation()</code> takes the name of a long array and an array size as values and returns a long value. - <code>doctor()</code> takes a string argument (the string is not to be modified) and returns a double value. - <code>ofcourse()</code> takes a boss structure as an argument and returns nothing. - <code>plot()</code> takes a pointer to a map structure as an argument and returns a string. <pre><code>void igor(void); // or void igor()\nfloat tofu(int n); // or float tofu(int);\ndouble mpg(double miles, double gallons);\nlong summation(long harray[], int size);\ndouble doctor(const char * str);\nvoid ofcourse(boss dude);\nchar * plot(map *pmap);\n</code></pre>  03. Write a function that takes three arguments: the name of an int array, the array size, and an int value. Have the function set each element of the array to the int value.  <pre><code>void set_array(int arr[], int size, int value)\n{\n    for (int i = 0; i &lt; size; i++)\n    arr[i] = value;\n}\n</code></pre>  04. Write a function that takes three arguments: a pointer to the first element of a range in an array, a pointer to the element following the end of a range in an array, and an int value. Have the function set each element of the array to the int value.  <pre><code>// // My solution -&gt; tested \n// fnTemp(int *begin, int *end, int val){\n//     int i{};\n//     while(*(begin + i) != *end){\n//         *(begin + i) = val;\n//         ++i;\n//     }\n// }\n\nvoid set_array(int * begin, int * end, int value)\n{\n    for (int * pt = begin; pt != end; pt++)\n    pt* = value;\n}\n</code></pre>  05. Write a function that takes a double array name and an array size as arguments and returns the largest value in that array. Note that this function shouldn\u2019t alter the contents of the array.  <pre><code>// // My solution -&gt; tested \n// double fnTemp(const double name[], int size){\n//     double max = name[0];\n//     for(int i {}; i &lt; size; ++i)\n//         if(name[i] &gt; max)\n//             max = name[i];\n//     return max;\n// }\n\ndouble biggest (const double foot[], int size)\n{\n    double max;\n    if (size &lt; 1)\n    {\n        cout &lt;&lt; \"Invalid array size of \" &lt;&lt; size &lt;&lt; endl;\n        cout &lt;&lt; \"Returning a value of 0\\n\";\n        return 0;\n    }\n    else // not necessary because return terminates program\n    {\n        max = foot[0];\n        for (int i = 1; i &lt; size; i++)\n        if (foot[i] &gt; max)\n        max = foot[i];\n        return max;\n    }\n}\n</code></pre>  06. Why don\u2019t you use the const qualifier for function arguments that are one of the fundamental types?  You use the const qualifier with pointers to protect the original pointed-to data from being altered. When a program passes a fundamental type such as an int or a double, it passes it by value so that the function works with a copy. Thus, the original data is already protected.   07. What are the three forms a C-style string can take in a C++ program?  <pre><code>char str[]; \n\"asdf\";\nchar *ptr = &amp;str;\n</code></pre>  A string can be stored in a <code>char array</code> , it can be represented by a string constant in double quotation marks, and it can be represented by a pointer pointing to the first character of a string.   08. Write a function that has this prototype:  <pre><code>int replace(char * str, char c1, char c2);\n</code></pre>  Have the function replace every occurrence of c1 in the string str with c2, and have the function return the number of replacements it makes.  <pre><code>int replace(char * str, char c1, char c2)\n{\n    int count = 0;\n    while (*str) // while not at end of string\n    {\n        if (*str == c1)\n        {\n            *str = c2;\n            count++;\n        }\n        str++; // advance to next character\n    }\nreturn count;\n}\n</code></pre>  09. What does the expression <code>*\"pizza\"</code> mean? What about <code>\"taco\"[2]</code>?   Because C++ interprets <code>\"pizza\"</code> as the address of its first element, applying the <code>*</code> operator yields the value of that first element, which is the character <code>p</code>. Because C++ interprets <code>\"taco\"</code> as the address of its first element, it interprets <code>\"taco\"[2]</code> as the value of the element two positions down the line that is, as the character <code>c</code> . In other words, the string constant acts the same as an array name   10. C++ enables you to pass a structure by value, and it lets you pass the address of a structure. If glitz is a structure variable, how would you pass it by value? How would you pass its address? What are the trade-offs of the two approaches?  <pre><code>// My answer\nBy value: fun(glitz)\n- it copies everything from glitz to local structure - less efficient\n\nBy address: fun(*glitz)\n- operates on original data - more prone to data corruption \n- less understandable, use indirect membership operator (-&gt;)\n</code></pre>  // Answer in the book To pass it by value, you just pass the structure name <code>glitz</code> . To pass its address, you use the address operator <code>&amp;glitz</code>. Passing by the value automatically protects the original data, but it takes time and memory. Passing by address saves time and memory but doesn\u2019t protect the original data unless you use the const modifier for the function parameter. Also passing by value means you can use ordinary structure member notation, but passing a pointer means you have to remember to use the indirect membership operator.   11. The function <code>judge()</code> has a type <code>int</code> return value. As an argument, it takes the address of a function. The function whose address is passed, in turn, takes a pointer to a const char as an argument and returns an int. Write the function prototype.   <pre><code>int judge (int (*pf)(const char *));\n</code></pre>  12. Suppose we have the following structure declaration:  <pre><code>struct applicant {\n    char name[30];\n    int credit_ratings[3];\n};\n</code></pre>  - Write a function that takes an applicant structure as an argument and displays its contents. - Write a function that takes the address of an applicant structure as an argument and displays the contents of the pointed-to structure    // My answer <pre><code>fnTemp(applicant)(\n    std::cout &lt;&lt; applicant.name &lt;&lt; \"  \" &lt;&lt; applicant.credit_ratings;\n)\n\nfnTemp(*applicant)(\n    std::cout &lt;&lt; applicant-&gt;name &lt;&lt; \"  \" &lt;&lt; applicant-&gt;credit_ratings;\n)\n</code></pre>  // Answer in the book  a. Note that if <code>ap</code> is an applicant structure, then <code>ap.credit_ratings</code> is an array name and <code>ap.credit_ratings[i]</code> is an array element.  <pre><code>void display(applicant ap)\n{\n    cout &lt;&lt; ap.name &lt;&lt; endl;\n    for (int i = 0; i &lt; 3; i++)\n        cout &lt;&lt; ap.credit_ratings[i] &lt;&lt; endl;\n}\n</code></pre>  b. Note that if pa is a pointer to an applicant structure, then <code>pa-&gt;credit_ratings</code> is an array name and <code>pa-&gt;credit_ratings[i]</code> is an array element.  <pre><code>void show(const applicant * pa)\n{\n    cout &lt;&lt; pa-&gt;name &lt;&lt; endl;\n    for (int i = 0; i &lt; 3; i++)\n        cout &lt;&lt; pa-&gt;credit_ratings[i] &lt;&lt; endl;\n}\n</code></pre>  13. Suppose the functions <code>f1()</code> and <code>f2()</code> have the following prototypes:  <pre><code>void f1(applicant * a);\nconst char * f2(const applicant * a1, const applicant * a2);\n</code></pre>  Declare <code>p1</code> as a pointer that points to <code>f1</code> and <code>p2</code> as a pointer to <code>f2</code> . Declare <code>ap</code> as an array of five pointers of the same type as <code>p1</code> , and declare <code>pa</code> as a pointer to an array of ten pointers of the same type as <code>p2</code> . Use <code>typedef</code> as an aid.   <pre><code>typedef void (*p_f1)(applicant *);\np_f1 p1 = f1;\ntypedef const char * (*p_f2)(const applicant *, const applicant *);\np_f2 p2 = f2;\np_f1 ap[5];\np_f2 (*pa)[10];\n</code></pre>"},{"location":"#chapter-8","title":"Chapter 8","text":"01. What kinds of functions are good candidates for inline status?  // Short ones. // The ones, that are not repeatable  Short, nonrecursive functions that can fit in one line of code are good candidates for <code>inline status</code> .   02. Suppose the <code>song()</code> function has this prototype:  <pre><code>void song(const char * name, int times);\n</code></pre>  a. How would you modify the prototype so that the default value for <code>times</code> is <code>1</code>? b. What changes would you make in the function definition? c. Can you provide a default value of <code>\"O, My Papa\"</code> for name?    a.  <pre><code>void song(const char * name, int times = 1);\n</code></pre>  b. None. Only prototypes contain the default value information.  c. Yes, provided that you retain the default value for times:  <pre><code>void song(char * name = \"O, My Papa\", int times = 1);\n</code></pre>  03. Write overloaded versions of <code>iquote()</code>, a function that displays its argument enclosed in double quotation marks. Write three versions: one for an <code>int</code> argument, one for a <code>double</code> argument, and one for a <code>string</code> argument.   You can use either the string <code>\"\\\"\"</code> or the character <code>\"</code> to print a quotation mark. The following functions show both methods:  <pre><code>#include &lt;iostream.h&gt;\nvoid iquote(int arg){\n    cout &lt;&lt; \"\\\"\" &lt;&lt; arg &lt;&lt; \"\\\"\" &lt;&lt; endl;\n}\n\nvoid iquote(double arg){\n    cout &lt;&lt; \"\\\"\" &lt;&lt; arg &lt;&lt; \"\\\"\" &lt;&lt; endl;\n}\n\nvoid iquote(const char * str){\n    cout &lt;&lt; \"\\\"\" &lt;&lt; arg &lt;&lt; \"\\\"\" &lt;&lt; endl;\n}\n</code></pre>  04. The following is a structure template:  <pre><code>struct box\n{\n    char maker[40];\n    float height;\n    float width;\n    float length;\n    float volume;\n};\n</code></pre>  a. Write a function that has a reference to a <code>box</code> structure as its formal argument and displays the value of each member. b. Write a function that has a reference to a <code>box</code> structure as its formal argument and sets the <code>volume</code> member to the product of the other three dimensions.    a. This function shouldn\u2019t alter the structure members, so use the const qualifier:  <pre><code>void show_box(const box &amp; container)\n{\n    cout &lt;&lt; \"Made by \" &lt;&lt; container. maker &lt;&lt; endl;\n    cout &lt;&lt; \"Height = \" &lt;&lt; container.height &lt;&lt; endl;\n    cout &lt;&lt; \"Width = \" &lt;&lt; container.width &lt;&lt; endl;\n    cout &lt;&lt; \"Length = \" &lt;&lt; container.length &lt;&lt; endl;\n    cout &lt;&lt; \"Volume = \" &lt;&lt; container.volume &lt;&lt; endl;\n}\n</code></pre>  b.  <pre><code>void set_volume(box &amp; crate)\n{\n    crate.volume = crate.height * crate.width * crate.length;\n}\n</code></pre>  05. What changes would need be made to Listing 7.15 (arrobj) so that the functions <code>fill()</code> and <code>show()</code> use reference parameters?   Note that <code>show()</code> should use const to protect the object from being modified. Next, within <code>main()</code> , change the <code>fill()</code> call to this:  Note that <code>(*pa)[i]</code> gets changed to the simpler <code>pa[i]</code> . Finally, the only change to <code>show()</code> is to the function header.  <pre><code>// arrobj.cpp -- functions with array objects (C++11)\n#include &lt;iostream&gt;\n#include &lt;array&gt;\n#include &lt;string&gt;\n\n// constant data\nconst int Seasons = 4;\nconst std::array&lt;std::string, Seasons&gt; Snames =\n    {\"Spring\", \"Summer\", \"Fall\", \"Winter\"};\n\n// function to modify array object\nvoid fill(std::array&lt;double, Seasons&gt; &amp;pa);\n// function that uses array object without modifying it\nvoid show(const std::array&lt;double, Seasons&gt; &amp;da);\n\nint main()\n{\n    std::array&lt;double, Seasons&gt; expenses;\n    fill(expenses);\n    show(expenses);\n    return 0;\n}\n\nvoid fill(std::array&lt;double, Seasons&gt; &amp;pa)\n{\n    using namespace std;\n    for (int i = 0; i &lt; Seasons; i++)\n    {\n        cout &lt;&lt; \"Enter \" &lt;&lt; Snames[i] &lt;&lt; \" expenses: \";\n        cin &gt;&gt; pa[i];\n    }\n}\n\nvoid show(const std::array&lt;double, Seasons&gt; &amp;da)\n{\n    using namespace std;\n    double total = 0.0;\n    cout &lt;&lt; \"\\nEXPENSES\\n\";\n    for (int i = 0; i &lt; Seasons; i++)\n    {\n        cout &lt;&lt; Snames[i] &lt;&lt; \": $\" &lt;&lt; da[i] &lt;&lt; endl;\n        total += da[i];\n    }\n    cout &lt;&lt; \"Total Expenses: $\" &lt;&lt; total &lt;&lt; endl;\n}\n</code></pre>  06. The following are some desired effects. Indicate whether each can be accomplished with default arguments, function overloading, both, or neither. Provide appropriate prototypes.  a. <code>mass(density, volume)</code> returns the mass of an object having a density of <code>density</code> and a volume of <code>volume</code> , whereas<code>mass(density)</code> returns the mass having a density of<code>density</code> and a <code>volume</code> of 1.0 cubic meters. All quantities are type<code>double</code>. b. <code>repeat(10, \"I'm OK\")</code> displays the indicated string 10 times, and <code>repeat(\"But you're kind of stupid\")</code> displays the indicated string 5 times. c. <code>average(3, 6)</code> returns the int average of two int arguments, and <code>average(3.0, 6.0)</code> returns the double average of two double values. d. <code>mangle(\"I'm glad to meet you\")</code> returns the character I or a pointer to the string \"I'm mad to gleet you\", depending on whether you assign the return value to a char variable or to a char* variable. <pre><code>// My answer\ndouble mass(double density, double volume = 1);\n\nvoid repeat(int num, const char * words[]);\nvoid repeat(const char * words[], int num = 5);\n\nint average(int numA, int numB);\ndouble average(double numA, double numB);\n\n???\n</code></pre> <pre><code>// Answer in the book\n// a. This can be done by using a default value for the second argument:\ndouble mass(double d, double v = 1.0);\nIt can also be done by using function overloading:\ndouble mass(double d, double v);\ndouble mass(double d);\n\n// b. You can\u2019t use a default for the repeat value because you have to provide\n// default values from right to left. You can use overloading:\nvoid repeat(int times, const char * str);\nvoid repeat(const char * str);\n\n// c. You can use function overloading:\nint average(int a, int b);\ndouble average(double x, double y);\n\n// d. You can\u2019t do this because both versions would have the same signature.\n</code></pre>  07. Write a function template that returns the larger of its two arguments.  <pre><code>// My answer\ntemplate &lt;typename t1, typpename t2&gt;\nauto(t1 myTypeA, t2 myTypeB){\n    return myTypeA &gt; myTypeB ? myTypeA : myTypeB;\n}\n</code></pre> <pre><code>template&lt;class T&gt;\nT max(T t1, T t2) // or T max(const T &amp; t1, const T &amp; t2)\n{\n    return t1 &gt; t2? t1 : t2;\n}\n</code></pre>  08. Given the template of Chapter Review Question 7 and the box structure of Chapter Review Question 4, provide a template specialization that takes two box arguments and returns the one with the larger volume.  <pre><code>template&lt;&gt; box max(box b1, box b2)\n{\n    return b1.volume &gt; b2.volume? b1 : b2;\n}\n</code></pre>  09. What types are assigned to v1, v2, v3, v4, and v5 in the following code (assuming the code is part of a complete program)?  <pre><code>int g(int x);\n...\nfloat m = 5.5f;\nfloat &amp; rm = m;\ndecltype(m) v1 = m;\ndecltype(rm) v2 = m;\ndecltype((m)) v3 = m;\ndecltype (g(100)) v4;\ndecltype (2.0 * m) v5;\n</code></pre> <pre><code>v1 = float\nv2 = float &amp;\nv3 = float\nv4 = int\nv5 = double (The literal 2.0 is type double)\n</code></pre>"},{"location":"#chapter-9","title":"Chapter 9","text":"01. What storage scheme would you use for the following situations?  a. <code>homer</code> is a formal argument (parameter) to a function. b. The <code>secret</code> variable is to be shared by two files. c. The <code>topsecret</code> variable is to be shared by the functions in one file but hidden from other files. d. <code>beencalled</code> keeps track of how many times the function containing it has been called.   a. <code>homer</code> is automatically an automatic variable. b. <code>secret</code> should be defined as an external variable in one file and declared using extern in the second file. c. <code>topsecret</code> could be defined as a static variable with internal linkage by prefacing the external definition with the keyword static. Or it could be defined in an unnamed namespace. d. <code>beencalled</code> should be defined as a local static variable by prefacing a declaration in the function with the keyword static.  02. Describe the differences between a <code>using</code> declaration and a <code>using</code> directive   //Declaration will only allow to use one declared thing from namespace. //Directive will allow to use all things declared namespace.  A using declaration makes available a single name from a namespace, and it has the scope corresponding to the declarative region in which the using declaration occurs. A using directive makes available all the names in a namespace. When you use a using directive, it is as if you have declared the names in the smallest declarative region containing both the using declaration and the namespace itself.    03. Rewrite the following so that it doesn\u2019t use using declarations or using directives:  <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n    double x;\n    cout &lt;&lt; \"Enter value: \";\n    while (!(cin &gt;&gt; x))\n    {\n        cout &lt;&lt; \"Bad input. Please enter a number: \";\n        cin.clear();\n        while (cin.get() != '\\n')\n            continue;\n    }\n    cout &lt;&lt; \"Value = \" &lt;&lt; x &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    double x;\n    std::cout &lt;&lt; \"Enter value: \";\n    while (!(std::cin &gt;&gt; x))\n    {\n        std::cout &lt;&lt; \"Bad input. Please enter a number: \";\n        std::cin.clear();\n        while (std::cin.get() != '\\n')\n            continue;\n    }\n    std::cout &lt;&lt; \"Value = \" &lt;&lt; x &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>  04. Rewrite the following so that it uses using declarations instead of the using directive:  <pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    double x;\n    cout &lt;&lt; \"Enter value: \";\n    while (!(cin &gt;&gt; x))\n    {\n        cout &lt;&lt; \"Bad input. Please enter a number: \";\n        cin.clear();\n        while (cin.get() != '\\n')\n            continue;\n    }\n    cout &lt;&lt; \"Value = \" &lt;&lt; x &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n\n    double x;\n    cout &lt;&lt; \"Enter value: \";\n    while (!(cin &gt;&gt; x))\n    {\n        cout &lt;&lt; \"Bad input. Please enter a number: \";\n        cin.clear();\n        while (cin.get() != '\\n')\n            continue;\n    }\n    cout &lt;&lt; \"Value = \" &lt;&lt; x &lt;&lt; endl;\n    return 0;\n}\n</code></pre>  05. Suppose you want the <code>average(3,6)</code> function to return an int average of the two int arguments when it is called in one file, and you want it to return a double average of the two int arguments when it is called in a second file in the same program. How could you set this up?   You could have separate static function definitions in each file. Or each file could define the appropriate <code>average()</code> function in an unnamed namespace.    06. What will the following two-file program display?  <pre><code>// file1.cpp\n#include &lt;iostream&gt;\nusing namespace std;\nvoid other();\nvoid another();\nint x = 10;\nint y;\nint main()\n{\n    cout &lt;&lt; x &lt;&lt; endl;\n    {\n        int x = 4;\n        cout &lt;&lt; x &lt;&lt; endl;\n        cout &lt;&lt; y &lt;&lt; endl;\n    }\n    other();\n    another();\n    return 0;\n}\nvoid other()\n{\n    int y = 1;\n    cout &lt;&lt; \"Other: \" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; endl;\n}\n\n// file 2.cpp\n#include &lt;iostream&gt;\nusing namespace std;\nextern int x;\nnamespace\n{\n    int y = -4;\n}\nvoid another()\n{\n    cout &lt;&lt; \"another(): \" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; endl;\n}\n</code></pre> <pre><code>10\n4\n0 //?? - why, y is not initialized... - undefined\nOther: 10, 1\nanother(): 10, -4\n</code></pre>  07. What will the following program display?  <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nvoid other();\nnamespace n1\n{\n    int x = 1;\n}\nnamespace n2\n{\n    int x = 2;\n}\nint main()\n{\n    using namespace n1;\n    cout &lt;&lt; x &lt;&lt; endl;\n    {\n        int x = 4;\n        cout &lt;&lt; x &lt;&lt; \", \" &lt;&lt; n1::x &lt;&lt; \", \" &lt;&lt; n2::x &lt;&lt; endl;\n    }\n    using n2::x;\n    cout &lt;&lt; x &lt;&lt; endl;\n    other();\n    return 0;\n}\nvoid other()\n{\n    using namespace n2;\n    cout &lt;&lt; x &lt;&lt; endl;\n    {\n        int x = 4;\n        cout &lt;&lt; x &lt;&lt; \", \" &lt;&lt; n1::x &lt;&lt; \", \" &lt;&lt; n2::x &lt;&lt; endl;\n    }\n    using n2::x;\n    cout &lt;&lt; x &lt;&lt; endl;\n}\n</code></pre> <pre><code>1\n4, 1, 2\n2\n2\n4, 1, 2\n2\n</code></pre>"},{"location":"#chapter-10","title":"Chapter 10","text":"01. What is a class?   Schema for creating object.  A class is a definition of a user-defined type. A class declaration specifies how data is to be stored, and it specifies the methods (class member functions) that can be used to access and manipulate that data.    02. How does a class accomplish abstraction, encapsulation, and data hiding?   by division of methods and variables by <code>public</code> and <code>private</code>  A class represents the operations you can perform on a class object with a public interface of class methods; this is abstraction. The class can use private visibility (the default) for data members, meaning that the data can be accessed only through the member functions; this is data hiding. Details of the implementation, such as data representation and method code, are hidden; this is encapsulation.    03. What is the relationship between an object and a class?   Class is used for creating object and defining its behaviour. We can use object on operate on it in accordance to the methods defined in class.  A class defines a type, including how it can be used. An object is a variable or another data object, such as that produced by new, which is created and used according to the class definition. The relationship between a class and an object is the same as that between a standard type and a variable of that type    04. In what way, aside from being functions, are class function members different from class data members?   Class functions are used with objects and part of the processed data can be encapsulated.  If you create several objects of a given class, each object comes with storage for its own set of data. But all the objects use the one set of member functions. (Typically, methods are public and data members are private, but that\u2019s a matter of policy, not of class requirements.)    05. Define a class to represent a bank account. Data members should include the depositor\u2019s name, the account number (use a string), and the balance. Member functions should allow the following:  - Creating an object and initializing it. - Displaying the depositor\u2019s name, account number, and balance - Depositing an amount of money given by an argument - Withdrawing an amount of money given by an argument  Just show the class declaration, not the method implementations. (Programming Exercise 1 provides you with an opportunity to write the implementation.)  <pre><code>// #include &lt;cstring&gt;\n// class definition\nclass BankAccount\n{\nprivate:\n    char name[40]; // or std::string name;\n    char acctnum[25]; // or std::string acctnum;\n    double balance;\n    public:\nBankAccount(const char * client, const char * num, double bal = 0.0);\n    //or BankAccount(const std::string &amp; client,\n    // const std::string &amp; num, double bal = 0.0);\n    void show(void) const;\n    void deposit(double cash);\n    void withdraw(double cash);\n};\n</code></pre>  06. When are class constructors called? When are class destructors called?   constructors are called when object is created and during initialization. destructors are called when object is deleted or on the end of the program.  A class constructor is called when you create an object of that class or when you explicitly call the constructor. A class destructor is called when the object expires.    07. Provide code for a constructor for the bank account class from Chapter Review Question 5.   These are two possible solutions (note that you must include cstring or string.h in order to use <code>strncpy()</code> or else you must include <code>string</code> to use the string class):  <pre><code>BankAccount::BankAccount(const char * client, const char * num, double bal)\n{\n    strncpy(name, client, 39);\n    name[39] = '\\0';\n    strncpy(acctnum, num, 24);\n    acctnum[24] = '\\0';\n    balance = bal;\n}\n</code></pre>  or  <pre><code>BankAccount::BankAccount(const std::string &amp; client,\nconst std::string &amp; num, double bal)\n{\n    name = client;\n    acctnum = num;\n    balance = bal;\n}\n</code></pre>  Keep in mind that default arguments go in the prototype, not in the function definition.    08. What is a default constructor? What is the advantage of having one?   It initializes class without any arguments.  A default constructor either has no arguments or has defaults for all the arguments. Having a default constructor enables you to declare objects without initializing them, even if you\u2019ve already defined an initializing constructor. It also allows you to declare arrays.    09. Modify the Stock class definition (the version in stock20.h) so that it has member     functions that return the values of the individual data members. Note: A member     that returns the company name should not provide a weapon for altering the array.     That is, it can\u2019t simply return a string reference. It could return a const reference. <pre><code>// stock30.h\n#ifndef STOCK30_H_\n#define STOCK30_H_\n\nclass Stock\n{\nprivate:\n    std::string company;\n    long shares;\n    double share_val;\n    double total_val;\n    void set_tot() { total_val = shares * share_val; }\npublic:\n    Stock(); // default constructor\n    Stock(const std::string &amp; co, long n, double pr);\n    ~Stock() {} // do-nothing destructor\n    void buy(long num, double price);\n    void sell(long num, double price);\n    void update(double price);\n    void show() const;\n    const Stock &amp; topval(const Stock &amp; s) const;\n    int numshares() const { return shares; }\n    double shareval() const { return share_val; }\n    double totalval() const { return total_val; }\nconst string &amp; co_name() const { return company; }\n};\n</code></pre>  10. What are <code>this</code> and <code>*this</code>? <code>this</code>  - pointer to current object <code>*this</code> - dereferention of object (object itself)  The <code>this</code> pointer is available to class methods. It points to the object used to invoke the method. Thus, this is the address of the object, and <code>*this</code> represents the object itself."},{"location":"#chapter-11","title":"Chapter 11","text":"01. Use a member function to overload the multiplication operator for the <code>Stonewt</code> class; have the operator multiply the data members by a type double value. Note that this will require carry over for the stone\u2013pound representation. That is, twice 10 stone 8 pounds is 21 stone 2 pounds.   // My answer  <pre><code>class Stonewt{\n    private:\n        enum{Pds_to_stn = 14};\n        int stone;\n        double fracPound;\n        double pound;\n    public:\n        // code ...\n        Stonewt operator*(double mt){\n\n            stone     *= (int)mt;\n            fracPound += (int)mt % Pds_to_stn + mt - int(mt);\n\n            pound     *= mt;\n            stone     += (int)pound % Pds_to_stn;\n            pound     -= int(pound);\n\n            return dm;\n        }\n}\n</code></pre>  // Answer in the book  Here\u2019s a prototype for the class definition file and a function definition for the methods file:  <pre><code>// prototype\nStonewt operator*(double mult);\n\n// definition \u2014 let constructor do the work\nStonewt Stonewt::operator*(double mult)\n{\n    return Stonewt(mult * pounds);\n}\n</code></pre>  02. What are the differences between a friend function and a member function?   // My answer Friend functions have access to private data of a class (ivoked object).  // Answer in the book A member function is part of a class definition and is invoked by a particular object.The member function can access members of the invoking object implicitly, without using the membership operator. A friend function is not part of a class, so it\u2019s called as a straight function call. It can\u2019t access class members implicitly, so it must use the membership operator applied to an object passed as an argument. Compare, for instance, the answer to Review Question 1 with the answer to Review Question 4.    03. Does a nonmember function have to be a friend to access a class\u2019s members?   // My answer For the direct access to the private members - Yes For the direct access to the public members - No For indirect access - via public methods - No  // Answer in the book It must be a friend to access private members, but it doesn\u2019t have to be a friend to access public members.    04. Use a friend function to overload the multiplication operator for the Stonewt class; have the operator multiply the double value by the Stone value.   // My answer  <pre><code>class Stonewt{\n    private:\n        enum{Pds_to_stn = 14};\n        int stone;\n        double fracPound;\n        double pound;\n    public:\n        // code ...\n        friend Stonewt operator*(double mt, Stonewt &amp;dm){\n            Stone tmp;\n\n            tmp.stone = dm.stone;\n            tmp.fracPound = dm.fracPound;\n            tmp.pound = dm.pound;\n\n            tmp.stone     *= (int)mt;\n            tmp.fracPound += (int)mt % Pds_to_stn + mt - int(mt);\n\n            tmp.pound     *= mt;\n            tmp.stone     += (int)dm.pound % Pds_to_stn;\n            tmp.pound     -= int(dm.pound);\n\n            return tmp;\n        }\n}\n</code></pre>  // Answer in the book   Here\u2019s a prototype for the class definition file and a function definition for the methods file:  <pre><code>// prototype\nfriend Stonewt operator*(double mult, const Stonewt &amp; s);\n\n// definition \u2014 let constructor do the work\nStonewt operator*(double mult, const Stonewt &amp; s)\n{\n    return Stonewt(mult * s.pounds);\n}\n</code></pre>  05. Which operators cannot be overloaded?   The following five operators cannot be overloaded:  <pre><code>sizeof\n.\n.*\n::\n? :\n</code></pre>  06. What restriction applies to overloading the following operators? <code>=</code>, <code>()</code>, <code>[]</code>, and <code>-&gt;</code>   These operations cannot overload basic functions they currently perform, thus they need to be defined by using a member function.    07. Define a conversion function for the Vector class that converts a Vector object to a type double value that represents the vector\u2019s magnitude.   // My answer - it should be by simple context.. again  <pre><code>class Vector{\n    private:\n        double x;\n        double y;\n    public:\n        // code ...\n        // option 1\n        double conv(Vector vc) const{\n            return sqrt(vc.x * vc.x + vc.y * vc.y);\n        }\n        // option 2\n        operator double(){\n            return sqrt(vc.x * vc.x + vc.y * vc.y);\n        }\n}\n</code></pre>  // Answer in the book  Here are a possible prototype and definition:  <pre><code>// prototype and inline definition\noperator double () {return mag;}\n</code></pre>  Note, however, that it makes better sense to use the <code>magval()</code> method than to define this conversion function."},{"location":"#chapter-12","title":"Chapter 12","text":"01. Suppose a String class has the following private members:  <pre><code>class String\n{\n    private:\n    char * str; // points to string allocated by new\n    int len; // holds length of string\n    //...\n};\n</code></pre>  a. What\u2019s wrong with this default constructor?  <pre><code>String::String() {}\n</code></pre>  b. What\u2019s wrong with this constructor?  <pre><code>String::String(const char * s)\n{\n    str = s;\n    len = strlen(s);\n}\n</code></pre>  c. What\u2019s wrong with this constructor?  <pre><code>String::String(const char * s)\n{\n    strcpy(str, s);\n    len = strlen(s);\n}\n</code></pre>   a. Constructor won't initialize data for proper use of object b. It is so called `shallow copy` for str. It will copy only pointer `s` to string, thus two objects will point into the same string c. `s` is `const` and is put into function  // Answer in the book  a. The syntax is fine, but this constructor leaves the `str` pointer uninitialized. The constructor should either set the pointer to NULL or use `new []` to initialize the pointer. b. This constructor does not create a new string; it merely copies the address of the old string. It should use `new []` and `strcpy()`. c. It copies the string without allocating the space to store it. It should use new `char[len + 1]` to allocate the proper amount of memory.    02. Name three problems that may arise if you define a class in which a pointer member is initialized by using <code>new</code>. Indicate how they can be remedied.   // Answer in the book  First, when an object of that type expires, the data pointed to by the object\u2019s member pointer remains in memory, using space and remaining inaccessible because the pointer has been lost. That can be fixed by having the class destructor delete memory allocated by `new` in the constructor functions.  Second, after the destructor deletes such memory, it might end up trying to delete it twice if a program initializes one such object to another.That\u2019s because the default initialization of one object to another copies pointer values but does not copy the pointed-to data, and this produces two pointers to the same data.The solution is to define a class copy constructor that causes initialization to copy the pointed-to data.  Third, assigning one object to another can produce the same situation of two pointers pointing to the same data. The solution is to overload the assignment operator so that it copies the data, not the pointers.  03. What class methods does the compiler generate automatically if you don\u2019t provide them explicitly? Describe how these implicitly generated functions behave.   // Answer in the book  - A default constructor if you define no constructors - A copy constructor if you don\u2019t define one - An assignment operator if you don\u2019t define one - A default destructor if you don\u2019t define one - An address operator if you don\u2019t define one  The default constructor does nothing, but it allows you to declare arrays and uninitialized objects. The default copy constructor and the default assignment operator use memberwise assignment.The default destructor does nothing.The implicit address operator returns the address of the invoking object (that is, the value of the `this` pointer).    04. Identify and correct the errors in the following class declaration:  <pre><code>class nifty\n{\n    // data\n    char personality[];\n    int talents;\n    // methods\n    nifty();\n    nifty(char *s);\n    ostream &amp;operator&lt;&lt;(ostream &amp;os, nifty &amp;n);\n} \n\nnifty : nifty()\n{\n    personality = NULL;\n    talents = 0;\n}\n\nnifty : nifty(char *s)\n{\n    personality = new char[strlen(s)];\n    personality = s;\n    talents = 0;\n}\n\nostream &amp;nifty : operator&lt;&lt;(ostream &amp; os, nifty &amp; n)\n{\n    os &lt;&lt; n;\n}\n</code></pre> <pre><code>class nifty\n{\n    // data\n    char personality[];\n    int talents;\n    // methods\n    nifty();\n    nifty(char *s);\n    ostream &amp;operator&lt;&lt;(ostream &amp;os, nifty &amp;n);\n\n    // Lack of destructor, when new is used\n    ~nifty();\n\n    // Lack of assignment operator - shallow copy error\n    nifty &amp;operator=(nifty n);\n} \n\nnifty : nifty()\n{\n    personality = NULL;\n    talents = 0;\n}\n\nnifty : nifty(char *s)\n{\n    personality = new char[strlen(s)];\n    // personality = s; // pointer assigned - shallow copy\n    strcpy(personality, s);\n    talents = 0;\n}\n\nostream &amp;nifty : operator&lt;&lt;(ostream &amp; os, nifty &amp; n)\n{\n    os &lt;&lt; n;\n}\n\n~nifty : nifty(){\n    delete personality;\n}\n\nnifty &amp;operator=(nifty n){\n    if(personality != NULL)\n        delete personality;\n    personality = new char[strlen(n.personality)];\n    strcpy(personality, n.personality);\n    talents = n.talents;\n}\n</code></pre>  // Answer in the book  The personality member should be declared either as a character array or as a pointer-to-char. Or you could make it a String object or a string object. The declaration fails to make the methods public. Then there are several small errors. Here is a possible solution, with changes (other than deletions) in boldface:  <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nclass nifty\n{\nprivate:                  // optional\n    char personality[40]; // provide array size\n    int talents;\n\npublic: // needed\n    // methods\n    nifty();\n    nifty(const char *s);\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const nifty &amp;n);\n}; // note closing semicolon\nnifty::nifty()\n{\n    personality[0] = '\\0';\n    talents = 0;\n}\nnifty::nifty(const char *s)\n{\n    strcpy(personality, s);\n    talents = 0;\n}\nostream &amp;operator&lt;&lt;(ostream &amp;os, const nifty &amp;n)\n{\n    os &lt;&lt; n.personality &lt;&lt; '\\n';\n    os &lt;&lt; n.talent &lt;&lt; '\\n';\n    return os;\n}\n</code></pre>  05. Consider the following class declaration: <pre><code>class Golfer\n{\nprivate:\n    char *fullname; // points to string containing golfer's name\n    int games;      // holds number of golf games played\n    int *scores;    // points to first element of array of golf scores\npublic:\n    Golfer();\n    Golfer(const char *name, int g = 0);\n    // creates empty dynamic array of g elements if g &gt; 0\n    Golfer(const Golfer &amp;g);\n    ~Golfer();\n};\n</code></pre>  a. What class methods would be invoked by each of the following statements ?  <pre><code>Golfer nancy;                    // #1\nGolfer lulu(\u201cLittle Lulu\u201d);      // #2\nGolfer roy(\u201cRoy Hobbs\u201d, 12);     // #3\nGolfer *par = new Golfer;        // #4\nGolfer next = lulu;              // #5\nGolfer hazzard = \u201cWeed Thwacker\u201d;// #6\n*par = nancy;                    // #7 \nnancy = \u201cNancy Putter\u201d;          // #8\n</code></pre>  b. Clearly, the class requires several more methods to make it useful. What additional     method does it require to protect against data corruption?    a.  <pre><code>Golfer nancy;                    // #1 Golfer()\nGolfer lulu(\u201cLittle Lulu\u201d);      // #2 Golfer(const char *name, int g = 0);\nGolfer roy(\u201cRoy Hobbs\u201d, 12);     // #3 Golfer(const char *name, int g = 0);\nGolfer *par = new Golfer;        // #4 Golfer operator=(Golfer *n);\nGolfer next = lulu;              // #5 Golfer operator=(Golfer n); // wrong\nGolfer hazzard = \u201cWeed Thwacker\u201d;// #6 Golfer operator=(String n); // wrong\n*par = nancy;                    // #7 Golfer *operator=(Golfer n); \nnancy = \u201cNancy Putter\u201d;          // #8 Golfer operator=(String n); // wrong\n</code></pre>  b.  <pre><code>Golfer &amp;operator=(const Golfer &amp;);\n</code></pre>  // Answer in the book  a.  <pre><code>Golfer nancy; // default constructor\nGolfer lulu(\"Little Lulu\"); // Golfer(const char * name, int g)\nGolfer roy(\"Roy Hobbs\", 12); // Golfer(const char * name, int g)\nGolfer * par = new Golfer; // default constructor\nGolfer next = lulu; // Golfer(const Golfer &amp;g)\nGolfer hazard = \"Weed Thwacker\"; // Golfer(const char * name, int g)\n*par = nancy; // default assignment operator\nnancy = \"Nancy Putter\";// Golfer(const char * name, int g), then\n// the default assignment operator\n</code></pre>  Note that some compilers additionally call the default assignment operator for Statements 5 and 6.  b. The class should define an assignment operator that copies data rather than addresses."},{"location":"#chapter-13","title":"Chapter 13","text":"01. What does a derived class inherit from a base class?   All public and protected methods and variables.  // Answer in the book  The public members of the base class become public members of the derived class. The protected members of the base class become protected members of the derived class.The private members of the base class are inherited but cannot be accessed directly. The answer to Review Question 2 provides the exceptions to these general rules.    02. What doesn\u2019t a derived class inherit from a base class?   The constructor methods are not inherited, the destructor is not inherited, the assignment operator is not inherited, and friends are not inherited.    03. Suppose the return type for the <code>baseDMA::operator=()</code> function were defined as <code>void</code> instead of <code>baseDMA &amp;</code>. What effect, if any, would that have? What if the return type were <code>baseDMA</code> instead of <code>baseDMA &amp;</code>?   `void` - returns nothing instead of reference to `baseDMA`, that is you would not be able to return `baseDMA` object and its data via `=` so the chain assignment wont work, only single assignment Returning object, not reference to it, makes execution slower due to necessity of copying everything to return it, instead of pointing to memory with already created object.  // Answer in the book  If the return type were void, you would still be able to use single assignment but not chain assignment:  <pre><code>baseDMA magazine(\"Pandering to Glitz\", 1);\nbaseDMA gift1, gift2, gift3;\ngift1 = magazine; // ok\ngift 2 = gift3 = gift1; // no longer valid\n</code></pre>  If the method returned an object instead of a reference, the method execution would be slowed a bit because the return statement would involve copying the object.    04. In what order are class constructors and class destructors called when a derived class object is created and deleted?   In reverse order to invoking constructors. In case of constructor with inheritance - it would be base class invoked via member initializator list `:`, constructed in order from left to right (in case of many classes).  // Answer in the book  Constructors are called in the order of derivation, with the most ancestral constructor called first. Destructors are called in the opposite order.    05. If a derived class doesn\u2019t add any data members to the base class, does the derived class require constructors?   Yes, and it need to invoke base class constructor.  // Answer in the book  Yes, every class requires its own constructors. If the derived class adds no new members, the constructor can have an empty body, but it must exist.    06. Suppose a base class and a derived class both define a method with the same name and a derived-class object invokes the method. What method is called?   Method in derived class.  // Answer in the book  Only the derived-class method is called. It supersedes the base-class definition.A base-class method is called only if the derived class does not redefine the method or if you use the scope-resolution operator. However, you really should declare as virtual any functions that will be redefined    07. When should a derived class define an assignment operator?   When it need to perform deep copy - that is, if it have dynamically allocated data.  // Answer in the book  The derived class should define an assignment operator if the derived-class constructors use the `new` or `new []` operator to initialize pointers that are members of that class. More generally, the derived class should define an assignment operator if the default assignment is incorrect for derived-class members.    08. Can you assign the address of an object of a derived class to a pointer to the base class? Can you assign the address of an object of a base class to a pointer to the derived class?   Yes to both. Pointer of derived class to base class is called upcasting. Pointer of base class to derived class is called downcasting.  // Answer in the book  Yes, you can assign the address of an object of a derived class to a pointer to the base class. You can assign the address of a base-class object to a pointer to a derived class (downcasting) only by making an explicit type cast, and it is not necessarily safe to use such a pointer.    09. Can you assign an object of a derived class to an object of the base class? Can you assign an object of a base class to an object of the derived class?   If you will make methods that will handle this - yes.  // Answer in the book  Yes, you can assign an object of a derived class to an object of the base class. Any data members that are new to the derived type are not passed to the base type, however. The program uses the base-class assignment operator. Assignment in the opposite direction (base to derived) is possible only if the derived class defines a `conversion operator`, which is a constructor that has a reference to the base type as its sole argument, or else defines an assignment operator with a base-class parameter.    10. Suppose you define a function that takes a reference to a base-class object as an argument. Why can this function also use a derived-class object as an argument?   Because it is inherited. Derived class object holds base class object.    // Answer in the book  It can do so because C++ allows a reference to a base type to refer to any type derived from that base.    11. Suppose you define a function that takes a base-class object as an argument (that is, the function passes a base-class object by value). Why can this function also use a derived-class object as an argument?   Because it is inherited. Derived class object holds base class object.    // Answer in the book  Passing an object by value invokes the copy constructor. Because the formal argument is a base-class object, the base-class copy constructor is invoked.The copy constructor has as its argument a reference to the base class, and this reference can refer to the derived object passed as an argument.The net result is that a new baseclass object whose members correspond to the base class portion of the derived object is produced    12. Why is it usually better to pass objects by reference than by value?   Because passing by value makes copy of an object, when reference is the address of the original object.   // Answer in the book  Passing an object by reference instead of by value enables the function to avail itself of virtual functions. Also passing an object by reference instead of by value may use less memory and time, particularly for large objects. The main advantage of passing by value is that it protects the original data, but you can accomplish the same end by passing the reference as a `const` type.    13. Suppose <code>Corporation</code> is a base class and <code>PublicCorporation</code> is a derived class. Also suppose that each class defines a <code>head()</code> member function, that <code>ph</code> is a pointer to the <code>Corporation</code> type, and that <code>ph</code> is assigned the address of a <code>PublicCorporation</code> object. How is <code>ph-&gt;head()</code> interpreted if the base class defines <code>head()</code> as a \u2003a. Regular nonvirtual method \u2003b. Virtual method   - via regular method - the `PublicCorporation-&gt;head()` will be invoked - via virtual method - the `Corporation-&gt;head()` will be invoked  // Answer in the book  If `head()` is a regular method, then `ph-&gt;head()` invokes `Corporation::head()`. If `head()` is a virtual function, then `ph-&gt;head()` invokes `PublicCorporation::head()`.    14. What\u2019s wrong, if anything, with the following code?  <pre><code>class Kitchen\n{\nprivate:\n    double kit_sq_ft;\n\npublic:\n    Kitchen() { kit_sq_ft = 0.0; }\n    virtual double area() const { return kit_sq_ft * kit_sq_ft; }\n};\n\nclass House : public Kitchen\n{\nprivate:\n    double all_sq_ft;\n\npublic:\n    House() { all_sq_ft += kit_sq_ft; }\n    double area(const char *s) const\n    {\n        cout &lt;&lt; s;\n        return all_sq_ft;\n    }\n};\n</code></pre>   Why `House` inherits `Kitchen`, instead containing it (it is has-a model) or via private deriviation(chapter 14)?   The keyword `virtual` in derived class `area` constructor don't need to be used, because base class function is overridden in a derived class via declared function as virtual in the base class. `Kitchen` and `House` constructors don't allow any input that assigns value to private values, which mean the `kit_sq_ft` and `all_sq_ft` will always be `0.0`.  // Answer in the book  First, the situation does not fit the is-a model, so public inheritance is not appropriate. Second, the definition of `area()` in `House` hides the `Kitchen` version of `area()` because the two methods have different signatures."},{"location":"#chapter-14","title":"Chapter 14","text":"01. For each of the following sets of classes, indicate whether public or private derivation is more appropriate for Column B:  |Lp|A|B| |---|---|---| |1|class Bear|class PolarBear| |2|class Kitchen|class Home| |3|class Person|class Programmer| |4|class Person|class HorseAndJockey| |5|class Person, class Automobile|class Driver|    // Answer in the book  1. Public; a polar bear is a kind of bear 2. Private; a home has a kitchen 3. Public; a programmer is a kind of person 4. Private; a horse and jockey team contains a person 5. Person public because a driver is a person; Automobile private because a driver has an automobile    02. Suppose you have the following definitions:  <pre><code>class Frabjous\n{\nprivate:\n    char fab[20];\n\npublic:\n    Frabjous(const char *s = \"C++\") : fab(s) {}\n    virtual void tell() { cout &lt;&lt; fab; }\n};\n\nclass Gloam\n{\nprivate:\n    int glip;\n    Frabjous fb;\n\npublic:\n    Gloam(int g = 0, const char *s = \"C++\");\n    Gloam(int g, const Frabjous &amp;f);\n    void tell();\n};\n</code></pre>  Given that the <code>Gloam</code> version of <code>tell()</code> should display the values of <code>glip</code> and <code>fb</code>, provide definitions for the three <code>Gloam</code> methods.   <pre><code>Gloam::Gloam(int g, const char *s)\n{\n    glip = g;\n    strcpy(fb.fab, s); \n}\n\nGloam::Gloam(int g, const Frabjous &amp;f)\n{\n    glip = g;\n    strcpy(fb.fab, f.fab);     \n}\n\nvoid Gloam::tell()\n{\n    cout &lt;&lt; glip;\n    cout &lt;&lt; fb.fab;\n}\n</code></pre>  // Answer in the book <pre><code>Gloam::Gloam(int g, const char * s) : glip(g), fb(s) { }\nGloam::Gloam(int g, const Frabjous &amp; fr) : glip(g), fb(fr) { }\n// note: the above uses the default Frabjous copy constructor\nvoid Gloam::tell()\n{\n    fb.tell();\n    cout &lt;&lt; glip &lt;&lt; endl;\n}\n</code></pre>  03. Suppose you have the following definitions:  <pre><code>class Frabjous\n{\nprivate:\n    char fab[20];\n\npublic:\n    Frabjous(const char *s = \"C++\") : fab(s) {}\n    virtual void tell() { cout &lt;&lt; fab; }\n};\n\nclass Gloam : private Frabjous\n{\nprivate:\n    int glip;\n\npublic:\n    Gloam(int g = 0, const char *s = \"C++\");\n    Gloam(int g, const Frabjous &amp;f);\n    void tell();\n};\n</code></pre>  Given that the <code>Gloam</code> version of <code>tell()</code> should display the values of <code>glip</code> and <code>fab</code>, provide definitions for the three <code>Gloam</code> methods.   <pre><code>// Gloam::Gloam(int g, const char *s) // wrong \n// {\n//     glip = g;\n//     this(s); // Error: this is a pointer, not a function - this keyword is a pointer to the current object, and it cannot be used to call constructor\n// }\n\n// Gloam::Gloam(int g, const Frabjous &amp;f) // wrong\n// {\n//     glip = g;\n//     this(f); // Error: this is a pointer, not a function\n// }\n\nGloam::Gloam(int g, const char * s)\n           : glip(g), Frabjous(s) { }\nGloam::Gloam(int g, const Frabjous &amp; fr)\n           : glip(g), Frabjous(fr) { }\n\nvoid Gloam::tell()\n{\n    cout &lt;&lt; glip;\n    Frabjous::tell();\n}\n</code></pre>  // Answer in the book <pre><code>Gloam::Gloam(int g, const char * s)\n            : glip(g), Frabjous(s) { }\nGloam::Gloam(int g, const Frabjous &amp; fr)\n            : glip(g), Frabjous(fr) { }\n// note: the above uses the default Frabjous copy constructor\nvoid Gloam::tell()\n{\n    Frabjous::tell();\n    cout &lt;&lt; glip &lt;&lt; endl;\n}\n</code></pre>  04. Suppose you have the following definition, based on the <code>Stack</code> template of Listing 14.13 (stacktp.h) and the <code>Worker</code> class of Listing 14.10 (workermi.h):  <pre><code>Stack&lt;Worker *&gt; sw;\n</code></pre>  Write out the class declaration that will be generated. Just do the class declaration, not the non-inline class methods.   <pre><code>template &lt;class Worker *&gt;\nclass Stack\n{\nprivate:\n    enum\n    {\n        MAX = 10\n    };               // constant specific to class\n    Worker * items[MAX]; // holds stack items\n    int top;         // index for top stack item\npublic:\n    Stack();\n    bool isempty();\n    bool isfull();\n    bool push(const Worker &amp;item); // add item to stack\n    bool pop(Worker &amp;item);        // pop top into item\n};\n</code></pre>  // Answer in the book <pre><code>class Stack&lt;Worker *&gt;\n{\nprivate:\n    enum {MAX = 10}; // constant specific to class\n    Worker * items[MAX]; // holds stack items\n    int top; // index for top stack item\npublic:\n    Stack();\n    Boolean isempty();\n    Boolean isfull();\n    Boolean push(const Worker * &amp; item); // add item to stack\n    Boolean pop(Worker * &amp; item); // pop top into item\n};\n</code></pre>  05. Use the template definitions in this chapter to define the following:  - An array of <code>string</code> objects - A stack of arrays of <code>double</code> - An array of stacks of pointers to <code>Worker</code> objects  How many template class definitions are produced in Listing 14.18 (twod.cpp)?   <pre><code>vector&lt;std::string&gt; one;\nStack&lt;vector&lt;double&gt;&gt; two;\nvector&lt;Stack&lt;* Worker&gt;&gt; three;\n</code></pre>  In `twop.cpp` 4 template class definitions are produced    // Answer in the book <pre><code>ArrayTP&lt;string&gt; sa;\nStackTP&lt; ArrayTP&lt;double&gt; &gt; stck_arr_db;\nArrayTP&lt; StackTP&lt;Worker *&gt; &gt; arr_stk_wpr;\n</code></pre>  Listing 14.18 generates four templates: `ArrayTP`, `ArrayTP`, `ArrayTP`, and `Array&lt; ArrayTP, 10&gt;`.    06. Describe the differences between virtual and nonvirtual base classes.   In case of upcasting, the base class methods for nonvirtual base class will not be invoked, which can result in errors  // Answer in the book  If two lines of inheritance for a class share a common ancestor, the class winds up having two copies of the ancestor\u2019s members. Making the ancestor class a virtual base class to its immediate descendants solves that problem."},{"location":"#chapter-15","title":"Chapter 15","text":"01. What\u2019s wrong with the following attempts at establishing friends?  a.  <pre><code>class snap\n{\n    friend clasp;\n    ...\n};\nclass clasp\n{\n    ...\n};\n</code></pre>  b.  <pre><code>class cuff\n{\npublic:\n    void snip(muff &amp;){...}...\n};\nclass muff\n{\n    friend void cuff::snip(muff &amp;);\n    ...\n};\n</code></pre>  c.  <pre><code>class muff\n{\n    friend void cuff::snip(muff &amp;);\n    ...\n};\nclass cuff\n{\npublic:\n    void snip(muff &amp;){...}...\n};\n</code></pre>   // Answer in the book  a.The friend declaration should be as follows :  <pre><code>friend class clasp;\n</code></pre>  b.This needs a forward declaration so that the compiler can interpret void snip(muff &amp;) :  <pre><code>class muff; // forward declaration\nclass cuff\n{\npublic:\n    void snip(muff &amp;){...}...\n};\nclass muff\n{\n    friend void cuff::snip(muff &amp;);\n    ...\n};\n</code></pre>  c. First, the cuff class declaration should precede the muff class so that the compiler can understand the term cuff::snip(). Second, the compiler needs a forward declaration of muff so that it can understand snip(muff &amp;) :   <pre><code>class muff; // forward declaration\nclass cuff\n{\npublic:\n    void snip(muff &amp;){...}\n    ...\n};\nclass muff\n{\n    friend void cuff::snip(muff &amp;);\n    ...\n};\n</code></pre>  02. You\u2019ve seen how to create mutual class friends. Can you create a more restricted form of friendship in which only some members of Class B are friends to Class A and some members of A are friends to B? Explain.   With forward declaration:  <pre><code>class A; // forward declaration\n\nclass B{\n        friend void sync(A &amp;cA, B &amp;cB);\n}\n\nclass A{\n        friend void sync(A &amp;cA, B &amp;cB);\n}\n\n// only protected &amp; public members are shared - there is no more restrictive way\n</code></pre>  // Answer in the book  No. For Class A to have a friend that\u2019s a member function of Class B, the B declaration must precede the A declaration. A forward declaration is not enough because it would tell A that B is a class, but it wouldn\u2019t reveal the names of the class members. Similarly, if B has a friend that\u2019s a member function of A, the complete A declaration must precede the B declaration.These two requirements are mutually exclusive.    03. What problems might the following nested class declaration have?  <pre><code>class Ribs\n{\nprivate:\n    class Sauce\n    {\n        int soy;\n        int sugar;\n\n    public:\n        Sauce(int s1, int s2) : soy(s1), sugar(s2) {}\n    };\n    ...\n};\n</code></pre>   The public interface of nested Sauce class will only be visible (will have a scope of) Ribs class.  // Answer in the book  The only access to a class is through its public interface, which means the only thing you can do with a Sauce object is call the constructor to create one. The other members (soy and sugar) are private by default.    04. How does <code>throw</code> differ from <code>return</code>?    `throw()` will get directly into main - it is faster  `throw(fun)` can jump into desired function     // Answer in the book   Suppose the function f1() calls the function f2(). A return statement in f2() causes program execution to resume at the next statement following the f2() function call in function f1(). A throw statement causes the program to back up through the current sequence of function calls until it finds a try block that directly or indirectly contains the call to f2(). This might be in f1() or in a function that called f1(), and so on. Once there, execution goes to the next matching catch block, not to the first statement after the function call.    05. Suppose you have a hierarchy of exception classes that are derived from a base exception class. In what order should you place <code>catch</code> blocks?   // Answer in the book  You should arrange the catch blocks in order, from most derived class to least derived.    06. Consider the <code>Grand</code>, <code>Superb</code>, and <code>Magnificent</code> classes defined in this chapter. Suppose <code>pg</code> is a type <code>Grand * pointer</code> that is assigned the address of an object of one of these three classes and that <code>ps</code> is a type <code>Superb *</code> pointer.What is the difference in how the following two code samples behave?  <pre><code>if (ps = dynamic_cast&lt;Superb *&gt;(pg))\n    ps-&gt;say(); // sample #1\n\nif (typeid(*pg) == typeid(Superb))\n    (Superb *) pg-&gt;say(); // sample #2\n</code></pre>   sample1 - if with dynamic cast - will assign any class as long as it is safe sample2 - if with typeid - will only check if pg is the exact pointer of Superb class    // Answer in the book  For Sample #1, the if condition is true if pg points to a Superb object or to an object of any class descended from Superb. In particular, it is also true if pg points to a Magnificent object. In Sample #2, the if condition is true only for a Superb object, not for objects derived from Superb.    07. How is the <code>static_cast</code> operator different from the <code>dynamic_cast</code> operator?   static_cast is only valid when compiler can convert type name into the same type expression has,  while dynamic_cast can assigning into expression is safe (upcasting)  // Answer in the book  The dynamic_cast operator only allows upcasting in a class hierarchy, whereas a static_cast operator allows both upcasting and downcasting.The static_cast operator also allows conversions from enumeration types to integer types, and vice versa, and between various numeric types."},{"location":"#chapter-16","title":"Chapter 16","text":"01. Consider the following class declaration:  <pre><code>class RQ1\n{\nprivate:\n    char *st; // points to C-style string\npublic:\n    RQ1()\n    {\n        st = new char[1];\n        strcpy(st, \"\");\n    }\n    RQ1(const char *s)\n    {\n        st = new char[strlen(s) + 1];\n        strcpy(st, s);\n    }\n    RQ1(const RQ1 &amp;rq)\n    {\n        st = new char[strlen(rq.st) + 1];\n        strcpy(st, rq.st);\n    }\n    ~RQ1(){delete[] st};\n    RQ &amp;operator=(const RQ &amp;rq);\n    // more stuff\n};\n</code></pre>  Convert this to a declaration that uses a <code>string</code> object instead. What methods no longer need explicit definitions?   <pre><code>class RQ1\n{\nprivate:\n    std::string st;\npublic:\n    RQ1()\n    {\n        st = \"\";\n    }\n    RQ1(const char *s)\n    {\n        strcpy(st, s);\n    }\n    ~RQ1(){};\n    RQ &amp;operator=(const RQ &amp;rq);\n    // more stuff\n};\n</code></pre>  delete, (const RQ1 &amp;rq)  // Answer in the book <pre><code>#include &lt;string&gt;\nusing namespace std;\nclass RQ1\n{\nprivate:\n    string st; // a string object\npublic:\n    RQ1() : st(\"\") {}\n    RQ1(const char *s) : st(s) {}\n    ~RQ1(){};\n    // more stuff\n};\n</code></pre>  The explicit copy constructor, destructor, and assignment operator are no longer needed because the <code>string</code> object provides its own memory management.    02. Name at least two advantages <code>string</code> objects have over C-style strings in terms of ease-of-use.   - string obj is an object, thus use destructor - for c-style you need to remember yourself to deallocate data - string obj can be used with STL  // Answer in the book  You can assign one string object to another. A string object provides its own memory management so that you normally don\u2019t have to worry about a string exceeding the capacity of its holder    03. Write a function that takes a reference to a <code>string</code> object as an argument and that converts the <code>string</code> object to all uppercase. <pre><code>void fun(string &amp;st)\n{\n    st.toupper();\n}\n</code></pre>  // Answer in the book <pre><code>#include &lt;string&gt;\n#include &lt;cctype&gt;\nusing namespace std;\nvoid ToUpper(string &amp;str)\n{\n    for (int i = 0; i &lt; str.size(); i++)\n        str[i] = toupper(str[i]);\n}\n</code></pre>  04. Which of the following are not examples of correct usage (conceptually or syntactically) of <code>auto_ptr</code>? (Assume that the needed header files have been included.)  <pre><code>auto_ptr&lt;int&gt; pia(new int[20]);\nauto_ptr&lt;string&gt;(new string);\nint rigue = 7;\nauto_ptr&lt;int&gt; pr(&amp;rigue);\nauto_ptr dbl(new double);\n</code></pre>   `auto_ptr pia(new int[20]);` - table cannot be assigned to auto_ptr `auto_ptr(new string);` - name? `auto_ptr pr(&amp;rigue);` - reference to automatic value // runtime error `auto_ptr dbl(new double);` - lack of data type in &lt;&gt; // compile error  // Answer in the book <pre><code>auto_ptr&lt;int&gt; pia= new int[20]; // wrong, use with new, not new[]\nauto_ptr&lt;string&gt;(new string); // wrong, no name for pointer\nint rigue = 7;\nauto_ptr&lt;int&gt;(&amp;rigue); // wrong, memory not allocated by new\nauto_ptr dbl (new double); // wrong, omits &lt;double&gt;\n</code></pre>  05. If you could make the mechanical equivalent of a stack that held golf clubs instead of numbers, why would it (conceptually) be a bad golf bag?   Because you will need to get/open all golf before correct one.  // Answer in the book  The LIFO aspect of a stack means you might have to remove a lot of clubs before reaching the one you need    06. Why would a <code>set</code> container be a poor choice for storing a hole-by-hole record of your golf scores?   Because it can store only unique values.  // Answer in the book  The set will store just one copy of each value, so, say, five scores of 5 would be stored as a single 5.    07. Because a pointer is an iterator, why didn\u2019t the STL designers simply use pointers instead of iterators?   // Answer in the book  Using iterators allows you to use objects with a pointer-like interface to move through data that is organized in some fashion other than an array (for example, data in a doubly linked list).    08. Why didn\u2019t the STL designers simply define a base iterator class, use inheritance to derive classes for the other iterator types, and express the algorithms in terms of those iterator classes?   // Answer in the book  The STL approach allows STL functions to be used with ordinary pointers to ordinary arrays as well as with iterators to STL container classes, thus increasing generality.    09. Give at least three examples of convenience advantages that a <code>vector</code> object has over an ordinary array.   - Dynamic and simple data allocation - .pushback(data) - Use of STL: .size(), .sort()  - It uses destructor  // Answer in the book  You can assign one vector object to another. A vector manages its own memory, so you can insert items into a vector and have it resize itself automatically. By using the `at()` method, you can get automatic bounds checking.    10. If Listing 16.9 were implemented with <code>list</code> instead of vector, what parts of the program would become invalid? Could the invalid part be fixed easily? If so, how? <pre><code>// vect3.cpp -- using STL functions\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nstruct Review\n{\n    std::string title;\n    int rating;\n};\n\nbool operator&lt;(const Review &amp;r1, const Review &amp;r2);\nbool worseThan(const Review &amp;r1, const Review &amp;r2);\nbool FillReview(Review &amp;rr);\nvoid ShowReview(const Review &amp;rr);\n\nint main()\n{\n    using namespace std;\n    vector&lt;Review&gt; books;\n    Review temp;\n    while (FillReview(temp))\n        books.push_back(temp);\n    if (books.size() &gt; 0)\n    {\n        cout &lt;&lt; \"Thank you. You entered the following \"\n             &lt;&lt; books.size() &lt;&lt; \" ratings:\\n\"\n             &lt;&lt; \"Rating\\tBook\\n\";\n        for_each(books.begin(), books.end(), ShowReview);\n        sort(books.begin(), books.end());\n        cout &lt;&lt; \"Sorted by title:\\nRating\\tBook\\n\";\n        for_each(books.begin(), books.end(), ShowReview);\n        sort(books.begin(), books.end(), worseThan);\n        cout &lt;&lt; \"Sorted by rating:\\nRating\\tBook\\n\";\n        for_each(books.begin(), books.end(), ShowReview);\n        random_shuffle(books.begin(), books.end());\n        cout &lt;&lt; \"After shuffling:\\nRating\\tBook\\n\";\n        for_each(books.begin(), books.end(), ShowReview);\n    }\n    else\n        cout &lt;&lt; \"No entries. \";\n    cout &lt;&lt; \"Bye.\\n\";\n    return 0;\n}\n\nbool operator&lt;(const Review &amp;r1, const Review &amp;r2)\n{\n    if (r1.title &lt; r2.title)\n        return true;\n    else if (r1.title == r2.title &amp;&amp; r1.rating &lt; r2.rating)\n        return true;\n    else\n        return false;\n}\n\nbool worseThan(const Review &amp;r1, const Review &amp;r2)\n{\n    if (r1.rating &lt; r2.rating)\n        return true;\n    else\n        return false;\n}\n\nbool FillReview(Review &amp;rr)\n{\n    std::cout &lt;&lt; \"Enter book title (quit to quit): \";\n    std::getline(std::cin, rr.title);\n    if (rr.title == \"quit\")\n        return false;\n    std::cout &lt;&lt; \"Enter book rating: \";\n    std::cin &gt;&gt; rr.rating;\n    if (!std::cin)\n        return false;\n    // get rid of rest of input line\n    while (std::cin.get() != '\\n')\n        continue;\n    return true;\n}\n\nvoid ShowReview(const Review &amp;rr)\n{\n    std::cout &lt;&lt; rr.rating &lt;&lt; \"\\t\" &lt;&lt; rr.title &lt;&lt; std::endl;\n}\n</code></pre>   Declaration   // Answer in the book  The two `sort()` functions and the `random_shuffle()` function require a random access iterator, whereas a list object just has a bidirectional iterator.You can use the list template class `sort()` member functions (see Appendix G,\u201cThe STL Methods and Functions\u201d) instead of the general-purpose functions to do the sorting, but there is no member function equivalent to `random_shuffle()`. However, you could copy the list to a `vector`, shuffle the vector, and copy the results back to the list.    11. Consider the <code>TooBig</code> functor in Listing 16.15. What does the following code do, and what values get assigned to bo?  <pre><code>// Listing 16.15 Too Big\ntemplate &lt;class T&gt; // functor class defines operator()()\nclass TooBig\n{\nprivate:\n    T cutoff;\n\npublic:\n    TooBig(const T &amp;t) : cutoff(t) {}\n    bool operator()(const T &amp;v) { return v &gt; cutoff; }\n};\n</code></pre> <pre><code>bool bo = TooBig&lt;int&gt;(10)(15);\n</code></pre>   used in functions/methods via operator overloading(). Returns bool 10&gt;15;  // Answer in the AI  The given code snippet creates an instance of the `TooBig` functor with the template parameter `int`, and the cutoff value set to `10`. Then it calls the `operator()` function with the argument `15`.  The `TooBig` functor checks if the passed argument (`15`) is greater than the cutoff value (`10`). Since `15` is indeed greater than `10`, the function returns `true`. Therefore, the `boolean` variable `bo` is assigned the value `true`."},{"location":"#chapter-17","title":"Chapter 17","text":"01. What role does the <code>iostream</code> file play in C++ I/O?   It define classes that can create objects to control stream of data from and to selected source (default is keyboard).   // Answer in the book  The `iostream` file defines the classes, constants, and manipulators used to manage input and output.These objects manage the streams and buffers used to handle I/O. The file also creates standard objects (`cin`, `cout`, `cerr`, and `clog` and their widecharacter equivalents) used to handle the standard input and output streams connected to every program.    02. Why does typing a number such as 121 as input require a program to make a conversion?   It is a raw stream of data from keyboard, that to be displayed as human-readable text, need to be converted.  // Answer in the book  Keyboard entry generates a series of characters. Typing `121` generates three characters, each represented by a 1-byte binary code. If the value is to be stored as type int, these three characters have to be converted to a single binary representation of the value `121`.    03. What\u2019s the difference between the standard output and the standard error?   `standard output` describes stream of data from program to selected destination, while `standard error` describes fault in program that is send as stream of data to the standard output.  // Answer in the book  By default, both the standard output and the standard error send output to the standard output device, typically a monitor. If you have the operating system redirect output to a file, however, the standard output connects to the file instead of to the screen, but the standard error continues to be connected to the screen.    04. Why is <code>cout</code> able to display various C++ types without being provided explicit instructions for each type?   Due to large number of overloadings in insertion operators `&lt;&lt;` and extraction operators `&gt;&gt;`.  // Answer in the book  The `ostream` class defines a version of the `operator&lt;&lt;()` function for each basic C++ type.The compiler interprets an expression like  <pre><code>cout &lt;&lt; spot;\n</code></pre>  as the following:  <pre><code>cout.operator&lt;&lt;(spot);\n</code></pre>  It can then match this method call to the function prototype that has the same argument type.    05. What feature of the output method definitions allows you to concatenate output?   ios_base class file mode method `ios_base::app`, that append new data to the end of file. In case of reading the file, than changing the data, `.clear` method will clear `eof` flag and allow to further manipulate data.  // Answer in the book  You can concatenate output methods that return type `ostream &amp;`. This causes the invoking of a method with an object to return that object. The returned object can then invoke the next method in a sequence.    06. Write a program that requests an integer and then displays it in decimal, octal, and hexadecimal forms. Display each form on the same line, in fields that are 15 characters wide, and use the C++ number base prefixes. <pre><code>#include &lt;iostream&gt;\n\nint main(){\n    int data{};\n\n    std::cout &lt;&lt; \"\\nEnter integer number: \";\n    std::cin &gt;&gt; data; \n    while (std::cin.get() != '\\n') continue; \n\n    // Use + before positive numbers. - num base prefix\n    std::cout.setf(std::ios_base::showpos); \n    std::cout &lt;&lt; \"You have entered:\\n\";\n\n    std::cout &lt;&lt; \"In decimal:\\t\";\n    std::cout.width(15);\n    std::cout &lt;&lt; data &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; std::hex;\n    std::cout &lt;&lt; \"In hexadecimal:\\t\";\n    std::cout.width(15);\n    std::cout &lt;&lt; data &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; std::oct;\n    std::cout &lt;&lt; \"In octal:\\t\";\n    std::cout.width(15);\n    std::cout &lt;&lt; data &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"\\nAdios!\";\n\n    return 0;\n}\n</code></pre>  // Answer in the book <pre><code>// rq17-6.cpp\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\nint main()\n{\n    using namespace std;\n    cout &lt;&lt; \"Enter an integer: \";\n    int n;\n    cin &gt;&gt; n;\n    cout &lt;&lt; setw(15) &lt;&lt; \"base ten\" &lt;&lt; setw(15)\n         &lt;&lt; \"base sixteen\" &lt;&lt; setw(15) &lt;&lt; \"base eight\"\n         &lt;&lt; \"\\n\";\n    cout.setf(ios::showbase); // or cout &lt;&lt; showbase;\n    cout &lt;&lt; setw(15) &lt;&lt; n &lt;&lt; hex &lt;&lt; setw(15) &lt;&lt; n\n         &lt;&lt; oct &lt;&lt; setw(15) &lt;&lt; n &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>  07. Write a program that requests the following information and that formats it as shown:  <pre><code>Enter your name: Billy Gruff\nEnter your hourly wages: 12\nEnter number of hours worked: 7.5\nFirst format:\nBilly Gruff: $ 12.00: 7.5\nSecond format:\nBilly Gruff : $12.00 :7.5\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main(){\n\n    std::string name;\n    float wage_hour{};\n    float work_hours{};\n\n    std::cout &lt;&lt; \"\\nEnter your name: \";\n    std::getline(std::cin, name);\n    std::cout &lt;&lt; \"Enter your hourly wage_hours: \";\n    std::cin &gt;&gt; wage_hour; \n    while (std::cin.get() != '\\n') continue; \n    std::cout &lt;&lt; \"Enter number of hours worked: \";\n    std::cin &gt;&gt; work_hours; \n    while (std::cin.get() != '\\n') continue; \n\n    std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);\n    std::cout &lt;&lt; \"First format:\\n\";\n    std::cout.precision(2);\n    std::cout &lt;&lt; name &lt;&lt; \": $ \" &lt;&lt; wage_hour;\n    std::cout.precision(1);\n    std::cout &lt;&lt; \": \" &lt;&lt; work_hours &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"Second format:\\n\";\n    std::cout.precision(2);\n    std::cout &lt;&lt; name &lt;&lt; \" : $\" &lt;&lt; wage_hour;\n    std::cout.precision(1);\n    std::cout &lt;&lt; \" :\" &lt;&lt; work_hours &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"\\nAdios!\";\n\n    return 0;\n}\n</code></pre>  // Answer in the book <pre><code>// rq17-7.cpp\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\nint main()\n{\n    using namespace std;\n    char name[20];\n    float hourly;\n    float hours;\n\n    cout &lt;&lt; \"Enter your name: \";\n    cin.get(name, 20).get();\n    cout &lt;&lt; \"Enter your hourly wages: \";\n    cin &gt;&gt; hourly;\n    cout &lt;&lt; \"Enter number of hours worked: \";\n    cin &gt;&gt; hours;\n\n    cout.setf(ios::showpoint);\n    cout.setf(ios::fixed, ios::floatfield);\n    cout.setf(ios::right, ios::adjustfield);\n\n    // or cout &lt;&lt; showpoint &lt;&lt; fixed &lt;&lt; right;\n    cout &lt;&lt; \"First format:\\n\";\n    cout &lt;&lt; setw(30) &lt;&lt; name &lt;&lt; \": $\" &lt;&lt; setprecision(2)\n         &lt;&lt; setw(10) &lt;&lt; hourly &lt;&lt; \":\" &lt;&lt; setprecision(1)\n         &lt;&lt; setw(5) &lt;&lt; hours &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"Second format:\\n\";\n    cout.setf(ios::left, ios::adjustfield);\n    cout &lt;&lt; setw(30) &lt;&lt; name &lt;&lt; \": $\" &lt;&lt; setprecision(2)\n         &lt;&lt; setw(10) &lt;&lt; hourly &lt;&lt; \":\" &lt;&lt; setprecision(1)\n         &lt;&lt; setw(5) &lt;&lt; hours &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>  08. Consider the following program:  <pre><code>// rq17-8.cpp\n#include &lt;iostream&gt;\nint main()\n{\n    using namespace std;\n    char ch;\n    int ct1 = 0;\n    cin &gt;&gt; ch;\n    while (ch != 'q')\n    {\n        ct1++;\n        cin &gt;&gt; ch;\n    }\n    int ct2 = 0;\n    cin.get(ch);\n    while (ch != 'q')\n    {\n        ct2++;\n        cin.get(ch);\n    }\n    cout &lt;&lt; \"ct1 = \" &lt;&lt; ct1 &lt;&lt; \"; ct2 = \" &lt;&lt; ct2 &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>  What does it print, given the following input:  <pre><code>I see a q&lt;Enter&gt;\nI see a q&lt;Enter&gt;\n</code></pre>  Here <code> signifies pressing the Enter key.    It will print: `ct1 = 5; ct2 = 8`  // Answer in the book  Here is the output: `ct1 = 5; ct2 = 9` The first part of the program ignores spaces and newline characters; the second part doesn\u2019t. Note that the second part of the program begins reading at the newline character following the first q, and it counts that newline character as part of its total.    09. Both of the following statements read and discard characters up to and including the end of a line. In what way does the behavior of one differ from that of the other?  <pre><code>while (cin.get() != '\\n')\n    continue;\ncin.ignore(80, '\\n');\n</code></pre>   `cin.ignore` discard `80` characters up to `\\n` or eof condition; this `while` loop will discard characters until `\\n` occur;   // Answer in the book  The `ignore()` form falters if the input line exceeds 80 characters. In that case, it skips only the first 80 characters."},{"location":"#chapter-18","title":"Chapter 18","text":"01. Rewrite the following code using braced initialization list syntax; the rewrite should dispense with using the array ar:  <pre><code>class Z200\n{\nprivate:\n    int j;\n    char ch;\n    double z;\n\npublic:\n    Z200(int jv, char chv, zv) : j(jv), ch(chv), z(zv){}...\n};\n\ndouble x = 8.8;\nstd::string s = \"What a bracing effect!\";\nint k(99);\nZ200 zip(200, 'Z', 0.675);\nstd::vector&lt;int&gt; ai(5);\nint ar[5] = {3, 9, 4, 7, 1};\nfor (auto pt = ai.begin(), int i = 0; pt != ai.end(); ++pt, ++i)\n    *pt = ai[i];\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass Z200\n{\nprivate:\n     int j;\n     char ch;\n     double z;\n\npublic:\n     Z200(int jv, char chv, double zv) : j(jv), ch(chv), z(zv){};\n};\n\nint main()\n{\n     double x{8.8};\n     std::string s {\"What a bracing effect!\"};\n     int k{99};\n     Z200 zip{200, 'Z', 0.675};\n     std::vector&lt;int&gt; ai{5};\n     int ar[5] {3, 9, 4, 7, 1};\n     for (auto pt {ai.begin()}, int i{0}; pt != ai.end(); ++pt, ++i)\n          *pt = ai[i];\n}\n</code></pre>  // Answer in the book <pre><code>class Z200\n{\nprivate:\n     int j;\n     char ch;\n     double z;\n\npublic:\n     Z200(int jv, char chv, zv) : j(jv), ch(chv), z(zv){}...\n};\n\ndouble x{8.8}; // or = {8.8}\nstd::string s{\"What a bracing effect!\"};\nint k{99};\nZ200 zip{200,'Z',0.67};\nstd::vector&lt;int&gt; ai{3, 9, 4, 7, 1};\n</code></pre>  02. For the following short program, which function calls are errors and why? For the valid calls, what does the reference argument refer to?  <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ndouble up(double x) { return 2.0 * x; }\nvoid r1(const double &amp;rx) { cout &lt;&lt; rx &lt;&lt; endl; }\nvoid r2(double &amp;rx) { cout &lt;&lt; rx &lt;&lt; endl; }\nvoid r3(double &amp;&amp;rx) { cout &lt;&lt; rx &lt;&lt; endl; }\n\nint main()\n{\n    double w = 10.0;\n    r1(w);\n    r1(w + 1);\n    r1(up(w));\n    r2(w);\n    r2(w + 1);\n    r2(up(w));\n    r3(w);\n    r3(w + 1);\n    r3(up(w));\n    return 0;\n}\n</code></pre> <pre><code>    r2(w + 1);  // reference need argument to bo to lvalue\n    r2(up(w));  // -||-\n    r3(w);      // for &amp;&amp;, argument need to be rvalue\n</code></pre>  // Answer in the book <pre><code>r1(w) is valid, and the argument rx refers to w.\nr1(w+1) is valid, and the argument rx refers to a temporary initialized to the value\nof w+1.\nr1(up(w)) is valid, and the argument rx refers to a temporary initialized to the\nreturn value of up(w).\n\nIn general, if an lvalue is passed to a const lvalue reference parameter, the parameter\nis initialized to the lvalue. If an rvalue is passed to the function, a const lvalue\nreference parameter refers to a temporary copy of the value.\n\nr2(w) is valid, and the argument rx refers to w.\nr2(w+1) is an error because w+1 is an rvalue.\nr2(up(w)) is an error because the return value of up(w) is an rvalue.\n\nIn general, if an lvalue is passed to a non-const lvalue reference parameter, the\nparameter is initialized to the lvalue. But a non-const lvalue reference parameter\ncan\u2019t accept an rvalue function argument.\n\nr3(w) is an error because an rvalue reference cannot refer to an lvalue, such as w.\nr3(w+1) is valid, and rx refers to the temporary value of the expression w+1.\nr3(up(w)) is valid, and rx refers to the temporary return value of up(w)\n</code></pre>  03.  a. What does the following short program display and why?  <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ndouble up(double x) { return 2.0 * x; }\nvoid r1(const double &amp;rx) { cout &lt;&lt; \u201cconst double &amp; rx\\n\u201d; }\nvoid r1(double &amp;rx) { cout &lt;&lt; \u201cdouble &amp; rx\\n\u201d; }\n\nint main()\n{\n    double w = 10.0;\n    r1(w);\n    r1(w + 1);\n    r1(up(w));\n    return 0;\n}\n</code></pre>  b. What does the following short program display and why?  <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ndouble up(double x) { return 2.0 * x; }\nvoid r1(double &amp;rx) { cout &lt;&lt; \"double &amp; rx\\n\"; }\nvoid r1(double &amp;&amp;rx) { cout &lt;&lt; \"double &amp;&amp; rx\\n\"; }\n\nint main()\n{\n    double w = 10.0;\n    r1(w);\n    r1(w + 1);\n    r1(up(w));\n    return 0;\n}\n</code></pre>  c. What does the following short program display and why?  <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ndouble up(double x) { return 2.0 * x; }\nvoid r1(const double &amp;rx) { cout &lt;&lt; \"const double &amp; rx\\n\"; }\nvoid r1(double &amp;&amp;rx) { cout &lt;&lt; \"double &amp;&amp; rx\\n\"; }\n\nint main()\n{\n    double w = 10.0;\n    r1(w);\n    r1(w + 1);\n    r1(up(w));\n    return 0;\n}\n</code></pre>   a)  <pre><code>double &amp; rx\ndouble &amp; rx\nconst double &amp; rx\n</code></pre>  b)  <pre><code>double &amp; rx\ndouble &amp;&amp; rx\ndouble &amp;&amp; rx\n</code></pre>  c)  <pre><code>const double &amp; rx\ndouble &amp;&amp; rx\ndouble &amp;&amp; rx\n</code></pre>  // Answer in the book <pre><code>a. \ndouble &amp; rx\nconst double &amp; rx\nconst double &amp; rx\n\nThe non-const lvalue reference matches the lvalue argument w. The other two\narguments are rvalues, and the const lvalue reference can refer to copies of them.\n\nb. \ndouble &amp; rx\ndouble &amp;&amp; rx\ndouble &amp;&amp; rx\n\nThe lvalue reference matches the lvalue argument w, and the rvalue references\nmatches the two rvalue arguments.\n\nc. \nconst double &amp; rx\ndouble &amp;&amp; rx\ndouble &amp;&amp; rx\n\nThe const lvalue reference matches the lvalue argument w, and the rvalue reference\nmatches the two rvalues.\nIn short, a non-const lvalue parameter matches an lvalue argument, a non-const\nrvalue parameter matches an rvalue argument, and a const lvalue parameter can\nmatch either an lvalue or an rvalue argument, but the compiler will prefer the first\ntwo choices, if available.\n</code></pre>  04. Which member functions are special member functions, and what makes them special?   // Answer in the book  They are the default constructor, the copy constructor, the move constructor, the destructor, the copy assignment operator, and the move assignment operator. They are special because the compiler can automatically provide defaulted versions of these functions, depending on the context.    05. Suppose the Fizzle class has only the data members shown:  <pre><code>class Fizzle\n{\nprivate:\n    double bubbles[4000];\n    ...\n};\n</code></pre>  Why would this class not be a good candidate for a user-defined move constructor? What change in approach to storing the 4000 double values would make the class a good candidate for a move function?    Make bubbles a dynamic pointer for move semantics  // Answer in the book  A move constructor can be used when it makes sense to transfer ownership of data instead of copying it, but there is no mechanism for transferring ownership of a standard array. If the `Fizzle` class used a pointer and dynamic memory allocation, then one can transfer ownership by reassigning the address of the data to a new pointer.    06. Revise the following short program so that it uses a lambda expression instead of <code>f1()</code>. Don\u2019t change <code>show2()</code>.  <pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\n    void show2(double x, T &amp;fp) { std::cout &lt;&lt; x &lt;&lt; \" -&gt; \" &lt;&lt; fp(x) &lt;&lt; '\\n'; }\ndouble f1(double x) { return 1.8 * x + 32; }\n\nint main()\n{\n    show2(18.0, f1);\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\n    void show2(double x, T &amp;fp) { std::cout &lt;&lt; x &lt;&lt; \" -&gt; \" &lt;&lt; fp(x) &lt;&lt; '\\n'; }\n\nint main()\n{\n    show2(18.0, [] (double x)-&gt;double{return 1.8 * x + 32;} );\n    return 0;\n}\n\n// Answer in the book&lt;/br&gt;\n\n```cpp\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\ntemplate&lt;typename T&gt;\n    void show2(double x, T fp) {std::cout &lt;&lt; x &lt;&lt; \" -&gt; \" &lt;&lt; fp(x) &lt;&lt; '\\n';}\nint main()\n{\n    show2(18.0, [](double x){return 1.8*x + 32;});\n    return 0;\n}\n</code></pre>  07. Revise the following short and ugly program so that it uses a lambda expression instead of the <code>Adder</code> functor. Don\u2019t change <code>sum()</code>.  <pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nconst int Size = 5;\ntemplate &lt;typename T&gt;\nvoid sum(std::array&lt;double, Size&gt; a, T &amp;fp);\n\nclass Adder\n{\n    double tot;\n\npublic:\n    Adder(double q = 0) : tot(q) {}\n    void operator()(double w) { tot += w; }\n    double tot_v() const { return tot; };\n};\nint main()\n{\n    double total = 0.0;\n    Adder ad(total);\n    std::array&lt;double, Size&gt; temp_c = {32.1, 34.3, 37.8, 35.2, 34.7};\n    sum(temp_c, ad);\n    total = ad.tot_v();\n    std::cout &lt;&lt; \"total: \" &lt;&lt; ad.tot_v() &lt;&lt; '\\n';\n    return 0;\n}\ntemplate &lt;typename T&gt;\nvoid sum(std::array&lt;double, Size&gt; a, T &amp;fp)\n{\n    for (auto pt = a.begin(); pt != a.end(); ++pt)\n    {\n        fp(*pt);\n    }\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nconst int Size = 5;\ntemplate &lt;typename T&gt;\nvoid sum(std::array&lt;double, Size&gt; a, T &amp;fp);\n\nint main()\n{\n    double total = 0.0;\n    std::array&lt;double, Size&gt; temp_c = {32.1, 34.3, 37.8, 35.2, 34.7};\n    sum(temp_c, [&amp;](double w){total += w});\n    std::cout &lt;&lt; \"total: \" &lt;&lt; total &lt;&lt; '\\n';\n    return 0;\n}\n\ntemplate &lt;typename T&gt;\nvoid sum(std::array&lt;double, Size&gt; a, T &amp;fp)\n{\n    for (auto pt = a.begin(); pt != a.end(); ++pt)\n    {\n        fp(*pt);\n    }\n}\n</code></pre>  // Answer in the book <pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n#include &lt;algorithm&gt;\n\nconst int Size = 5;\ntemplate &lt;typename T&gt;\nvoid sum(std::array&lt;double, Size&gt; a, T &amp;fp);\n\nint main()\n{\n     double total = 0.0;\n     std::array&lt;double, Size&gt; temp_c = {32.1, 34.3, 37.8, 35.2, 34.7};\n     sum(temp_c, [&amp;total](double w)\n         { total += w; });\n     std::cout &lt;&lt; \"total: \" &lt;&lt; total &lt;&lt; '\\n';\n     std::cin.get();\n     return 0;\n}\n\ntemplate &lt;typename T&gt;\nvoid sum(std::array&lt;double, Size&gt; a, T &amp;fp)\n{\n     for (auto pt = a.begin(); pt != a.end(); ++pt)\n     {\n          fp(*pt);\n     }\n}\n</code></pre>"},{"location":"exercises/","title":"Exercises","text":"<p>Collapse All/Expand All Code</p>"},{"location":"exercises/#chapter-2","title":"Chapter 2","text":"<p>1 - Write a C++ program that displays your name and address (or if you value your privacy,a fictitious name and address).</p> Code <pre><code>#include &lt;iostream&gt;                          // a PREPROCESSOR directive\n\nint main()                                   // function header\n{                                            // start of function body\n    using namespace std;                     // make definitions visible\n    cout &lt;&lt; \"Name: Deimos\\n\";\n    cout &lt;&lt; \"Country: Poland\\n\";\n    cout &lt;&lt; \"City: Warsaw\";\n    cout &lt;&lt; endl;                            // start a new line\n    return 0;                                // terminate main()\n} // end of function body\n</code></pre> <p>2 - Write a C++ program that asks for a distance in furlongs and converts it to yards. (One furlong is 220 yards.)</p> Code <pre><code>#include &lt;iostream&gt;                          // a PREPROCESSOR directive\n\nint main()                                   // function header\n{                                            // start of function body\n    using namespace std;                     // make definitions visible\n\n    float iFurlongs = 0;                     // declare variables\n    float iYards = 0;\n\n    cout &lt;&lt; \"Program converting distance from furlong to yards\\n\";\n    cout &lt;&lt; \"1 furlong = 220 yards\\n\\n\";\n    cout &lt;&lt; \"Enter the distance in furlongs: \";\n\n    cin &gt;&gt; iFurlongs;                        // read input\n\n    cout &lt;&lt; iFurlongs &lt;&lt; \" furlongs = \" &lt;&lt; iFurlongs * 220 &lt;&lt; \" yards\";\n\n    cout &lt;&lt; endl;                            // start a new line\n    return 0;                                // terminate main()\n} // end of function body\n</code></pre> <p>3 - Write a C++ program that uses three user-defined functions (counting <code>main()</code> as one) and produces the following output:</p> <pre><code>Three blind mice\nThree blind mice\nSee how they run\nSee how they run\n</code></pre> <p>One function,called two times,should produce the first two lines, and the remain- ing function, also called twice, should produce the remaining output.</p> Code <pre><code>#include &lt;iostream&gt;                          // a PREPROCESSOR directive\n\nusing namespace std;\n\nvoid fun1()\n{\n    cout &lt;&lt; \"Three blind mice\\n\";\n}\n\nvoid fun2()\n{\n    cout &lt;&lt; \"See how they run\\n\";\n}\n\nint main()                                   // function header\n{                                            // start of function body\n    fun1();                                  // function call\n    fun1();                                  // function call\n    fun2();                                  // function call\n    fun2();                                  // function call\n\n    return 0;                                // terminate main()\n} \n</code></pre> <p>4 - Write a program that asks the user to enter his or her age. The program then should display the age in months:</p> <pre><code>Enter your age: 29\nYour age in months is 384.\n</code></pre> Code <pre><code>#include &lt;iostream&gt;                          // a PREPROCESSOR directive\n\nint main()                                   // function header\n{                                            // start of function body\n    using namespace std;\n\n    int iAge = 0;\n\n    cout &lt;&lt; \"\\nEnter your age: \";\n    cin &gt;&gt; iAge;\n    cout &lt;&lt; \"Your age in months is \" &lt;&lt; iAge * 12 &lt;&lt; \"\\n\";\n\n    return 0;                                // terminate main()\n} \n</code></pre> <p>5 - Write a program that has <code>main()</code> call a user-defined function that takes a Celsius temperature value as an argument and then returns the equivalent Fahrenheit value.The program should request the Celsius value as input from the user and displaythe result, as shown in the following code:</p> <pre><code>Please enter a Celsius value: 20\n20 degrees Celsius is 68 degrees Fahrenheit.\n</code></pre> <p>For reference,here is the formula for making the conversion: <code>Fahrenheit = 1.8 \u00d7 degrees Celsius + 32.0</code></p> Code <pre><code>#include &lt;iostream&gt;                          // a PREPROCESSOR directive\n\nfloat fnCelsiusToFahrenheit(float fCelsius)\n{\n    return (1.8 * fCelsius + 32);\n}\n\nint main()                                   // function header\n{                      \n    using namespace std;\n\n    float fCelsius = 0;\n\n    cout &lt;&lt; \"\\nPlease enter a Celsius value: \";\n    cin &gt;&gt; fCelsius;\n    cout &lt;&lt; fCelsius &lt;&lt; \" degrees Celsius is \" &lt;&lt; fnCelsiusToFahrenheit(fCelsius) &lt;&lt; \" degrees Farhenheit\\n\";\n\n    return 0;                                // terminate main()\n} \n</code></pre> <p>6 -</p> <p>Write a program that has <code>main()</code> call a user-defined function that takes a distance in light years as an argument and then returns the distance in astronomical units.The program should request the light year value as input from the user and display the result,as shown in the following code:</p> <pre><code>Enter the number of light years: 4.2\n4.2 light years = 265608 astronomical units.\n</code></pre> <p>An astronomical unit is the average distance from the earth to the sun (about 150,000,000 km or 93,000,000 miles), and a light year is the distance light travels in a year (about 10 trillion kilometers or 6 trillion miles). (The nearest star after thesun is about 4.2 light years away.) Use type double (as in Listing 2.4 (page 51)) and this conversion factor:</p> <pre><code>1 light year = 63,240 astronomical units\n</code></pre> Code <pre><code>#include &lt;iostream&gt;                          // a PREPROCESSOR directive\n\nint main()                                   // function header\n{                      \n    using namespace std;\n\n    double dLightYears = 0;\n\n    cout &lt;&lt; \"\\nEnter the number of light years: \";\n    cin &gt;&gt; dLightYears;\n    cout &lt;&lt; dLightYears &lt;&lt; \" light years = \" &lt;&lt; (dLightYears * 63240) &lt;&lt; \" astronomical units\\n\";\n\n    return 0;                                // terminate main()\n} \n</code></pre> <p>7 - Write a program that asks the user to enter an hour value and a minute value. The <code>main()</code> function should then pass these two values to a type <code>void</code> function that displays the two values in the format shown in the following sample run:</p> <pre><code>Enter the number of hours: 9\nEnter the number of minutes: 28\nTime: 9:28\n</code></pre> Code <pre><code>#include &lt;iostream&gt;                          // a PREPROCESSOR directive\n\nint main()                                   // function header\n{                      \n    using namespace std;\n\n    int iHours = 0;\n    int iMinutes = 0;\n\n    cout &lt;&lt; \"\\nEnter the number of hours: \";\n    cin &gt;&gt; iHours;\n    cout &lt;&lt; \"Enter the number of minutes: \";\n    cin &gt;&gt; iMinutes;\n\n    cout &lt;&lt; \"Time: \" &lt;&lt; iHours &lt;&lt; \":\" &lt;&lt; iMinutes &lt;&lt; endl;\n\n    return 0;                                // terminate main()\n} \n</code></pre>"},{"location":"exercises/#chapter-3","title":"Chapter 3","text":"<p>1 - Write a short program that asks for your height in integer inches and then converts your height to feet and inches. Have the program use the underscore character to indicate where to type the response. Also use a const symbolic constant to represent the conversion factor.</p> Code <pre><code>#include &lt;iostream&gt;\n\nconst unsigned int _CONV_FACTOR {12};\n\nint main() \n{\n    using namespace std;\n\n    unsigned int uiHeightInput {0};\n    unsigned int uiHeightFeet {0};\n    unsigned int uiHeightInches {0};\n\n    cout &lt;&lt; \"Enter your height in inches:__\\b\\b\";\n    cin &gt;&gt; uiHeightInput;\n\n    uiHeightFeet = uiHeightInput / _CONV_FACTOR;\n    uiHeightInches = uiHeightInput % _CONV_FACTOR;\n\n    cout &lt;&lt; \"Your height is: \" &lt;&lt; uiHeightFeet &lt;&lt; \" feet and \" &lt;&lt; uiHeightInches &lt;&lt; \" inches.\" &lt;&lt; endl;\n}\n</code></pre> <p>2 -</p> <p>Write a short program that asks for your height in feet and inches and your weight in pounds. (Use three variables to store the information.) Have the program report your body mass index (BMI).To calculate the BMI, first convert your height in feet and inches to your height in inches (1 foot = 12 inches). Then convert your height in inches to your height in meters by multiplying by 0.0254.Then convert your weight in pounds into your mass in kilograms by dividing by 2.2. Finally, compute your BMI by dividing your mass in kilograms by the square of your height in meters. Use symbolic constants to represent the various conversion factors.</p> Code <pre><code>#include &lt;iostream&gt;\n\nconst int _RATIO_FEET_TO_INCH {12};\nconst float _RATIO_INCH_TO_METER {0.0254};\nconst float _CONV_POUNDS_TO_KG {2.2};\n\ndouble fnBMI(double dHeight, double dWeight);   // function prototype\n\nint main() \n{\n    using namespace std;\n\n    unsigned int uiHeightFeet {};\n    double ulHeightInches {};\n    double ulWeight {};\n\n    cout &lt;&lt; \"Enter your height in feet and (the rest) in inches. Round to whole units.\\n\";\n\n    cout &lt;&lt; \"Enter your height in feet:__\\b\\b\";\n    cin &gt;&gt; uiHeightFeet;\n    cout &lt;&lt; \"Enter your height in inches:__\\b\\b\";\n    cin &gt;&gt; ulHeightInches;\n    cout &lt;&lt; \"Enter your  weight in pounds:__\\b\\b\";\n    cin &gt;&gt; ulWeight;\n\n    ulHeightInches = (uiHeightFeet * _RATIO_FEET_TO_INCH) + ulHeightInches;   // height in inches\n    cout &lt;&lt; \"\\nYour height in inches is \" &lt;&lt; ulHeightInches &lt;&lt; endl;\n\n    cout &lt;&lt; \"Your BMI is \" &lt;&lt; fnBMI(ulHeightInches, ulWeight) &lt;&lt; endl;\n}\n\n/// @brief BMI calculator\n/// @param dHeight in inches\n/// @param dWeight in pounds\n/// @return BMI value in double\ndouble fnBMI(double dHeight, double dWeight)\n{\n    dHeight = dHeight * _RATIO_INCH_TO_METER;                   // height in meters\n    std::cout &lt;&lt; \"Your height in meters is \" &lt;&lt; dHeight &lt;&lt; std::endl;\n\n    dWeight = dWeight / _CONV_POUNDS_TO_KG;                    // weight in kilograms \n    std::cout &lt;&lt; \"Your weight in kilograms is \" &lt;&lt; dWeight &lt;&lt; std::endl &lt;&lt; std::endl;\n\n    return dWeight / (dHeight * dHeight);\n}\n</code></pre> <p>3 - Write a program that asks the user to enter a latitude in degrees, minutes, and seconds and that then displays the latitude in decimal format.There are 60 seconds of arc to a minute and 60 minutes of arc to a degree; represent these values with symbolic constants.You should use a separate variable for each input value. A sample run should look like this:</p> <pre><code>Enter a latitude in degrees, minutes, and seconds:\nFirst, enter the degrees: 37\nNext, enter the minutes of arc: 51\nFinally, enter the seconds of arc: 19\n37 degrees, 51 minutes, 19 seconds = 37.8553 degrees\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n\nconst int _CONV_ARCSECONDS_TO_ARCMINUTES {60};\nconst int _CONV_ARCMINUTES_TO_DEGREES {60};\n\ndouble fnDecimalLattitude(int iDegrees, int iArcMinutes, int iArcSeconds);\n\nint main() \n{\n    using namespace std;\n\n    int iDegrees {};\n    int iArcMinutes {};\n    int iArcSeconds {};\n\n    cout &lt;&lt; \"Enter a latitude in degrees, minutes, and seconds:\\n\";\n\n    cout &lt;&lt; \"First, enter the degrees: \";\n    cin &gt;&gt; iDegrees;\n    cout &lt;&lt; \"Next, enter the minutes of arc: \";\n    cin &gt;&gt; iArcMinutes;\n    cout &lt;&lt; \"Finally, enter the seconds of arc: \";\n    cin &gt;&gt; iArcSeconds;\n\n    cout &lt;&lt; iDegrees &lt;&lt; \" degrees, \" &lt;&lt; iArcMinutes &lt;&lt; \" minutes, \" &lt;&lt; iArcSeconds &lt;&lt; \" seconds = \";\n    cout &lt;&lt; fnDecimalLattitude(iDegrees, iArcMinutes, iArcSeconds) &lt;&lt; \" degrees\\n\";\n}\n\n/// @brief Returns the latitude with decimal format\ndouble fnDecimalLattitude(int iDegrees, int iArcMinutes, int iArcSeconds)\n{\n    double dDegrees = double(iArcSeconds) / _CONV_ARCSECONDS_TO_ARCMINUTES;\n    dDegrees = (iArcMinutes + dDegrees) / _CONV_ARCMINUTES_TO_DEGREES;\n    return iDegrees + dDegrees;\n}\n</code></pre> <p>4 - Write a program that asks the user to enter the number of seconds as an integer value (use type long, or, if available, long long) and that then displays the equivalent time in days, hours, minutes, and seconds. Use symbolic constants to represent the number of hours in the day, the number of minutes in an hour, and the number of seconds in a minute.The output should look like this:</p> <pre><code>Enter the number of seconds: 31600000 \n31600000 seconds = 365 days, 17 hours, 46 minutes, 40 seconds\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n\nconst int _CONV_SECONDS_TO_MINUTES {60};\nconst int _CONV_MINUTES_TO_HOURS {60};\nconst int _CONV_HOURS_TO_DAYS {24};\n\nint main() \n{\n    using namespace std;\n\n    unsigned long long llInputSeconds {}, llSeconds {};\n    unsigned long iMinutes {}, iHours {}, iDays {};\n\n    cout &lt;&lt; \"Enter the number of seconds: \";\n    cin &gt;&gt; llInputSeconds;\n\n    iMinutes = llInputSeconds / _CONV_SECONDS_TO_MINUTES;\n    llSeconds = llInputSeconds % iMinutes;\n\n    iHours = iMinutes / _CONV_MINUTES_TO_HOURS;\n    iMinutes = iMinutes % iHours;\n\n    iDays = iHours / _CONV_HOURS_TO_DAYS;\n    iHours = iHours % iDays;\n\n    cout &lt;&lt; llInputSeconds &lt;&lt; \" seconds = \" &lt;&lt; iDays &lt;&lt; \" days, \" &lt;&lt; iHours &lt;&lt; \" hours, \" &lt;&lt; iMinutes &lt;&lt; \" minutes, \" &lt;&lt; llSeconds &lt;&lt; \" seconds\\n\";\n}\n</code></pre> <p>5 - Write a program that requests the user to enter the current world population and the current population of the U.S. (or of some other nation of your choice). Store the information in variables of type long long. Have the program display the percent that the U.S. (or other nation\u2019s) population is of the world\u2019s population.The output should look something like this:</p> <pre><code>Enter the world's population: 6898758899\nEnter the population of the US: 310783781\nThe population of the US is 4.50492% of the world population.\n</code></pre> <p>You can use the Internet to get more recent figures.</p> Code <pre><code>#include &lt;iostream&gt;\n\nint main() \n{\n    using namespace std;\n\n    unsigned long long llWorldPopulation {};\n    unsigned long long llCountryPopulation {};\n\n    cout &lt;&lt; \"Enter the world's population: \";\n    cin &gt;&gt; llWorldPopulation;\n\n    cout &lt;&lt; \"Enter the population of the US: \";\n    cin &gt;&gt; llCountryPopulation;\n\n    cout &lt;&lt; \"The population of the US is \";\n    cout &lt;&lt; (double)llCountryPopulation / llWorldPopulation * 100;\n    cout &lt;&lt; \"% of the world population.\";\n}\n</code></pre> <p>6 - Write a program that asks how many miles you have driven and how many gallons of gasoline you have used and then reports the miles per gallon your car has gotten. Or, if you prefer, the program can request distance in kilometers and petrol in liters and then report the result European style, in liters per 100 kilometers.</p> Code <pre><code>#include &lt;iostream&gt;\n\nint main() \n{\n    using namespace std;\n\n    unsigned long long llMilesDriven {};\n    unsigned long long llUsedGasoline {};\n\n    cout &lt;&lt; \"Enter how many miles you have driven: \";\n    cin &gt;&gt; llMilesDriven;\n\n    cout &lt;&lt; \"Enter how many gallons of gasoline you have used: \";\n    cin &gt;&gt; llUsedGasoline;\n\n    cout &lt;&lt; (double)llMilesDriven / llUsedGasoline;\n    cout &lt;&lt; \" miles per gallon your car have gotten\";\n}\n</code></pre> <p>7 - Write a program that asks you to enter an automobile gasoline consumption figure in the European style (liters per 100 kilometers) and converts to the U.S. style of miles per gallon. Note that in addition to using different units of measurement, the U.S. approach (distance / fuel) is the inverse of the European approach (fuel / distance). Note that 100 kilometers is 62.14 miles, and 1 gallon is 3.875 liters. Thus, 19 mpg is about 12.4 l/100 km, and 27 mpg is about 8.7 l/100 km.</p> Code <pre><code>#include &lt;iostream&gt;\n\nconst double _RATIO_KM_TO_M {0.6214};\nconst double _RATIO_GAL_TO_L {3.785412};\n\nint main() \n{\n    using namespace std;\n\n    float fGasolineConsumptionEU {};\n\n    cout &lt;&lt; \"Enter automobile gasoline consumption figure (liters per 100 kilometers): \";\n    cin &gt;&gt; fGasolineConsumptionEU;\n\n    cout &lt;&lt; fGasolineConsumptionEU &lt;&lt; \" liters per 100 kilometers = \";\n    cout &lt;&lt; fGasolineConsumptionEU / _RATIO_GAL_TO_L &lt;&lt; \" galons per \";\n    cout &lt;&lt; _RATIO_KM_TO_M * 100 &lt;&lt; \" miles\\n\";\n\n    cout &lt;&lt; \"MPG = \" &lt;&lt; (_RATIO_KM_TO_M * 100) / (fGasolineConsumptionEU / _RATIO_GAL_TO_L) &lt;&lt; endl;\n}\n</code></pre>"},{"location":"exercises/#chapter-4","title":"Chapter 4","text":"<p>1 - Write a C++ program that requests and displays information as shown in the following.</p> <p>Example of output:</p> <pre><code>What is your first name? Betty Sue\nWhat is your last name? Yewe\nWhat letter grade do you deserve? B\nWhat is your age? 22\nName: Yewe, Betty Sue\nGrade: C\nAge: 22\n</code></pre> <p>Note that the program should be able to accept first names that comprise more than one word. Also note that the program adjusts the grade downward\u2014that is, up one letter. Assume that the user requests an A, a B, or a C so that you don\u2019t have to worry about the gap between a D and an F.</p> Code <pre><code>#include &lt;iostream&gt;\n\nconst double _RATIO_KM_TO_M {0.6214};\nconst double _RATIO_GAL_TO_L {3.785412};\n\nint main() \n{\n    using namespace std;\n\n    float fGasolineConsumptionEU {};\n\n    cout &lt;&lt; \"Enter automobile gasoline consumption figure (liters per 100 kilometers): \";\n    cin &gt;&gt; fGasolineConsumptionEU;\n\n    cout &lt;&lt; fGasolineConsumptionEU &lt;&lt; \" liters per 100 kilometers = \";\n    cout &lt;&lt; fGasolineConsumptionEU / _RATIO_GAL_TO_L &lt;&lt; \" galons per \";\n    cout &lt;&lt; _RATIO_KM_TO_M * 100 &lt;&lt; \" miles\\n\";\n\n    cout &lt;&lt; \"MPG = \" &lt;&lt; (_RATIO_KM_TO_M * 100) / (fGasolineConsumptionEU / _RATIO_GAL_TO_L) &lt;&lt; endl;\n}\n</code></pre> <p>2 - Rewrite Listing 4.4, using the C++ string class instead of char arrays.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct stStudent {\n    std::string firstName;\n    std::string lastName;\n    char Grade;\n    unsigned int age;\n};\n\nint main() \n{\n    using namespace std;\n    stStudent *pStudent = new stStudent;\n\n    cout &lt;&lt; \"What is your first name? \"; \n    getline(cin, pStudent-&gt;firstName);\n\n    cout &lt;&lt; \"What is your last name? \";\n    getline(cin, pStudent-&gt;lastName);\n\n    cout &lt;&lt; \"What letter grade do you deserve? \";\n    cin &gt;&gt; pStudent-&gt;Grade;\n\n    cout &lt;&lt; \"What is your age? \";\n    cin &gt;&gt; pStudent-&gt;age;\n\n    cout &lt;&lt; \"Name: \" &lt;&lt; pStudent-&gt;lastName &lt;&lt; \", \" &lt;&lt; pStudent-&gt;firstName &lt;&lt; endl;\n    cout &lt;&lt; \"Grade: \" &lt;&lt; (char) ++(pStudent-&gt;Grade) &lt;&lt; endl;     \n    cout &lt;&lt; \"Age: \" &lt;&lt; pStudent-&gt;age &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>3 - Write a program that asks the user to enter his or her first name and then last name, and that then constructs, stores, and displays a third string, consisting of the user\u2019s last name followed by a comma, a space, and first name. Use char arrays and functions from the cstring header file.A sample run could look like this:</p> <pre><code>Enter your first name: Flip\nEnter your last name: Fleming\nHere\u2019s the information in a single string: Fleming, Flip\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nint main() \n{\n    using namespace std;\n    char szFirstName[50];\n    char szLastName[50];\n    char szConNames[100];\n\n    cout &lt;&lt; \"Enter your first name: \"; \n    cin.getline(szFirstName, 50);\n\n    cout &lt;&lt; \"Enter your last name: \";\n    cin.getline(szLastName, 50);\n\n    cout &lt;&lt; \"Here is the information in a single string: \";\n    strcpy(szConNames, szLastName);\n    strcat(szConNames, \", \");\n    strcat(szConNames, szFirstName);\n    cout &lt;&lt; szConNames &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>4 - Write a program that asks the user to enter his or her first name and then last name, and that then constructs, stores, and displays a third string consisting of the user\u2019s last name followed by a comma, a space, and first name. Use string objects and methods from the string header file. A sample run could look like this:</p> <pre><code>Enter your first name: Flip\nEnter your last name: Fleming\nHere\u2019s the information in a single string: Fleming, Flip\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() \n{\n    using namespace std;\n    string szFirstName;\n    string szLastName;\n    string szConNames;\n\n    cout &lt;&lt; \"Enter your first name: \"; \n    getline(cin, szFirstName);\n\n    cout &lt;&lt; \"Enter your last name: \";\n    getline(cin, szLastName);\n\n    cout &lt;&lt; \"Here is the information in a single string: \";\n    szConNames = szLastName + \", \" + szFirstName;\n    cout &lt;&lt; szConNames &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>5 - The CandyBar structure contains three members. The first member holds the brand name of a candy bar. The second member holds the weight (which may have a fractional part) of the candy bar, and the third member holds the number of calories (an integer value) in the candy bar. Write a program that declares such a structure and creates a CandyBar variable called snack, initializing its members to \"Mocha Munch\", 2.3, and 350, respectively.The initialization should be part of the declaration for snack. Finally, the program should display the contents of the snack variable.</p> Code <pre><code>#include &lt;iostream&gt;\n\nstruct CandyBar{\n    char name[20];\n    float weight;\n    int calories;\n};\n\nint main() \n{\n    using namespace std;\n\n    CandyBar snack {\"Mocha Munch\", 2.3, 350};\n\n    cout &lt;&lt; \"Snack name: \" &lt;&lt; snack.name &lt;&lt; endl \n         &lt;&lt; \"Snack weight: \" &lt;&lt; snack.weight &lt;&lt; endl \n         &lt;&lt; \"Snack calories: \" &lt;&lt; snack.calories &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>6 - The CandyBar structure contains three members, as described in Programming Exercise 5.Write a program that creates an array of three CandyBar structures, initializes them to values of your choice, and then displays the contents of each structure.</p> Code <pre><code>#include &lt;iostream&gt;\n\nstruct CandyBar{\n    char name[20];\n    float weight;\n    int calories;\n};\n\nint main() \n{\n    using namespace std;\n\n    CandyBar snack[3];\n\n    snack[0] = {\"Mocha Munch\", 2.3, 350};\n    snack[1] = {\"Nom Nom Nom\", 4.5, 440};\n    snack[2] = {\"Diet Munch\", 5.3, 600};\n\n    // // Also correct\n    // snack[3] =\n    // {\n    //     {\"Mocha Munch\", 2.3, 350};\n    //     {\"Nom Nom Nom\", 4.5, 440};\n    //     {\"Diet Munch\", 5.3, 600}\n    // };\n\n    cout &lt;&lt; \"Snack name: \" &lt;&lt; snack[0].name &lt;&lt; endl \n         &lt;&lt; \"Snack weight: \" &lt;&lt; snack[0].weight &lt;&lt; endl \n         &lt;&lt; \"Snack calories: \" &lt;&lt; snack[0].calories &lt;&lt; endl &lt;&lt; endl;\n\n    cout &lt;&lt; \"Snack name: \" &lt;&lt; snack[1].name &lt;&lt; endl \n         &lt;&lt; \"Snack weight: \" &lt;&lt; snack[1].weight &lt;&lt; endl \n         &lt;&lt; \"Snack calories: \" &lt;&lt; snack[1].calories &lt;&lt; endl &lt;&lt; endl;\n\n    cout &lt;&lt; \"Snack name: \" &lt;&lt; snack[2].name &lt;&lt; endl \n         &lt;&lt; \"Snack weight: \" &lt;&lt; snack[2].weight &lt;&lt; endl \n         &lt;&lt; \"Snack calories: \" &lt;&lt; snack[2].calories &lt;&lt; endl &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>7 - William Wingate runs a pizza-analysis service. For each pizza, he needs to record the following information:</p> <ul> <li>The name of the pizza company, which can consist of more than one word</li> <li>The diameter of the pizza</li> <li>The weight of the pizza</li> </ul> <p>Devise a structure that can hold this information and write a program that uses a structure variable of that type.The program should ask the user to enter each of the preceding items of information, and then the program should display that information. Use cin (or its methods) and cout.</p> Code <pre><code>#include &lt;iostream&gt;\n\nstruct Pizza{\n    char name[50];\n    float diameter;\n    float weight;\n};\n\nint main() \n{\n    using namespace std;\n    Pizza myPizza;\n\n     cout &lt;&lt; \"Enter the name of your pizza: \";\n     cin.getline(myPizza.name, 50);\n     cout &lt;&lt; \"Enter the diameter of your pizza: \";\n     cin &gt;&gt; myPizza.diameter;\n     cout &lt;&lt; \"Enter the weight of your pizza: \";\n     cin &gt;&gt; myPizza.weight;\n\n    cout &lt;&lt; endl &lt;&lt; \"My Pizza name: \" &lt;&lt; myPizza.name &lt;&lt; endl \n         &lt;&lt; \"My Pizza diameter: \" &lt;&lt; myPizza.diameter &lt;&lt; endl \n         &lt;&lt; \"My Pizza weight: \" &lt;&lt; myPizza.weight &lt;&lt; endl &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>8 - Do Programming Exercise 7 but use new to allocate a structure instead of declaring a structure variable. Also have the program request the pizza diameter before it requests the pizza company name.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nstruct Pizza\n{\n    char name[50];\n    float diameter;\n    float weight;\n};\n\nint main()\n{\n    using namespace std;\n    Pizza *myPizza = new Pizza;\n\n    cout &lt;&lt; \"Enter the diameter of your pizza: \";\n    // cin leaves a newline character in the input stream .get removes it (chapter 3: C-style strings)\n    (cin &gt;&gt; myPizza-&gt;diameter).get();\n    cout &lt;&lt; \"Enter the name of your pizza: \";\n    cin.getline(myPizza-&gt;name, 50);\n    cout &lt;&lt; \"Enter the weight of your pizza: \";\n    cin &gt;&gt; myPizza-&gt;weight;\n\n    cout &lt;&lt; endl\n         &lt;&lt; \"My Pizza name: \" &lt;&lt; myPizza-&gt;name &lt;&lt; endl\n         &lt;&lt; \"My Pizza diameter: \" &lt;&lt; myPizza-&gt;diameter &lt;&lt; endl\n         &lt;&lt; \"My Pizza weight: \" &lt;&lt; myPizza-&gt;weight &lt;&lt; endl\n         &lt;&lt; endl;\n\n    delete myPizza;\n\n    return 0;\n}\n</code></pre> <p>9 - Do Programming Exercise 6, but instead of declaring an array of three CandyBar structures, use new to allocate the array dynamically.</p> Code <pre><code>#include &lt;iostream&gt;\n\nstruct CandyBar\n{\n    char name[20];\n    float weight;\n    int calories;\n};\n\nint main()\n{\n    using namespace std;\n\n    CandyBar *snack = new CandyBar[3];\n\n    snack[0] = {\"Mocha Munch\", 2.3, 350};\n    snack[1] = {\"Nom Nom Nom\", 4.5, 440};\n    snack[2] = {\"Diet Munch\", 5.3, 600};\n\n    cout &lt;&lt; \"Snack name: \" &lt;&lt; snack[0].name &lt;&lt; endl\n         &lt;&lt; \"Snack weight: \" &lt;&lt; snack[0].weight &lt;&lt; endl\n         &lt;&lt; \"Snack calories: \" &lt;&lt; snack[0].calories &lt;&lt; endl\n         &lt;&lt; endl;\n\n    cout &lt;&lt; \"Snack name: \" &lt;&lt; snack[1].name &lt;&lt; endl\n         &lt;&lt; \"Snack weight: \" &lt;&lt; snack[1].weight &lt;&lt; endl\n         &lt;&lt; \"Snack calories: \" &lt;&lt; snack[1].calories &lt;&lt; endl\n         &lt;&lt; endl;\n\n    cout &lt;&lt; \"Snack name: \" &lt;&lt; snack[2].name &lt;&lt; endl\n         &lt;&lt; \"Snack weight: \" &lt;&lt; snack[2].weight &lt;&lt; endl\n         &lt;&lt; \"Snack calories: \" &lt;&lt; snack[2].calories &lt;&lt; endl\n         &lt;&lt; endl;\n\n    delete[] snack;\n\n    return 0;\n}\n</code></pre> <p>10 - Write a program that requests the user to enter three times for the 40-yd dash (or 40-meter, if you prefer) and then displays the times and the average. Use an array object to hold the data. (Use a built-in array if array is not available.)</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nint main()\n{\n     using namespace std;\n     array&lt;int, 3&gt; aDash{}; // or int aDash[3] {};\n\n     cout &lt;&lt; \"enter three times the 40-meter dash: \\n\";\n     cin &gt;&gt; aDash[0] &gt;&gt; aDash[1] &gt;&gt; aDash[2];\n     cout &lt;&lt; \"Average: \" &lt;&lt; (aDash[0] + aDash[1] + aDash[2]) / 3.0 &lt;&lt; \" \\n\";\n\n     return 0;\n}\n</code></pre>"},{"location":"exercises/#chapter-5","title":"Chapter 5","text":"<p>1 - Write a program that requests the user to enter two integers.The program should then calculate and report the sum of all the integers between and including the two integers. At this point, assume that the smaller integer is entered first. For example, if the user enters 2 and 9, the program should report that the sum of all the integers from 2 through 9 is 44.</p> Code <pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    using namespace std;\n    int iVal[2] {}, iSum {};\n\n    cout &lt;&lt; \"Enter two integers: \" &lt;&lt; endl;\n    cout &lt;&lt; \"  First integer: \";\n    cin &gt;&gt; iVal[0];\n\n    cout &lt;&lt; \"  Second integer: \";\n    cin &gt;&gt; iVal[1];\n\n    if (iVal[0] &gt; iVal[1]){\n        int temp {};\n\n        temp = iVal[0]; \n        iVal[0] = iVal[1];\n        iVal[1] = temp;\n    }\n\n    for (size_t i = iVal[0]; i &lt;= iVal[1]; i++)\n        iSum += i;\n\n    cout &lt;&lt; \"Sum of integers from \" &lt;&lt; iVal[0] &lt;&lt; \" to \" &lt;&lt; iVal[1] &lt;&lt; \" is \" &lt;&lt; iSum &lt;&lt; endl;\n\n    return 0;    \n}\n</code></pre> <p>2 - Redo Listing 5.4 using a type array object instead of a built-in array and type long double instead of long long. Find the value of 100!</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nint main()\n{\n    using namespace std;\n    array&lt;long double, 2&gt; dVal {};\n    long double dSum {};\n\n    cout &lt;&lt; \"Enter two integers: \" &lt;&lt; endl;\n    cout &lt;&lt; \"  First integer: \";\n    cin &gt;&gt; dVal[0];\n\n    cout &lt;&lt; \"  Second integer: \";\n    cin &gt;&gt; dVal[1];\n\n    if (dVal[0] &gt; dVal[1]){\n        int temp {};\n\n        temp = dVal[0]; \n        dVal[0] = dVal[1];\n        dVal[1] = temp;\n    }\n\n    for (size_t i = dVal[0]; i &lt;= dVal[1]; i++)\n        dSum += i;\n\n    cout &lt;&lt; \"Sum of integers from \" &lt;&lt; dVal[0] &lt;&lt; \" to \" &lt;&lt; dVal[1] &lt;&lt; \" is \" &lt;&lt; dSum &lt;&lt; endl;\n\n    return 0;    \n}\n</code></pre> <p>3 - Write a program that asks the user to type in numbers.After each entry, the program should report the cumulative sum of the entries to date.The program should terminate when the user enters 0.</p> Code <pre><code>#include &lt;iostream&gt;\n\nint main() \n{\n    using namespace std;\n    long double dVal {}, dSum {};\n\n    cout &lt;&lt; \"Enter a number, the program will sum it all.\\n\";\n    cout &lt;&lt; \"Enter 0 to exit.\\n\\n\";\n\n    do{\n        cout &lt;&lt; \"Enter a number : \";\n        cin &gt;&gt; dVal;\n        dSum += dVal;\n        cout &lt;&lt; \"Sum : \" &lt;&lt; dSum &lt;&lt; endl;\n    }while (dVal != 0);\n\n    cout &lt;&lt; \"Bye!\\n\";\n    return 0;\n}\n</code></pre> <p>4 - Daphne invests <code>$100 at 10%</code> simple interest.That is, every year, the investment earns <code>10%</code> of the original investment, or <code>$10</code> each and every year:</p> <pre><code>interest = 0.10 \u00d7 original balance\n</code></pre> <p>At the same time, Cleo invests <code>$100</code> at <code>5%</code> compound interest.That is, interest is <code>5%</code> of the current balance, including previous additions of interest:</p> <pre><code>interest = 0.05 \u00d7 current balance\n</code></pre> <p>Cleo earns <code>5% of $100</code> the first year, giving her <code>$105</code>.The next year she earns <code>5%</code> of <code>$105</code>, or <code>$5.25</code>, and so on. Write a program that finds how many years it takes for the value of Cleo\u2019s investment to exceed the value of Daphne\u2019s investment and then displays the value of both investments at that time.</p> Code <pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    using namespace std;\n    double dSimple {100}, dCompound {100};\n    double dSimpleSum {dSimple}, dCompoundSum {dCompound};\n    size_t i {0};\n\n    cout &lt;&lt; \"\\nInitial investment in 10% Simple interest: \" &lt;&lt; dSimple &lt;&lt; endl;\n    cout &lt;&lt; \"Initial investment in 5% Compound interest: \" &lt;&lt; dCompound &lt;&lt; endl &lt;&lt; endl;\n\n    do\n    {\n        i++;\n        dSimpleSum += dSimple * 0.1;\n        dCompoundSum += dCompoundSum * 0.05;\n    } while (dSimpleSum &gt; dCompoundSum);\n\n    cout &lt;&lt; \"Simple Interest after \" &lt;&lt; i &lt;&lt; \" years: \" &lt;&lt; dSimpleSum &lt;&lt; endl;\n    cout &lt;&lt; \"Compound Interest after \" &lt;&lt; i &lt;&lt; \" years: \" &lt;&lt; dCompoundSum &lt;&lt; endl;\n\n    cout &lt;&lt; endl &lt;&lt; \"  It takes \" &lt;&lt; i &lt;&lt; \" years for compound investment to exceed simple investment.\" &lt;&lt; endl &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>5 - You sell the book C++ for Fools. Write a program that has you enter a year\u2019s worth of monthly sales (in terms of number of books, not of money).The program should use a loop to prompt you by month, using an array of char * (or an array of string objects, if you prefer) initialized to the month strings and storing the input data in an array of int.Then, the program should find the sum of the array contents and report the total sales for the year.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    using namespace std;\n    string sMonths[] {\n        \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n        \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\n    // const char *sMonths[12] {                                                // also correct\n    //     \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \n    //     \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\n\n    int iSales[12];\n    long lTotal {};\n\n    cout &lt;&lt; \"Enter monthly sale for a: \\n\";\n\n    for (size_t i = 0; i &lt; 12; i++)\n    {\n        cout &lt;&lt; sMonths[i] &lt;&lt; \": \"; \n        cin &gt;&gt; iSales[i];\n        lTotal += iSales[i];\n    }\n\n    cout &lt;&lt; \"\\nTotal sales for the year: \" &lt;&lt; lTotal &lt;&lt; endl;   \n\n    return 0;\n}\n</code></pre> <p>6 - Do Programming Exercise 5 but use a two-dimensional array to store input for 3 years of monthly sales. Report the total sales for each individual year and for the combined years.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    using namespace std;\n    string sMonths[]{\n        \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n        \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\n    int iSales[3][12] {};\n    long lYearlyTotal[3] {};\n    long lTotal{};\n\n    for (size_t i = 0; i &lt; 3; i++)\n    {\n        cout &lt;&lt; \"For \" &lt;&lt; (i + 1) &lt;&lt; \" year, enter the sale for: \\n\";\n        for (size_t j = 0; j &lt; 12; j++)\n        {\n            cout &lt;&lt; sMonths[j] &lt;&lt; \": \";\n            cin &gt;&gt; iSales[i][j];\n            lYearlyTotal[i] += iSales[i][j];\n        }\n        lTotal += lYearlyTotal[i];\n        cout &lt;&lt; \"\\nTotal sales for \" &lt;&lt; (i + 1) &lt;&lt; \" year: \" &lt;&lt; lYearlyTotal[i] &lt;&lt; \"\\n\";\n    }\n\n    cout &lt;&lt; \"\\nTotal sales for all years: \" &lt;&lt; lTotal &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>7 - Design a structure called car that holds the following information about an automobile: its make, as a string in a character array or in a string object, and the year it was built, as an integer.Write a program that asks the user how many cars to catalog. The program should then use new to create a dynamic array of that many car structures. Next, it should prompt the user to input the make (which might consist of more than one word) and year information for each structure. Note that this requires some care because it alternates reading strings with numeric data (see Chapter 4). Finally, it should display the contents of each structure.A sample run should look something like the following:</p> <pre><code>How many cars do you wish to catalog? 2\nCar #1:\nPlease enter the make: Hudson Hornet\nPlease enter the year made: 1952\nCar #2:\nPlease enter the make: Kaiser\nPlease enter the year made: 1951\nHere is your collection:\n1952 Hudson Hornet\n1951 Kaiser\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct car{\n    std::string make;\n    int year;\n};\n\nint main()\n{\n    using namespace std;\n    int iNumCars{};\n\n    cout &lt;&lt; \"How many cars do you wish to catalog? : \";\n    (cin &gt;&gt; iNumCars).get();\n\n    car *pCar = new car[iNumCars];\n\n    for (size_t i = 0; i &lt; iNumCars; i++)\n    {\n        cout &lt;&lt; \"Car #\" &lt;&lt; i + 1 &lt;&lt; \":\" &lt;&lt; endl;\n\n        cout &lt;&lt; \"Please enter the make: \";\n        getline(cin, pCar[i].make);\n\n        cout &lt;&lt; \"Please enter the year made: \";\n        (cin &gt;&gt; pCar[i].year).get();\n    }\n\n    cout &lt;&lt; \"\\nHere is your collection:\\n\";\n    for (size_t i = 0; i &lt; iNumCars; i++)\n        cout &lt;&lt; pCar[i].year &lt;&lt; \" \" &lt;&lt; pCar[i].make &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>8 - Write a program that uses an array of char and a loop to read one word at a time until the word done is entered.The program should then report the number of words entered (not counting done).A sample run could look like this:</p> <pre><code>Enter words (to stop, type the word done):\nanteater birthday category dumpster\nenvy finagle geometry done for sure\nYou entered a total of 7 words.\n</code></pre> <p>You should include the cstring header file and use the strcmp() function to make the comparison test.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nint main()\n{\n    using namespace std;\n    char word[100];\n    int count{};\n\n    cout &lt;&lt; \"Enter words (to stop, type the word done):\\n\";\n    do\n    {\n        cin &gt;&gt; word;\n        ++count;\n    } while (strcmp(word, \"done\"));\n    cout &lt;&lt; endl\n         &lt;&lt; \"You entered a total of \" &lt;&lt; count &lt;&lt; \" words\\n\";\n\n    return 0;\n}\n</code></pre> <p>9 - Write a program that matches the description of the program in Programming Exercise 8, but use a string class object instead of an array. Include the string header file and use a relational operator to make the comparison test.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nint main()\n{\n    using namespace std;\n    string word;\n    int count{};\n\n    cout &lt;&lt; \"Enter words (to stop, type the word done):\\n\";\n    do\n    {\n        cin &gt;&gt; word;\n        ++count;\n    } while (word != \"done\");\n    cout &lt;&lt; endl\n         &lt;&lt; \"You entered a total of \" &lt;&lt; count &lt;&lt; \" words\\n\";\n\n    return 0;\n}\n</code></pre> <p>10 - Write a program using nested loops that asks the user to enter a value for the number of rows to display. It should then display that many rows of asterisks, with one asterisk in the first row, two in the second row, and so on. For each row, the asterisks are preceded by the number of periods needed to make all the rows display a total number of characters equal to the number of rows.A sample run would look like this:</p> <pre><code>Enter number of rows: 5\n....*\n...**\n..***\n.****\n*****\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nint main()\n{\n    using namespace std;\n    int iRows{};\n\n    cout &lt;&lt; \"Enter number of rows: \";\n    cin &gt;&gt; iRows;\n\n    for (size_t i = 0; i &lt; iRows; i++)                  // lines to print\n    {\n        // dots to print: \n        // dot = 1, -&gt; because per 3 chars there is one `star`\n        // dot &lt; iRows - i, -&gt; because the next line will have one more `star` \n        //                     and one less `dot` EVERY LOOP\n        for (size_t dot = 1; dot &lt; iRows - i; ++dot)    // DOTS ARE PRINTED FIRST\n            cout &lt;&lt; \".\";\n        for (size_t star = 0; star &lt;= i; ++star)        // STARS ARE PRINTED SECOND\n            cout &lt;&lt; \"*\";\n\n        // // Different solution\n        // for (size_t dot = i; dot &lt; iRows - 1; dot++)\n        //     cout &lt;&lt; '.';\n        // for (size_t star = i + 1; star != 0; star--)\n        //     cout &lt;&lt; '*';\n\n        cout &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"exercises/#chapter-6","title":"Chapter 6","text":"<p>1 - Write a program that reads keyboard input to the @ symbol and that echoes the input except for digits, converting each uppercase character to lowercase, and vice versa. (Don\u2019t forget the <code>cctype</code> family.)</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cctype&gt;\n\nint main(){\n    using namespace std;\n\n    char cInput;\n\n    while (cin.get(cInput) &amp;&amp; cInput != '@')\n    {\n        if(isdigit(cInput))\n            cInput = ' ';\n        else if(isupper(cInput))\n            cInput = tolower(cInput);\n        else\n            cInput = toupper(cInput);\n        cout &lt;&lt; cInput;\n    }\n\n    return 0;\n}\n</code></pre> <p>2 - Write a program that reads up to 10 donation values into an array of double. (Or, if you prefer, use an array template object.) The program should terminate input on non-numeric input. It should report the average of the numbers and also report how many numbers in the array are larger than the average.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cctype&gt;\n\nconst int MAX_SIZE = 10;\n\nint main()\n{\n    using namespace std;\n\n    double dArray[MAX_SIZE]{};\n    double dAboveAverage{}, dSum{};\n    int i{};\n\n    cout &lt;&lt; \"Write \" &lt;&lt; MAX_SIZE &lt;&lt; \" donations: \\n\";\n    cout &lt;&lt; \"\\n #\" &lt;&lt; i + 1 &lt;&lt; \" donation: \";\n\n    while (i &lt; MAX_SIZE &amp;&amp; cin &gt;&gt; dArray[i])\n    {\n        dSum += dArray[i];\n        if(++i &lt; MAX_SIZE)\n            cout &lt;&lt; \" #\" &lt;&lt; i + 1 &lt;&lt; \" donation: \";\n    }\n\n    for (size_t j = 0; j &lt; i; j++)\n        if (dArray[j] &gt; (dSum / i))\n            ++dAboveAverage;\n\n    cout &lt;&lt; \"\\n\\n   Average from donations: \" &lt;&lt; dSum / i &lt;&lt; endl;\n    cout &lt;&lt; \"   Amount of donations above average: \" &lt;&lt; dAboveAverage &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>3 - Write a precursor to a menu-driven program.The program should display a menu offering four choices, each labeled with a letter. If the user responds with a letter other than one of the four valid choices, the program should prompt the user to enter a valid response until the user complies.Then the program should use a switch to select a simple action based on the user\u2019s selection. A program run could look something like this:</p> <pre><code>Please enter one of the following choices:\nc) carnivore    p) pianist\nt) tree         g) game\nf\nPlease enter a c, p, t, or g: q\nPlease enter a c, p, t, or g: t\nA maple is a tree.\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n\nint main(){\n    using namespace std;\n    char cMenu;\n\n    cout &lt;&lt; \"Please enter one of the following choices:\" &lt;&lt; endl \n         &lt;&lt; \"c) carnivore\\t p) pianist\" &lt;&lt; endl \n         &lt;&lt; \"t) tree\\t\\t g) game\" &lt;&lt; endl;\n\n    cin &gt;&gt; cMenu;\n\n    while(true){\n        switch (cMenu)\n        {\n        case 'c':        \n            cout &lt;&lt; \"Cat is a carnivore.\";\n            break;\n        case 'p':        \n            cout &lt;&lt; \"Beethoven is a pianist\";\n            break;\n        case 't':        \n            cout &lt;&lt; \"A maple is a tree.\";\n            break;\n        case 'g':        \n            cout &lt;&lt; \"Rain World is a good game.\";\n            break;\n        default:\n            cout &lt;&lt; \"Please enter a: c, p, t, or g: \";\n            break;\n        }\n        cin &gt;&gt; cMenu;\n    }\n\n    return 0;\n}\n</code></pre> <p>4 - When you join the Benevolent Order of Programmers, you can be known at BOP meetings by your real name, your job title, or your secret BOP name. Write a program that can list members by real name, by job title, by secret name, or by a member\u2019s preference. Base the program on the following structure:</p> <pre><code>// Benevolent Order of Programmers name structure\nstruct bop\n{\n    char fullname[strsize]; // real name\n    char title[strsize];    // job title\n    char bopname[strsize];  // secret BOP name\n    int preference;         // 0 = fullname, 1 = title, 2 = bopname\n};\n</code></pre> <p>In the program, create a small array of such structures and initialize it to suitable values. Have the program run a loop that lets the user select from different alternatives:</p> <pre><code>a. display by name      b. display by title\nc. display by bopname   d. display by preference\nq. quit\n</code></pre> <p>Note that \u201cdisplay by preference\u201d does not mean display the preference member; it means display the member corresponding to the preference number. For instance, if preference is 1, choice d would display the programmer\u2019s job title.A sample run may look something like the following:</p> <pre><code>Benevolent Order of Programmers Report\na. display by name b. display by title\nc. display by bopname d. display by preference\nq. quit\nEnter your choice: a\nWimp Macho\nRaki Rhodes\nCelia Laiter\nHoppy Hipman\nPat Hand\nNext choice: d\nWimp Macho\nJunior Programmer\nMIPS\nAnalyst Trainee\nLOOPY\nNext choice: q\nBye!\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nconst int sizeBOP = 5;\nconst int strsize = 50;\n// Benevolent Order of Programmers name structure\nstruct bop\n{\n    char fullname[strsize]; // real name\n    char title[strsize];    // job title\n    char bopname[strsize];  // secret BOP name\n    int preference;         // 0 = fullname, 1 = title, 2 = bopname\n};\n\nint main()\n{\n    using namespace std;\n    char cMenu;\n\n    cout &lt;&lt; \"Please enter one of the following choices:\" &lt;&lt; endl\n         &lt;&lt; \"a. display by name\\t b. display by title\" &lt;&lt; endl\n         &lt;&lt; \"c. display by bopname\\t d. display by preference\" &lt;&lt; endl\n         &lt;&lt; \"q. quit\" &lt;&lt; endl;\n\n    cout &lt;&lt; \"Enter your choice: \";\n    cin &gt;&gt; cMenu;\n\n    bop *stBOP = new bop[sizeBOP];\n    strcpy(stBOP[0].fullname, \"Wimp Macho\");\n    strcpy(stBOP[0].title, \"Chef\");\n    strcpy(stBOP[0].bopname, \"BOPA\");\n    stBOP[0].preference = 0;\n\n    strcpy(stBOP[1].fullname, \"Raki Rhodes\");\n    strcpy(stBOP[1].title, \"Junior Programmer\");\n    strcpy(stBOP[1].bopname, \"RAKI\");\n    stBOP[1].preference = 1;\n\n    strcpy(stBOP[2].fullname, \"Celia Laiter\");\n    strcpy(stBOP[2].title, \"Senior Programmer\");\n    strcpy(stBOP[2].bopname, \"MIPS\");\n    stBOP[2].preference = 2;\n\n    strcpy(stBOP[3].fullname, \"Hoppy Hipman\");\n    strcpy(stBOP[3].title, \"Analyst trainee\");\n    strcpy(stBOP[3].bopname, \"MEHA\");\n    stBOP[3].preference = 1;\n\n    strcpy(stBOP[4].fullname, \"Pat Hand\");\n    strcpy(stBOP[4].title, \"Boss\");\n    strcpy(stBOP[4].bopname, \"LOOPY\");\n    stBOP[4].preference = 2;\n\n    while (cMenu != 'q')\n    {\n        switch (cMenu)\n        {\n        case 'a':\n            for (int i{}; i &lt; sizeBOP; ++i)\n                cout &lt;&lt; stBOP[i].fullname &lt;&lt; endl;\n            break;\n        case 'b':\n            for (int i{}; i &lt; sizeBOP; ++i)\n                cout &lt;&lt; stBOP[i].title &lt;&lt; endl;\n            break;\n        case 'c':\n            for (int i{}; i &lt; sizeBOP; ++i)\n                cout &lt;&lt; stBOP[i].bopname &lt;&lt; endl;\n            break;\n        case 'd':\n            for (int i{}; i &lt; sizeBOP; ++i)\n            {\n                switch (stBOP[i].preference)\n                {\n                case 0: cout &lt;&lt; stBOP[i].fullname &lt;&lt; endl;  break;\n                case 1: cout &lt;&lt; stBOP[i].title &lt;&lt; endl;     break;\n                case 2: cout &lt;&lt; stBOP[i].bopname &lt;&lt; endl;   break;\n                default: cout &lt;&lt; \"No preference\" &lt;&lt; endl;   break;\n                }\n            }\n            break;\n        default:\n            cout &lt;&lt; \"Please enter: a, b, c, d, or q. : \";\n            break;\n        }\n        cout &lt;&lt; \"Next choice: \";\n        cin &gt;&gt; cMenu;\n    }\n    delete[] stBOP;\n    cout &lt;&lt; \"Bye!\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>5 - The Kingdom of Neutronia, where the unit of currency is the tvarp, has the following income tax code:</p> <pre><code>    First 5,000 tvarps: 0% tax\n    Next 10,000 tvarps: 10% tax\n    Next 20,000 tvarps: 15% tax\n    Tvarps after 35,000: 20% tax\n</code></pre> <p>For example, someone earning 38,000 tvarps would owe 5,000 \u00d7 0.00 + 10,000 \u00d7 0.10 + 20,000 \u00d7 0.15 + 3,000 \u00d7 0.20, or 4,600 tvarps. Write a program that uses a loop to solicit incomes and to report tax owed. The loop should terminate when the user enters a negative number or non-numeric input.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n\nint main(){\n    using namespace std;\n    long double dIncome{}, dTax{}; \n\n    cout &lt;&lt; \"Enter income in tvarps: \";\n    while(cin &gt;&gt; dIncome){\n        if(dIncome &lt; 0)\n            break;\n\n        if (dIncome &lt;= 5000)\n            dTax = 0;\n        else if(dIncome &lt;= 15000)\n            dTax = (dIncome - 5000) * 0.1;\n        else if(dIncome &lt; 35000)\n            dTax = (dIncome - 15000) * 0.15 + 10000 * 0.1;\n        else\n            dTax = (dIncome - 35000) * 0.2 + 20000 * 0.15 + 10000 * 0.1;\n\n        cout &lt;&lt; \"Your tax is: \" &lt;&lt; dTax &lt;&lt; \" tvarps\" &lt;&lt; endl;\n        cout &lt;&lt; \"Enter income in tvarps: \";\n    }\n    return 0;\n}\n</code></pre> <p>6 - Put together a program that keeps track of monetary contributions to the Society for the Preservation of Rightful Influence. It should ask the user to enter the number of contributors and then solicit the user to enter the name and contribution of each contributor.The information should be stored in a dynamically allocated array of structures. Each structure should have two members: a character array (or else a <code>string</code> object) to store the name and a <code>double</code> member to hold the amount of the contribution.After reading all the data, the program should display the names and amounts donated for all donors who contributed $10,000 or more. This list should be headed by the label Grand Patrons.After that, the program should list the remaining donors. That list should be headed Patrons. If there are no donors in one of the categories, the program should print the word \u201cnone\u201d. Aside from displaying two categories, the program need do no sorting.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct stSocietyPRI\n{\n    std::string name;\n    double contribution;\n};\n\nint main()\n{\n    using namespace std;\n    int iContrbutors{}, iCounter{};\n\n    cout &lt;&lt; \"Enter the number of contributors: \";\n\n    while (!(cin &gt;&gt; iContrbutors))\n    {\n        cin.clear(); // reset input\n        while (cin.get() != '\\n')\n            continue; // get rid of bad input\n        cout &lt;&lt; \"Please enter a number: \";\n    }\n    cin.get(); // clear the input buffer\n\n    stSocietyPRI *pSociety = new stSocietyPRI[iContrbutors];\n\n    for (size_t i = 0; i &lt; iContrbutors; i++)\n    {\n        cout &lt;&lt; \"Enter the name of the \" &lt;&lt; i + 1 &lt;&lt; \" contributor: \";\n        getline(cin, pSociety[i].name);\n\n        cout &lt;&lt; \"Enter the contribution of the \" &lt;&lt; i + 1 &lt;&lt; \" contributor: \";\n        while (!(cin &gt;&gt; pSociety[i].contribution))\n        {\n            cin.clear(); // reset input\n            while (cin.get() != '\\n')\n                continue; // get rid of bad input\n            cout &lt;&lt; \"Please enter a number: \";\n        }\n        cin.get(); // clear the input buffer\n    }\n\n    // Print Grand Patrons\n    iCounter = 0;\n    cout &lt;&lt; \"Grand Patrons: \\n\";\n    for (size_t i = 0; i &lt; iContrbutors; i++)\n    {\n        if (pSociety[i].contribution &gt;= 10000)\n        {\n            cout &lt;&lt; \"\\t\" &lt;&lt; pSociety[i].name &lt;&lt; \"; \\n\";\n            ++iCounter;\n        }\n    }\n    if (iCounter == 0)\n        cout &lt;&lt; \"\\tnone\\n\";\n\n    // Print the rest Patrons\n    iCounter = 0;\n    cout &lt;&lt; \"Patrons: \\n\";\n    for (size_t i = 0; i &lt; iContrbutors; i++)\n    {\n        if (pSociety[i].contribution &lt; 10000)\n        {\n            cout &lt;&lt; \"\\t\" &lt;&lt; pSociety[i].name &lt;&lt; \"; \\n\";\n            ++iCounter;\n        }\n    }\n    if (iCounter == 0)\n        cout &lt;&lt; \"\\tnone\\n\";\n\n    return 0;\n}\n</code></pre> <p>7 - Write a program that reads input a word at a time until a lone q is entered. The program should then report the number of words that began with vowels, the number that began with consonants, and the number that fit neither of those categories. One approach is to use <code>isalpha()</code> to discriminate between words beginning with letters and those that don\u2019t and then use an <code>if</code> or <code>switch</code> statement to further identify those passing the <code>isalpha()</code> test that begin with vowels.A sample run might look like this:</p> <pre><code>Enter words (q to quit):\nThe 12 awesome oxen ambled\nquietly across 15 meters of lawn. q\n5 words beginning with vowels\n4 words beginning with consonants\n2 others\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;cctype&gt;\n\nint main()\n{\n    using namespace std;\n    char cInput[100];\n    int iNumOther{}, iNumVowels{}, iNumConsonants{};\n\n    cout &lt;&lt; \"\\nEnter words (q to quit):\\n\";\n\n    do\n    {\n        cin &gt;&gt; cInput;\n        if (!isalpha(cInput[0]))\n        {\n            ++iNumOther;\n        }\n        else if (cInput[0] == 'A' || cInput[0] == 'E' ||\n                 cInput[0] == 'I' || cInput[0] == 'O' ||\n                 cInput[0] == 'U' || cInput[0] == 'Y' ||\n                 cInput[0] == 'a' || cInput[0] == 'e' ||\n                 cInput[0] == 'i' || cInput[0] == 'o' ||\n                 cInput[0] == 'u' || cInput[0] == 'y')\n        {\n            ++iNumVowels;\n        }\n        else if (cInput[0] == 'A' || cInput[0] == 'C' || cInput[0] == 'D' ||\n                 cInput[0] == 'F' || cInput[0] == 'G' || cInput[0] == 'J' ||\n                 cInput[0] == 'K' || cInput[0] == 'L' || cInput[0] == 'M' ||\n                 cInput[0] == 'N' || cInput[0] == 'P' || cInput[0] == 'Q' ||\n                 cInput[0] == 'S' || cInput[0] == 'T' || cInput[0] == 'V' ||\n                 cInput[0] == 'X' || cInput[0] == 'Z' ||\n                 cInput[0] == 'a' || cInput[0] == 'c' || cInput[0] == 'd' ||\n                 cInput[0] == 'f' || cInput[0] == 'g' || cInput[0] == 'j' ||\n                 cInput[0] == 'k' || cInput[0] == 'l' || cInput[0] == 'm' ||\n                 cInput[0] == 'n' || cInput[0] == 'p' || cInput[0] == 'q' ||\n                 cInput[0] == 's' || cInput[0] == 't' || cInput[0] == 'v' ||\n                 cInput[0] == 'x' || cInput[0] == 'z')\n        {\n            ++iNumConsonants;\n        }\n        else\n        {\n            ++iNumOther;\n        }\n\n    } while (strcmp(cInput, \"q\"));\n    --iNumConsonants; // q  - at the end detected as word(consonant)\n\n    cout &lt;&lt; iNumVowels &lt;&lt; \" words beginning with vowels\\n\";\n    cout &lt;&lt; iNumConsonants &lt;&lt; \" words beginning with consonants\\n\";\n    cout &lt;&lt; iNumOther &lt;&lt; \" others\\n\";\n\n    return 0;\n}\n\n// Different method - pseudocode\n/*\n\n    char sConsonants[]{'b', 'c', 'd', 'f', 'g', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 's', 't', 'v', 'x', 'z',\n                      'B', 'C', 'D', 'F', 'G', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'S', 'T', 'V', 'X', 'Z'};\n    char sWovels[]{'a', 'e', 'i', 'o', 'u',\n                  'A', 'E', 'I', 'O', 'U'};\n\n        cin &gt;&gt; cInput;\n        if (!isalpha(cInput[0]))\n        {\n            ++iNumOther;\n        }\n        else{\n            for (size_t i = 0; i &lt; 12; i++)\n            {\n                if(cInput[0] == sConsonants[i] || cInput[0] == sConsonants[i+11] || cInput[0] == sConsonants[i + 22]){\n                    ++iNumConsonants;\n                    break;\n                }\n                else (cInput[0] == sWovels[i]){\n                    ++iNumVowels;\n                    break;\n                }\n            }\n        }\n*/\n</code></pre> <p>8 - Write a program that opens a text file, reads it character-by-character to the end of the file, and reports the number of characters in the file.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cstdlib&gt;\n\nint main()\n{\n    using namespace std;\n    int iDataCounter;\n\n    ifstream inFile;\n    inFile.open(\"./Notes/C++PrimerPlus/exercises/chapter6/ch6_8.txt\"); //OR ./ch6_8.txt\n\n    if (!inFile.is_open())\n    {\n        cout &lt;&lt; \"Could not open the file\" &lt;&lt; endl;\n        cout &lt;&lt; \"Program terminating.\\n\";\n    }\n\n    while(inFile.good()){\n        ++iDataCounter;\n\n        char temp;\n        inFile &gt;&gt; temp;\n    }\n\n    cout &lt;&lt; \"\\nnumber of characters in the file \" &lt;&lt; iDataCounter &lt;&lt; endl;\n    inFile.close();\n\n    return 0;\n}\n</code></pre> <p>9 - Do Programming Exercise 6 but modify it to get information from a file. The first item in the file should be the number of contributors, and the rest of the file should consist of pairs of lines, with the first line of each pair being a contributor\u2019s name and the second line being a contribution. That is, the file should look like this:</p> <pre><code>4\nSam Stone\n2000\nFreida Flass\n100500\nTammy Tubbs\n5000\nRich Raptor\n55000\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nstruct stSocietyPRI\n{\n    std::string name;\n    double contribution;\n};\n\nint main()\n{\n    using namespace std;\n    int iContrbutors{}, iCounter{};\n\n    ifstream inFile;\n    inFile.open(\"./Notes/C++PrimerPlus/exercises/chapter6/ch6_9.txt\");\n\n    if (!inFile.is_open()) // failed to open file\n    {\n        cout &lt;&lt; \"Could not open the file\" &lt;&lt; endl;\n        cout &lt;&lt; \"Terminate program.\\n\";\n        exit(EXIT_FAILURE);\n    }\n\n    if(inFile.good()){\n        inFile &gt;&gt; iContrbutors; // First line\n    }\n\n    stSocietyPRI *pSociety = new stSocietyPRI[iContrbutors];\n\n    // Read contributors from file \n    for (size_t i = 0; i &lt; iContrbutors; i++)\n    {\n        inFile.get(); // clear buffer\n        getline(inFile, pSociety[i].name);\n        inFile &gt;&gt; pSociety[i].contribution;\n    }\n\n    // Print Grand Patrons\n    iCounter = 0;\n    cout &lt;&lt; \"Grand Patrons: \\n\";\n    for (size_t i = 0; i &lt; iContrbutors; i++)\n    {\n        if (pSociety[i].contribution &gt;= 10000)\n        {\n            cout &lt;&lt; \"\\t\" &lt;&lt; pSociety[i].name &lt;&lt; \"; \\n\";\n            ++iCounter;\n        }\n    }\n    if (iCounter == 0)\n        cout &lt;&lt; \"\\tnone\\n\";\n\n    // Print the rest Patrons\n    iCounter = 0;\n    cout &lt;&lt; \"Patrons: \\n\";\n    for (size_t i = 0; i &lt; iContrbutors; i++)\n    {        if (pSociety[i].contribution &lt; 10000)\n        {\n            cout &lt;&lt; \"\\t\" &lt;&lt; pSociety[i].name &lt;&lt; \"; \\n\";\n            ++iCounter;\n        }\n    }\n    if (iCounter == 0)\n        cout &lt;&lt; \"\\tnone\\n\";\n\n    return 0;\n}\n</code></pre>"},{"location":"exercises/#chapter-7","title":"Chapter 7","text":"<p>1 - Write a program that repeatedly asks the user to enter pairs of numbers until at least one of the pair is 0. For each pair, the program should use a function to calculate the harmonic mean of the numbers. The function should return the answer to <code>main()</code>, which should report the result. The harmonic mean of the numbers is the inverse of the average of the inverses and can be calculated as follows: \\(\\(HarmonicMean = 2.0 \u00d7 x \u00d7 y / (x + y)\\)\\)</p> Code <pre><code>#include &lt;iostream&gt;\n\ndouble fnHarmonicMean(double dNumX, double dNumY)\n{\n    return (2 * dNumX * dNumY) / (dNumX + dNumY);\n}\n\nint main()\n{\n    using namespace std;\n    double dHarmonicMean{1};\n    double dNum[2]{};\n\n    cout &lt;&lt; \"\\nCalculate harmonic mean of pair of numbers.\";\n    cout &lt;&lt; \"\\nFor one of input equal '0', program terminate.\";\n\n    do\n    {\n        cout &lt;&lt; \"\\nEnter two noumbers after space: \";\n        if (!(cin &gt;&gt; dNum[0] &gt;&gt; dNum[1]))\n        {\n            cin.clear();\n            while (cin.get() != '\\n')\n                continue;\n            cout &lt;&lt; \"\\nTry again.\\n\";\n            continue;\n        }\n\n        dHarmonicMean = fnHarmonicMean(dNum[0], dNum[1]);\n\n        if (!dHarmonicMean)\n            break;\n\n        cout &lt;&lt; \"\\nHarmonic mean: \" &lt;&lt; dHarmonicMean;\n        cin.clear();\n    } while (dHarmonicMean != 0);\n\n    cout &lt;&lt; \"\\n\\n\\tBye! Bye! :)\\n\";\n\n    return 0;\n}\n</code></pre> <p>2 - Write a program that asks the user to enter up to 10 golf scores, which are to be stored in an array.You should provide a means for the user to terminate input prior to entering 10 scores.The program should display all the scores on one line and report the average score. Handle input, display, and the average calculation with three separate array-processing functions</p> Code <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint fnInput(double *pdScores, int iLength);\n// int fnInput(double pdScores[], int iLength); // The same\n\ndouble fnCalculation(double *pdScores, int iNumEl);\nvoid fnDisplay(double *dFnScores, double dFnAverage, int iNumEl);\n\nint main(){\n    const int iArrayLength{10}; \n    double dScores[iArrayLength]{};\n    double dAverage{};\n    int iNumEl{};\n\n    iNumEl = fnInput(dScores, iArrayLength);\n    dAverage = fnCalculation(dScores, iNumEl);\n    fnDisplay(dScores, dAverage, iNumEl);\n\n    return 0;\n}\n\nint fnInput(double *dFnScores, int iLength){\n    cout &lt;&lt; \"\\nEnter 10 golf scores (`q` to quit):\\n#1 Score: \";\n\n    int i{};\n    while(cin &gt;&gt; dFnScores[i] &amp;&amp; i &lt; iLength-1)\n        cout &lt;&lt; \"#\" &lt;&lt; (++i + 1) &lt;&lt; \" Score: \";\n\n    return i;\n}\n\ndouble fnCalculation(double *dFnScores, int iNumEl){\n    double dFnAverage{};\n\n    for (int i{}; i &lt;= iNumEl; ++i){\n        cout &lt;&lt; \"\\t\" &lt;&lt; dFnAverage &lt;&lt; \" \" &lt;&lt; dFnScores[i];\n        dFnAverage += dFnScores[i];\n    }\n\n    dFnAverage = dFnAverage / (iNumEl + 1); \n\n    return dFnAverage;\n}\n\nvoid fnDisplay(double *dFnScores, double dFnAverage, int iNumEl){\n    cout &lt;&lt; \"\\nScores: \";\n    for (int j{}; j &lt;= iNumEl; ++j)\n        cout &lt;&lt; dFnScores[j] &lt;&lt; \", \";\n\n    cout &lt;&lt; \"\\nAverage: \" &lt;&lt; dFnAverage &lt;&lt; endl;\n}\n</code></pre> <p>3 - Here is a structure declaration:</p> <pre><code>struct box\n{\n    char maker[40];\n    float height;\n    float width;\n    float length;\n    float volume;\n};\n</code></pre> <ul> <li>Write a function that passes a <code>box</code> structure by value and that displays the value of each member.</li> <li>Write a function that passes the address of a <code>box</code> structure and that sets the <code>volume</code> member to the product of the other three dimensions.</li> <li>Write a simple program that uses these two functions.</li> </ul> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n\nusing namespace std;\n\nstruct box\n{\n    char maker[40];\n    float height;\n    float width;\n    float length;\n    float volume;\n};\n\nvoid fnBoxVal(box b1);\nvoid fnBoxAddr(box *b2);\n\nint main(){\n\n    box sBox1;\n    box * sBox2 = new box;\n\n    // sBox1 - value \n    strcpy(sBox1.maker, \"Oh No!\");\n    sBox1.height = 123.3;\n    sBox1.width = 34;\n    sBox1.length = 899;\n    sBox1.volume = 500;\n\n    fnBoxVal(sBox1);\n    fnBoxAddr(&amp;sBox1);\n\n    // sBox2 - pointer by new\n    strcpy(sBox2-&gt;maker, \"Adress Maker\");\n    sBox2-&gt;height = 23;\n    sBox2-&gt;width = 45;\n    sBox2-&gt;length = 65;\n    sBox2-&gt;volume = 98;    \n\n    fnBoxVal(*sBox2);\n    fnBoxAddr(sBox2);\n\n    return 0;\n}\n\nvoid fnBoxVal(box b1){\n    cout &lt;&lt; \"maker: \" &lt;&lt; b1.maker &lt;&lt; endl;\n    cout &lt;&lt; \"height: \" &lt;&lt; b1.height &lt;&lt; endl;\n    cout &lt;&lt; \"width: \" &lt;&lt; b1.width &lt;&lt; endl;\n    cout &lt;&lt; \"length: \" &lt;&lt; b1.length &lt;&lt; endl;\n    cout &lt;&lt; \"volume: \" &lt;&lt; b1.volume &lt;&lt; endl &lt;&lt; endl;\n}\n\nvoid fnBoxAddr(box *b2){\n    b2-&gt;height = b2-&gt;volume;\n    b2-&gt;width = b2-&gt;volume;\n    b2-&gt;length = b2-&gt;volume;\n\n    cout &lt;&lt; \"maker: \" &lt;&lt; b2-&gt;maker &lt;&lt; endl;\n    cout &lt;&lt; \"height: \" &lt;&lt; b2-&gt;height &lt;&lt; endl;\n    cout &lt;&lt; \"width: \" &lt;&lt; b2-&gt;width &lt;&lt; endl;\n    cout &lt;&lt; \"length: \" &lt;&lt; b2-&gt;length &lt;&lt; endl;\n    cout &lt;&lt; \"volume: \" &lt;&lt; b2-&gt;volume &lt;&lt; endl &lt;&lt; endl;\n}\n</code></pre> <p>4 - Many state lotteries use a variation of the simple lottery portrayed by Listing 7.4 (lotto). In these variations you choose several numbers from one set and call them the field numbers. For example, you might select five numbers from the field of 1\u201347).You also pick a single number (called a mega number or a power ball, etc.) from a second range, such as 1\u201327. To win the grand prize, you have to guess all the picks correctly. The chance of winning is the product of the probability of picking all the field numbers times the probability of picking the mega number. For instance, the probability of winning the example described here is the product of the probability of picking 5 out of 47 correctly times the probability of picking 1 out of 27 correctly. Modify Listing 7.4 to calculate the probability of winning this kind of lottery.</p> Code <pre><code>#include &lt;iostream&gt;\n\n// Note: some implementations require double instead of long double\nlong double probability(unsigned numbers, unsigned picks);\nint main()\n{\n    using namespace std;\n    double total, choices, totalMega;\n    cout &lt;&lt; \"Enter the total number of choices on the game card, total number of choices on mega number\\n\"\n            \"and the number of picks allowed :\\n\";\n    while ((cin &gt;&gt; total &gt;&gt; totalMega &gt;&gt; choices) &amp;&amp; choices &lt;= total)\n    {\n        double temp = probability(total, choices);\n        cout &lt;&lt; \"You have one chance in \";\n        cout &lt;&lt; temp; \n\n        temp = temp * (probability(totalMega, 1));\n        cout &lt;&lt; \" of winning in game card.\\n\";\n        cout &lt;&lt; \"and one chance in: \" &lt;&lt; temp &lt;&lt; \" of winning mega number\" &lt;&lt; endl;\n        cout &lt;&lt; \"Next two numbers (q to quit): \";\n    }\n    cout &lt;&lt; \"bye\\n\";\n    return 0;\n}\n\n// the following function calculates the probability of picking picks\n// numbers correctly from numbers choices\nlong double probability(unsigned numbers, unsigned picks)\n{\n    long double result = 1.0; // here come some local variables\n    long double n;\n    unsigned p;\n    for (n = numbers, p = picks; p &gt; 0; n--, p--)\n        result = result * n / p;\n    return result;\n}\n\n// R = (51 \u00d7 50 \u00d7 49 \u00d7 48 \u00d7 47 \u00d7 46) / (6 \u00d7 5 \u00d7 4 \u00d7 3 \u00d7 2 \u00d7 1)\n</code></pre> <p>5 - Define a recursive function that takes an integer argument and returns the factorial of that argument. Recall that 3 factorial, written 3!, equals 3 \u00d7 2!, and so on, with 0! defined as 1. In general, if n is greater than zero, n! = n * (n - 1)!.Test your function in a program that uses a loop to allow the user to enter various values for which the program reports the factorial</p> Code <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ndouble fnFactorial(int iFactor);\n\nint main(){\n    int iFactor{};\n    double dFactorial{};\n\n    cout &lt;&lt; \"\\nEnter a number to get factorial: \";\n    while (!(cin &gt;&gt; iFactor))\n    {\n        cin.clear(); // reset input\n        while (cin.get() != '\\n')\n            continue; // get rid of bad input\n        cout &lt;&lt; \"Please enter a number: \";\n    }\n\n    dFactorial = fnFactorial(iFactor);\n    cout &lt;&lt; \"\\nFactorial: \" &lt;&lt; dFactorial &lt;&lt; endl;\n\n    return 0;\n}\n\ndouble fnFactorial(int iFactor){\n    if(iFactor - 1 &gt; 0)\n        return iFactor * fnFactorial(--iFactor);\n    return 1;\n}\n</code></pre> <p>6 - Write a program that uses the following functions:</p> <p><code>Fill_array()</code> takes as arguments the name of an array of double values and an array size. It prompts the user to enter double values to be entered in the array. It ceases taking input when the array is full or when the user enters non-numeric input, and it returns the actual number of entries.</p> <p><code>Show_array()</code> takes as arguments the name of an array of double values and an array size and displays the contents of the array.</p> <p><code>Reverse_array()</code> takes as arguments the name of an array of double values and an array size and reverses the order of the values stored in the array. The program should use these functions to fill an array, show the array, reverse the array, show the array, reverse all but the first and last elements of the array, and then show the array.</p> Code <pre><code>#include &lt;iostream&gt;\n\nint Fill_array(double *arr, int arrSize);\nvoid Show_array(double *arr, int arrSize);\nvoid Reverse_array(double *arr, int arrSize);\n\nint main(){\n    int iArrSize {10};\n    double *dArray = new double[iArrSize];\n\n    iArrSize = Fill_array(dArray, iArrSize);\n\n    std::cout &lt;&lt; \"\\n\" &lt;&lt; iArrSize &lt;&lt; \"\\n\";\n    Show_array(dArray, iArrSize);\n\n    Reverse_array(dArray, iArrSize);\n    Show_array(dArray, iArrSize);\n\n    Reverse_array(dArray + 1, iArrSize - 2);\n    Show_array(dArray, iArrSize);\n}\n\nint Fill_array(double *arr, int arrSize){\n    int i {};\n\n    std::cout &lt;&lt; \"\\nEnter value of: \\n\";\n    while(i &lt; arrSize)\n    {\n        std::cout &lt;&lt; \"#\" &lt;&lt; i + 1 &lt;&lt; \" element: \";\n        // arr[i] = i; // Autofill : ) \n        while (!(std::cin &gt;&gt; arr[i]))\n        {\n            std::cout &lt;&lt; \"Not a number. Breaking function!\";\n            std::cin.clear();\n            while(std::cin.get() != '\\n')\n                continue;\n            return i;\n        }\n        ++i;\n    }\n\n    return i;\n}\n\nvoid Show_array(double *arr, int arrSize){\n    std::cout &lt;&lt; std::endl;\n    for (int i {0}; i &lt; arrSize; ++i)\n        std::cout &lt;&lt; arr[i] &lt;&lt; \", \";\n}\n\nvoid Reverse_array(double *arr, int arrSize){\n    for (int i {}, j {arrSize - 1}; i &lt; arrSize / 2; ++i, --j)\n    {\n        double temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }    \n}\n</code></pre> <p>7 - Redo Listing 7.7 (arrfun3), modifying the three array-handling functions to each use two pointer parameters to represent a range. The <code>fill_array()</code> function, instead of returning the actual number of items read, should return a pointer to the location after the last location filled; the other functions can use this pointer as the second argument to identify the end of the data.</p> Code <pre><code>// arrfun3.cpp -- array functions and const\n#include &lt;iostream&gt;\nconst int Max = 5;\n\n// function prototypes\ndouble * fill_array(double ar[], const int *limit);\nvoid show_array(const double ar[], double *n); // don't change data\nvoid revalue(double r, double ar[], double *n);\n\nint main()\n{\n    using namespace std;\n    double properties[Max];\n    double *size = fill_array(properties, &amp;Max);\n    show_array(properties, size);\n    if (*size &gt; 0)\n    {\n        cout &lt;&lt; \"Enter revaluation factor: \";\n        double factor;\n        while (!(cin &gt;&gt; factor)) // bad input\n        {\n            cin.clear();\n            while (cin.get() != '\\n')\n                continue;\n            cout &lt;&lt; \"Bad input; Please enter a number: \";\n        }\n        revalue(factor, properties, size);\n        show_array(properties, size);\n    }\n    cout &lt;&lt; \"Done.\\n\";\n    cin.get();\n    cin.get();\n    return 0;\n}\n\ndouble * fill_array(double ar[], const int *limit)\n{\n    using namespace std;\n    double temp;\n    int i;\n    for (i = 0; i &lt; *limit; i++)\n    {\n        cout &lt;&lt; \"Enter value #\" &lt;&lt; (i + 1) &lt;&lt; \": \";\n        cin &gt;&gt; temp;\n        if (!cin) // bad input\n        {\n            cin.clear();\n            while (cin.get() != '\\n')\n                continue;\n            cout &lt;&lt; \"Bad input; input process terminated.\\n\";\n            break;\n        }\n        else if (temp &lt; 0) // signal to terminate\n            break;\n        ar[i] = temp;\n    }\n    return &amp;ar[i];\n}\n// the following function can use, but not alter,\n// the array whose address is ar\nvoid show_array(const double ar[], double *n)\n{\n    using namespace std;\n    for (int i = 0; ar[i] != *n; i++)\n    {\n        cout &lt;&lt; \"Property #\" &lt;&lt; (i + 1) &lt;&lt; \": $\";\n        cout &lt;&lt; ar[i] &lt;&lt; endl;\n    }\n}\n\n// multiplies each element of ar[] by r\nvoid revalue(double r, double ar[], double *n)\n{\n    for (int i = 0; ar[i] != *n; i++)\n        ar[i] *= r;\n}\n</code></pre> <p>8 - Redo Listing 7.15 (arrobj) without using the array class. Do two versions:</p> <p>a. Use an ordinary array of <code>const char *</code> for the strings representing the season names, and use an ordinary array of double for the expenses.</p> <p>b. Use an ordinary array of <code>const char *</code> for the strings representing the season names, and use a structure whose sole member is an ordinary array of double for the expenses. (This design is similar to the basic design of the array class.)</p> Code <pre><code>/// A version /// -----------\n/*\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n// constant data\nconst int Seasons = 4;\nconst char Snames[Seasons][10] =\n    {\"Spring\", \"Summer\", \"Fall\", \"Winter\"};\n\n// function to modify array object\nvoid fill(double t.expenses[],const int Seasons);\n// function that uses array object without modifying it\nvoid show(double t.expenses[],const int Seasons);\n\nint main()\n{\n    double expenses[Seasons]{};\n    fill(expenses, Seasons);\n    show(expenses, Seasons);\n    return 0;\n}\n\nvoid fill(double t.expenses[],const int Seasons)\n{\n    using namespace std;\n    for (int i = 0; i &lt; Seasons; i++)\n    {\n        cout &lt;&lt; \"Enter \" &lt;&lt; Snames[i] &lt;&lt; \" expenses: \";\n        cin &gt;&gt; t.expenses[i];\n    }\n}\n\nvoid show(double t.expenses[],const int Seasons)\n{\n    using namespace std;\n    double total = 0.0;\n    cout &lt;&lt; \"\\nEXPENSES\\n\";\n    for (int i = 0; i &lt; Seasons; i++)\n    {\n        cout &lt;&lt; Snames[i] &lt;&lt; \": $\" &lt;&lt; t.expenses[i] &lt;&lt; endl;\n        total += t.expenses[i];\n    }\n    cout &lt;&lt; \"Total Expenses: $\" &lt;&lt; total &lt;&lt; endl;\n}\n*/\n\n/// B version /// -----------\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n// constant data\nconst int Seasons = 4;\nconst char Snames[Seasons][10] =\n    {\"Spring\", \"Summer\", \"Fall\", \"Winter\"};\n\nstruct sAll{\n    double expenses[Seasons]{};\n};\n\n// function to modify array object\nvoid fill(sAll *t,const int Seasons);\n// function that uses array object without modifying it\nvoid show(sAll *t,const int Seasons);\n\nint main()\n{\n    sAll exp;\n    fill(&amp;exp, Seasons);\n    show(&amp;exp, Seasons);\n    return 0;\n}\n\nvoid fill(sAll *t,const int Seasons)\n{\n    using namespace std;\n    for (int i = 0; i &lt; Seasons; i++)\n    {\n        cout &lt;&lt; \"Enter \" &lt;&lt; Snames[i] &lt;&lt; \" expenses: \";\n        cin &gt;&gt; t-&gt;expenses[i];\n    }\n}\n\nvoid show(sAll *t,const int Seasons)\n{\n    using namespace std;\n    double total = 0.0;\n    cout &lt;&lt; \"\\nEXPENSES\\n\";\n    for (int i = 0; i &lt; Seasons; i++)\n    {\n        cout &lt;&lt; Snames[i] &lt;&lt; \": $\" &lt;&lt; t-&gt;expenses[i] &lt;&lt; endl;\n        total += t-&gt;expenses[i];\n    }\n    cout &lt;&lt; \"Total Expenses: $\" &lt;&lt; total &lt;&lt; endl;\n}\n\n\n/*\nEnter Spring expenses: 212\nEnter Summer expenses: 256\nEnter Fall expenses: 208\nEnter Winter expenses: 244\n\nEXPENSES\nSpring: $212\nSummer: $256\nFall: $208\nWinter: $244\nTotal: $920\n*/\n</code></pre> <p>9 - This exercise provides practice in writing functions dealing with arrays and structures. The following is a program skeleton. Complete it by providing the described functions:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nconst int SLEN = 30;\n\nstruct student\n{\n    char fullname[SLEN];\n    char hobby[SLEN];\n    int ooplevel;\n};\n\n// getinfo() has two arguments: a pointer to the first element of\n// an array of student structures and an int representing the\n// number of elements of the array. The function solicits and\n// stores data about students. It terminates input upon filling\n// the array or upon encountering a blank line for the student\n// name. The function returns the actual number of array elements\n// filled.\nint getinfo(student pa[], int n);\n\n// display1() takes a student structure as an argument\n// and displays its contents\nvoid display1(student st);\n\n// display2() takes the address of student structure as an\n// argument and displays the structure\u2019s contents\nvoid display2(const student *ps);\n\n// display3() takes the address of the first element of an array\n// of student structures and the number of array elements as\n// arguments and displays the contents of the structures\nvoid display3(const student pa[], int n);\n\nint main()\n{\n    cout &lt;&lt; \"Enter class size : \";\n    int class_size;\n    cin &gt;&gt; class_size;\n    while (cin.get() != '\\n')\n        continue;\n\n    student *ptr_stu = new student[class_size];\n    int entered = getinfo(ptr_stu, class_size);\n    for (int i = 0; i &lt; entered; i++)\n    {\n        display1(ptr_stu[i]);\n        display2(&amp;ptr_stu[i]);\n    }\n    display3(ptr_stu, entered);\n    delete[] ptr_stu;\n    cout &lt;&lt; \"Done\\n\";\n    return 0;\n}\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nconst int SLEN = 30;\n\nstruct student\n{\n    char fullname[SLEN];\n    char hobby[SLEN];\n    int ooplevel;\n};\n\n// getinfo() has two arguments: a pointer to the first element of\n// an array of student structures and an int representing the\n// number of elements of the array. The function solicits and\n// stores data about students. It terminates input upon filling\n// the array or upon encountering a blank line for the student\n// name. The function returns the actual number of array elements\n// filled.\nint getinfo(student pa[], int n);\n\n// display1() takes a student structure as an argument\n// and displays its contents\nvoid display1(student st);\n\n// display2() takes the address of student structure as an\n// argument and displays the structure\u2019s contents\nvoid display2(const student *ps);\n\n// display3() takes the address of the first element of an array\n// of student structures and the number of array elements as\n// arguments and displays the contents of the structures\nvoid display3(const student pa[], int n);\n\nint main()\n{\n    cout &lt;&lt; \"Enter class size : \";\n    int class_size;\n    cin &gt;&gt; class_size;\n    while (cin.get() != '\\n')\n        continue;\n\n    student *ptr_stu = new student[class_size];\n    int entered = getinfo(ptr_stu, class_size);\n\n    cout &lt;&lt; \"Sadf sadf \" &lt;&lt; entered &lt;&lt; endl;\n\n    for (int i = 0; i &lt; entered; i++)\n    {\n        display1(ptr_stu[i]);\n        display2(&amp;ptr_stu[i]);\n    }\n    display3(ptr_stu, entered);\n    delete[] ptr_stu;\n    cout &lt;&lt; \"Done\\n\";\n    return 0;\n}\n\nint getinfo(student pa[], int n)\n{\n    int i{};\n\n    do\n    {\n        cout &lt;&lt; \"\\nEnter the name of \" &lt;&lt; i + 1 &lt;&lt; \" student: \";\n        while (!(cin.get(pa[i].fullname, SLEN))) // the only function that reads an empty line and sets failbit\n            return i;\n\n        cout &lt;&lt; \"Enter the hobby of \" &lt;&lt; i + 1 &lt;&lt; \" student: \";\n        cin.get();\n        while (!(cin.get(pa[i].hobby, SLEN)))\n        {\n            cin.clear();\n            while (cin.get() != '\\n')\n                break;\n            break;\n        }\n\n        cout &lt;&lt; \"Enter the oop level of \" &lt;&lt; i + 1 &lt;&lt; \" student: \";\n        while (!(cin &gt;&gt; pa[i].ooplevel))\n        {\n            cin.clear();\n            while (cin.get() != '\\n')\n                continue;\n            cout &lt;&lt; \"Bad input; Please enter a number: \";\n        }\n\n        // read newlines (in other case you will only read one line,\n        // the rest will fill from buffer - chapter 6: Review, 9)\n        while (cin.get() != '\\n')\n            continue;\n\n    } while (++i &lt; n);\n\n    return i;\n}\n\nvoid display1(student st)\n{\n    cout &lt;&lt; \"\\n\\t&lt;display1&gt;\";\n    cout &lt;&lt; \"\\nName: \" &lt;&lt; st.fullname;\n    cout &lt;&lt; \"\\nHobby: \" &lt;&lt; st.hobby;\n    cout &lt;&lt; \"\\nOOP level: \" &lt;&lt; st.ooplevel &lt;&lt; endl;\n}\n\nvoid display2(const student *ps)\n{\n    cout &lt;&lt; \"\\n\\t&lt;display2&gt;\";\n    cout &lt;&lt; \"\\nName: \" &lt;&lt; ps-&gt;fullname;\n    cout &lt;&lt; \"\\nHobby: \" &lt;&lt; ps-&gt;hobby;\n    cout &lt;&lt; \"\\nOOP level: \" &lt;&lt; ps-&gt;ooplevel &lt;&lt; endl;\n}\n\nvoid display3(const student pa[], int n)\n{\n    cout &lt;&lt; \"\\n\\t&lt;display3&gt;\";\n    for (int i{}; i &lt; n; ++i)\n    {\n        cout &lt;&lt; \"\\nName: \" &lt;&lt; (pa + i)-&gt;fullname;\n        cout &lt;&lt; \"\\nHobby: \" &lt;&lt; (pa + i)-&gt;hobby;\n        cout &lt;&lt; \"\\nOOP level: \" &lt;&lt; (pa + i)-&gt;ooplevel &lt;&lt; endl;\n    }\n}\n</code></pre> <p>10 - Design a function <code>calculate()</code> that takes two type <code>double</code> values and a pointer to a function that takes two <code>double</code> arguments and returns a double.The <code>calculate()</code> function should also be type double, and it should return the value that the pointed-to function calculates, using the double arguments to <code>calculate()</code>. For example, suppose you have this definition for the <code>add()</code> function:</p> <pre><code>double add(double x, double y)\n{\n    return x + y;\n}\n</code></pre> <p>Then, the function call in the following would cause <code>calculate()</code> to pass the values 2.5 and 10.4 to the <code>add()</code> function and then return the <code>add()</code> return value (12.9):</p> <pre><code>double q = calculate(2.5, 10.4, add);\n</code></pre> <p>Use these functions and at least one additional function in the <code>add()</code> mold in a program.The program should use a loop that allows the user to enter pairs of numbers. For each pair, use <code>calculate()</code> to invoke <code>add()</code> and at least one other function. If you are feeling adventurous, try creating an array of pointers to add()-style functions and use a loop to successively apply <code>calculate()</code> to a series of functions by using these pointers. Hint: Here\u2019s how to declare such an array of three pointers:</p> <pre><code>double (*pf[3])(double, double);\n</code></pre> <p>You can initialize such an array by using the usual array initialization syntax and function names as addresses.</p> Code <pre><code>#include &lt;iostream&gt;\n\ndouble add(double, double);\ndouble calculate(double, double, double (*add)(double, double));\n\nint main()\n{\n    double a{};\n    double b{};\n\n    /// A version /// -----------\n    /*\n    std::cout &lt;&lt; \"\\nAdd pairs of numbers.\\nEnter 2 numbers after space, q to quit:\\n\";\n\n    while (std::cin &gt;&gt; a &gt;&gt; b)\n    {\n        if (!std::cin)\n            break;\n\n        std::cout &lt;&lt; \"\\nAdded: \" &lt;&lt; a &lt;&lt; \" + \" &lt;&lt; b\n                  &lt;&lt; \" = \" &lt;&lt; calculate(a, b, add);\n\n        std::cout &lt;&lt; \"\\n\\nEnter 2 new numbers: \";\n\n        // Clear buffer if more numbers than 2\n        std::cin.clear();\n        while (std::cin.get() != '\\n')\n            continue;\n    }\n    std::cout &lt;&lt; \"\\n\\tBye Bye!\";\n    */\n\n    /// B version /// -----------:\n    // // try creating an array of pointers to add()-style\n    // // functions and use a loop to successively apply calculate() to a series of functions\n    // // by using these pointers.\n    double (*pf[3])(double, double){add, add, add};\n    std::cout &lt;&lt; \"\\nAdd pairs of numbers.\\nEnter 2 numbers after space, q to quit:\\n\";\n\n    while (std::cin &gt;&gt; a &gt;&gt; b)\n    {\n        if (!std::cin)\n            break;\n\n        double temp1 = calculate(a, b, pf[0]);\n        double temp2 = calculate(temp1, a, pf[1]);\n        double temp3 = calculate(temp2, temp1, pf[2]);\n\n        std::cout &lt;&lt; \"\\nAdded: \" &lt;&lt; a &lt;&lt; \" + \" &lt;&lt; b\n                  &lt;&lt; \" = \" &lt;&lt; temp1;\n\n        std::cout &lt;&lt; \"\\nAdded: \" &lt;&lt; temp1 &lt;&lt; \" + \" &lt;&lt; a\n                  &lt;&lt; \" = \" &lt;&lt; temp2;\n\n        std::cout &lt;&lt; \"\\nAdded: \" &lt;&lt; temp2 &lt;&lt; \" + \" &lt;&lt; temp1\n                  &lt;&lt; \" = \" &lt;&lt; temp3;\n\n        std::cout &lt;&lt; \"\\n\\nEnter 2 new numbers: \";\n\n        // Clear buffer if more numbers than 2\n        std::cin.clear();\n        while (std::cin.get() != '\\n')\n            continue;\n    }\n    std::cout &lt;&lt; \"\\n\\tBye Bye!\";\n}\n\ndouble add(double x, double y)\n{\n    return x + y;\n}\n\ndouble calculate(double a, double b, double (*add)(double, double))\n{\n    return add(a, b);\n}\n</code></pre>"},{"location":"exercises/#chapter-8","title":"Chapter 8","text":"<p>1 - Write a function that normally takes one argument, the address of a string, and prints that string once. However, if a second, type int, argument is provided and is nonzero, the function should print the string a number of times equal to the number of times that function has been called at that point. (Note that the number of times the string is printed is not equal to the value of the second argument; it is equal to the number of times the function has been called.) Yes, this is a silly function, but it makes you use some of the techniques discussed in this chapter. Use the function in a simple program that demonstrates how the function works.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nstatic int iNum{};\n\nvoid fnFun(string *cStr, int iPrint = 1);\nvoid fnFun(char *cStr, int iPrint = 1);\n\nint main()\n{\n    char *cSthChar = new char[50];\n    string *cSthString = new string;\n\n    int iSth{};\n    char cChoice{};\n\n    cout &lt;&lt; \"\\nWrite words to call finction and print it\";\n    cout &lt;&lt; \"\\nthe number of times function was called\";\n    cout &lt;&lt; \"\\nWrite 'done' to quit\";\n\n    cout &lt;&lt; \"\\nType: A - use *std::string, B - use *char[]: \";\n\n    cin &gt;&gt; cChoice;\n    switch (cChoice)\n    {\n    case 'A':\n        do\n        {\n            cout &lt;&lt; \"\\nWrite words: \";\n            cin.getline(cSthChar, 50);\n\n            cout &lt;&lt; \"\\nEnter nonzero number to print words: \";\n            while (!(cin &gt;&gt; iSth))\n            {\n                std::cout &lt;&lt; \"Not a number. Try again: \";\n                std::cin.clear();\n                while (std::cin.get() != '\\n')\n                    continue;\n            }\n\n            fnFun(cSthChar, iSth);\n\n            cin.get();\n        } while (strcmp(cSthChar, \"done\"));\n\n        delete[] cSthChar;\n        break;\n\n    case 'B':\n        do\n        {\n            cout &lt;&lt; \"\\nWrite words: \";\n            getline(cin, *cSthString);\n\n            cout &lt;&lt; \"\\nEnter nonzero number to print words: \";\n            while (!(cin &gt;&gt; iSth))\n            {\n                std::cout &lt;&lt; \"Not a number. Try again: \";\n                std::cin.clear();\n                while (std::cin.get() != '\\n')\n                    continue;\n            }\n\n            fnFun(cSthString, iSth);\n\n            cin.get();\n        } while (!(*cSthString == \"done\"));\n\n        delete[] cSthString;\n        break;\n    default:\n        break;\n    }\n\n    return 0;\n}\n\nvoid fnFun(string *cStr, int iPrint)\n{\n    ++iNum;\n\n    if (!iPrint)\n        return;\n\n    for (int i{}; i &lt; iNum; i++)\n        cout &lt;&lt; *cStr &lt;&lt; endl;\n}\n\nvoid fnFun(char *cStr, int iPrint)\n{\n    ++iNum;\n\n    if (!iPrint)\n        return;\n\n    for (int i{}; i &lt; iNum; ++i)\n        cout &lt;&lt; cStr &lt;&lt; endl;\n}\n</code></pre> <p>2 - The <code>CandyBar</code> structure contains three members.The first member holds the brand name of a candy bar.The second member holds the weight (which may have a fractional part) of the candy bar, and the third member holds the number of calories (an integer value) in the candy bar.Write a program that uses a function that takes as arguments a reference to CandyBar, a pointer-to-char, a double, and an <code>int</code> and uses the last three values to set the corresponding members of the structure. The last three arguments should have default values of \u201cMillennium Munch,\u201d 2.85, and 350. Also the program should use a function that takes a reference to a <code>CandyBar</code> as an argument and displays the contents of the structure. Use <code>const</code> where appropriate.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nstruct CandyBar{\n    char name[50];\n    float weight;\n    int calories;\n};\n\nvoid fnFunA(CandyBar &amp;cb, const char *cstr, int num){\n    --num; // 9 letters  \n    cb.name[0] = cstr[num-1]; \n    cb.weight = float(cstr[num-2]) * 0.1;\n    cb.calories = int(cstr[num-3]);\n}\n\nvoid fnFunB(CandyBar const &amp;cb){\n    std::cout &lt;&lt; cb.name &lt;&lt; \", \";\n    std::cout &lt;&lt; cb.weight &lt;&lt; \", \";\n    std::cout &lt;&lt; cb.calories &lt;&lt; std::endl;\n}\n\nint main(){\n    int iNum {10};\n    char cData[iNum] {\"qwertyuiO\"};\n    CandyBar myCandy {\"Millennium Munch\", 2.85, 350};\n\n    std::cout &lt;&lt; \"\\nCurrent data: \\n\";\n    fnFunB(myCandy);\n\n    std::cout &lt;&lt; \"\\n-PROCESS DATA-\\n\";\n    fnFunA(myCandy, cData, iNum);\n\n    std::cout &lt;&lt; \"\\nNew data: \\n\";\n    fnFunB(myCandy);\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>3 - Write a function that takes a reference to a <code>string</code> object as its parameter and that converts the contents of the <code>string</code> to uppercase. Use the <code>toupper()</code> function described in Table 6.4 of Chapter 6.Write a program that uses a loop which allows you to test the function with different input.A sample run might look like this:</p> <pre><code>Enter a string (q to quit): go away\nGO AWAY\nNext string (q to quit): good grief!\nGOOD GRIEF!\nNext string (q to quit): q\nBye.\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;cctype&gt;\n\nvoid fnFunA(std::string &amp;data){\n    int iLet {sizeof(data)/sizeof(data[0])};\n    char temp[iLet];\n\n    for (int i {}; i &lt; iLet; ++i)\n        data[i] = toupper((int)data[i]);\n}\n\nint main(){\n    std::string sData;\n\n    std::cout &lt;&lt; \"\\nEnter a string (q to quit): \";\n    while (std::getline(std::cin, sData))\n    {\n        if (sData == \"q\")\n            break;\n\n        fnFunA(sData);\n\n        std::cout &lt;&lt; sData &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"Next string (q to quit): \";\n    }\n\n    return 0;\n}\n</code></pre> <p>4 - The following is a program skeleton:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n#include &lt;cstring&gt; // for strlen(), strcpy()\nstruct stringy\n{\n    char *str; // points to a string\n    int ct;    // length of string (not counting '\\0')\n};\n// prototypes for set(), show(), and show() go here\nint main()\n{\n    stringy beany;\n    char testing[] = \"Reality isn't what it used to be.\";\n    set(beany, testing); // first argument is a reference,\n    // allocates space to hold copy of testing,\n    // sets str member of beany to point to the\n    // new block, copies testing to new block,\n    // and sets ct member of beany\n    show(beany);    // prints member string once\n    show(beany, 2); // prints member string twice\n    testing[0] = 'D';\n    testing[1] = 'u';\n    show(testing);    // prints testing string once\n    show(testing, 3); // prints testing string thrice\n    show(\"Done!\");\n    return 0;\n}\n</code></pre> <p>Complete this skeleton by providing the described functions and prototypes. Note that there should be two <code>show()</code> functions, each using default arguments. Use <code>const</code> arguments when appropriate. Note that <code>set()</code> should use <code>new</code> to allocate sufficient space to hold the designated string.The techniques used here are similar to those used in designing and implementing classes. (You might have to alter the header filenames and delete the <code>using</code> directive, depending on your compiler.)</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt; // for strlen(), strcpy()\n\nusing namespace std;\n\nstruct stringy\n{\n    char *str; // points to a string\n    int ct;    // length of string (not counting '\\0')\n};\n\n// prototypes for set(), show(), and show() go here\nvoid show(stringy const &amp;sStringy, int iNum = 1);\nvoid show(const char *cWord, int iNum = 1);\nvoid set(stringy &amp;sStringy, const char *cString);\n\nint main()\n{\n    stringy beany;\n    char testing[] = \"Reality isn't what it used to be.\";\n\n    set(beany, testing); // first argument is a reference,\n    // allocates space to hold copy of testing,\n    // sets str member of beany to point to the\n    // new block, copies testing to new block,\n    // and sets ct member of beany\n\n    show(beany);    // prints member string once\n    show(beany, 2); // prints member string twice\n\n    testing[0] = 'D';\n    testing[1] = 'u';\n\n    show(testing);    // prints testing string once\n    show(testing, 3); // prints testing string thrice\n    show(\"Done!\");\n\n    return 0;\n}\n\nvoid set(stringy &amp;sStringy, const char *cString){\n    const int iLength = strlen(cString);\n    static char * cTemp = new char[iLength + 1];\n\n    strcpy(cTemp, cString);\n\n    sStringy.str = cTemp;\n    sStringy.ct = iLength;\n\n    // cout &lt;&lt; endl &lt;&lt; \"sStringy str :\" &lt;&lt; sStringy.str &lt;&lt; \", in memory: \" &lt;&lt; &amp;sStringy.str;\n    // cout &lt;&lt; endl &lt;&lt; \"cString :\" &lt;&lt; cString &lt;&lt; \", in memory: \" &lt;&lt; &amp;cString;\n    // cout &lt;&lt; endl &lt;&lt; \"cTemp :\" &lt;&lt; cTemp &lt;&lt; \", in memory: \" &lt;&lt; &amp;cTemp;\n}\n\nvoid show(stringy const &amp;sStringy, int iNum){\n    for (int i {}; i &lt; iNum; ++i)\n        cout &lt;&lt; endl &lt;&lt; sStringy.str;\n}\n\nvoid show(const char *cWord, int iNum){\n    for (int i {}; i &lt; iNum; ++i)\n        cout &lt;&lt; endl &lt;&lt; cWord;\n} \n</code></pre> <p>5 - Write a template function <code>max5()</code> that takes as its argument an array of five items of type <code>T</code> and returns the largest item in the array. (Because the size is fixed, it can be hard-coded into the loop instead of being passed as an argument.) Test it in a program that uses the function with an array of five int value and an array of five double values.</p> Code <pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nT max5(T tVal[5]);\n\nint main()\n{\n    int iTestVal[5] {9,3,6,8,4};\n    double dTestVal[5] {9.35, 9.424, 9.383, 9.123, 9.13};\n    double dOutput {};\n\n    std::cout &lt;&lt; \"\\n int test: \\n\";\n    dOutput = max5(iTestVal);\n    std::cout &lt;&lt; dOutput &lt;&lt; \", and fun : \" &lt;&lt; max5(iTestVal) &lt;&lt; std::endl;\n\n\n    std::cout &lt;&lt; \"\\n double test: \\n\";\n    dOutput = max5(dTestVal);\n    std::cout &lt;&lt; dOutput &lt;&lt; \", and fun : \" &lt;&lt; max5(dTestVal) &lt;&lt; std::endl ;\n\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n\ntemplate&lt;typename T&gt;\nT max5(T tVal[5]) \n{\n    T tMax {tVal[0]};\n\n    for (int i {1}; i &lt; 5; i++)\n        if (tMax &lt; tVal[i])\n            tMax = tVal[i];\n\n    return tMax;\n}\n</code></pre> <p>6 - Write a template function <code>maxn()</code> that takes as its arguments an array of items of type T and an integer representing the number of elements in the array and that returns the largest item in the array.Test it in a program that uses the function template with an array of six int value and an array of four double values.The program should also include a specialization that takes an array of pointers-to-char as an argument and the number of pointers as a second argument and that returns the address of the longest string. If multiple strings are tied for having the longest length, the function should return the address of the first one tied for longest.Test the specialization with an array of five string pointers.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\ntemplate &lt;typename T&gt;\nT maxn(T tVal[], int iNumEl);\n\ntemplate &lt;&gt; const char *maxn(const char *cArr[], int iNumPtr);\n\nint main()\n{\n    int iVals[6] {123, 234, 564, 34, 535, 543};\n    double dVals[4] {1.23, 2.34, 5.64, 3.4};\n    const char *cVals[6] {\"fdsffds\", \"lubie placki\", \"was is das\", \"i like pancakes\", \"ni hao\", \"arigato\"};\n\n    std::cout &lt;&lt; \"\\n int test: \\n\";\n    std::cout &lt;&lt; maxn(iVals, 6);\n\n    std::cout &lt;&lt; \"\\n double test: \\n\";\n    std::cout &lt;&lt; maxn(dVals, 4);\n\n    std::cout &lt;&lt; \"\\n c-string test: \\n\";\n    std::cout &lt;&lt; maxn(cVals, 6);\n    std::cout &lt;&lt; std::endl &lt;&lt; \"str2 :\" &lt;&lt; *cVals &lt;&lt; \", in memory: \" &lt;&lt; cVals;\n\n    return 0;\n}\n\ntemplate &lt;typename T&gt;\nT maxn(T tVal[], int iNumEl)\n{\n    T tMax{tVal[0]};\n\n    for (int i{}; i &lt; iNumEl; ++i)\n        if (tMax &lt; tVal[i])\n            tMax = tVal[i];\n\n    return tMax;\n}\n\ntemplate &lt;&gt; const char *maxn(const char *cArr[], int iNumPtr){\n    int iMax = strlen(cArr[0]);\n    int tmp{};\n\n    for (int i{}; i &lt; iNumPtr; ++i){\n        if (iMax &lt; strlen(cArr[i])){\n            iMax = strlen(cArr[i]);\n            tmp = i;\n        }\n    }\n\n    std::cout &lt;&lt; std::endl &lt;&lt; \"str1 :\" &lt;&lt; *cArr &lt;&lt; \", in memory: \" &lt;&lt; cArr &lt;&lt; std::endl;\n    return cArr[tmp];   \n}\n</code></pre> <p>7 - Modify Listing 8.14 (tempover) so that it uses two template functions called <code>SumArray()</code> to return the sum of the array contents instead of displaying the contents.The program now should report the total number of things and the sum of all the debts</p> Code <pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt; // template A\nT SumArray(T arr[], int n);\ntemplate &lt;typename T&gt; // template B\nT SumArray(T *arr[], int n);\n\nstruct debts\n{\n    char name[50];\n    double amount;\n};\n\nint main()\n{\n    using namespace std;\n    int things[6] = {13, 31, 103, 301, 310, 130};\n    struct debts mr_E[3] =\n        {\n            {\"Ima Wolfe\", 2400.0},\n            {\"Ura Foxe\", 1300.0},\n            {\"Iby Stout\", 1800.0}};\n    double *pd[3];\n\n    // set pointers to the amount members of the structures in mr_E\n    for (int i = 0; i &lt; 3; i++)\n        pd[i] = &amp;mr_E[i].amount;\n    cout &lt;&lt; \"Listing Mr. E's counts of things:\\n\";\n    // things is an array of int\n    cout &lt;&lt; SumArray(things, 6) &lt;&lt; endl &lt;&lt; endl; // uses template A\n    cout &lt;&lt; \"Listing Mr. E's debts:\\n\";\n    // pd is an array of pointers to double\n    cout &lt;&lt; SumArray(pd, 3) &lt;&lt; endl &lt;&lt; endl; // uses template B (more specialized)\n    return 0;\n}\n\ntemplate &lt;typename T&gt;\nT SumArray(T arr[], int n)\n{\n    using namespace std;\n    T tSum{};\n\n    cout &lt;&lt; \"template A\\n\";\n    for (int i = 0; i &lt; n; i++)\n        tSum += arr[i];\n\n    return tSum;\n}\n\ntemplate &lt;typename T&gt;\nT SumArray(T *arr[], int n)\n{\n    using namespace std;\n    T tSum{};\n\n    cout &lt;&lt; \"template B\\n\";\n    for (int i = 0; i &lt; n; i++)\n        tSum += *arr[i];\n\n    return tSum;\n}\n</code></pre>"},{"location":"exercises/#chapter-9","title":"Chapter 9","text":"<p>1 - Here is a header file:</p> <pre><code>// golf.h -- for pe9-1.cpp\nconst int Len = 40;\nstruct golf\n{\n    char fullname[Len];\n    int handicap;\n};\n// non-interactive version:\n// function sets golf structure to provided name, handicap\n// using values passed as arguments to the function\nvoid setgolf(golf &amp; g, const char * name, int hc);\n\n// interactive version:\n// function solicits name and handicap from user\n// and sets the members of g to the values entered\n// returns 1 if name is entered, 0 if name is empty string\nint setgolf(golf &amp; g);\n\n// function resets handicap to new value\nvoid handicap(golf &amp; g, int hc);\n\n// function displays contents of golf structure\nvoid showgolf(const golf &amp; g);\n</code></pre> <p>Note that setgolf() is overloaded. Using the first version of setgolf() would look like this:</p> <pre><code>golf ann;\nsetgolf(ann, \"Ann Birdfree\", 24);\n</code></pre> <p>The function call provides the information that\u2019s stored in the ann structure. Using the second version of setgolf() would look like this:</p> <pre><code>golf andy;\nsetgolf(andy);\n</code></pre> <p>The function would prompt the user to enter the name and handicap and store them in the <code>andy</code> structure. This function could (but doesn\u2019t need to) use the first version internally.</p> <p>Put together a multifile program based on this header. One file, named <code>golf.cpp</code>, should provide suitable function definitions to match the prototypes in the header file. A second file should contain <code>main()</code> and demonstrate all the features of the prototyped functions. For example, a loop should solicit input for an array of golf structures and terminate when the array is full or the user enters an empty string for the golfer\u2019s name. The <code>main()</code> function should use only the prototyped functions to access the golf structures.</p> <p>(compile: <code>g++ ch9_1_golf.cpp ch9_1_main.cpp</code>)</p> Code - Prototypes <pre><code>#include &lt;iostream&gt;\n#include \"ch9_1_golf.h\"\n\nvoid setgolf(golf &amp;g, const char *name, int hc)\n{\n    strcpy(g.fullname, name);\n    g.handicap = hc;\n}\n\nint setgolf(golf &amp;g)\n{\n    std::cin.clear(); // reset input\n    while (std::cin.get() != '\\n')\n        continue; // get rid of bad input\n\n    std::cout &lt;&lt; \"\\nEnter the name: \";\n    // std::cin &gt;&gt; g.fullname;\n    std::cin.getline(g.fullname, Len) ;\n\n    std::cout &lt;&lt; \"Enter the handicap: \";\n    // std::cin &gt;&gt; g.handicap;\n    while (!(std::cin &gt;&gt; g.handicap))\n    {\n        std::cin.clear(); // reset input\n        while (std::cin.get() != '\\n')\n            continue; // get rid of bad input\n        std::cout &lt;&lt; \"Please enter a number: \";\n    }\n    // std::cin.get(); // clear the input buffer\n\n    if (g.fullname == \"\")\n    {\n        return 0;\n    }\n    return 1;\n}\n\nvoid handicap(golf &amp;g, int hc)\n{\n    g.handicap = hc;\n}\n\nvoid showgolf(const golf &amp;g)\n{\n    std::cout &lt;&lt; \"\\t\" &lt;&lt; g.fullname &lt;&lt; \"\\t\\t\";\n    std::cout &lt;&lt; g.handicap &lt;&lt; std::endl;\n}\n</code></pre> Code - headers <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nconst int Len = 40;\n\nstruct golf\n{\n    char fullname[Len];\n    int handicap;\n};\n\n// non-interactive version:\n// function sets golf structure to provided name, handicap\n// using values passed as arguments to the function\nvoid setgolf(golf &amp;g, const char *name, int hc);\n\n// interactive version:\n// function solicits name and handicap from user\n// and sets the members of g to the values entered\n// returns 1 if name is entered, 0 if name is empty string\nint setgolf(golf &amp;g);\n\n// function resets handicap to new value\nvoid handicap(golf &amp;g, int hc);\n\n// function displays contents of golf structure\nvoid showgolf(const golf &amp;g);\n</code></pre> Code - Program <pre><code>#include &lt;iostream&gt;\n#include \"ch9_1_golf.h\"\n\nvoid fnPrintMenu()\n{\n    std::cout\n        &lt;&lt; \"\\nPlease select:\\n\"\n        &lt;&lt; \"\\ta) non-interactive version\\tb) interactive version\\n\"\n        &lt;&lt; \"\\tc) print all players\\t\\td) change number of players\\n\"\n        &lt;&lt; \"\\te) quit\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n\n    char strFullname[40];\n    int iHandicap{}, iPlayers{1};\n    char cMenu;\n\n    do\n    {\n        std::cout &lt;&lt; \"\\nEnter the number of players (default is 1, max is 40): \";\n        std::cin &gt;&gt; iPlayers;\n\n        if (iPlayers &gt; 40 || iPlayers &lt; 1)\n        {\n            std::cout &lt;&lt; \"Invalid number of players, try again\\n\";\n        }\n    } while (iPlayers &gt; 40 || iPlayers &lt; 1);\n\n    fnPrintMenu();\n    std::cin &gt;&gt; cMenu;\n\n    // golf *andy = new golf[iPlayers];     // dynamic memory allocation [1/2]\n    golf andy[iPlayers]; // static memory allocation  [1/1]\n\n    while (true)\n    {\n\n        switch (cMenu)\n        {\n        case 'a':\n            for (int i = 0; i &lt; iPlayers; ++i)\n            {\n                // std::cin &gt;&gt; strFullname &gt;&gt; iHandicap;\n                std::cin.clear(); // reset input\n                while (std::cin.get() != '\\n')\n                    continue; // get rid of bad input\n\n                std::cin.getline(strFullname, Len);\n                while (!(std::cin &gt;&gt; iHandicap))\n                {\n                    std::cin.clear(); // reset input\n                    while (std::cin.get() != '\\n')\n                        continue; // get rid of bad input\n                    std::cout &lt;&lt; \"Please enter a number: \";\n                }\n\n                setgolf(andy[i], strFullname, iHandicap);\n            }\n            break;\n        case 'b':\n            for (size_t i = 0; i &lt; iPlayers; ++i)\n            {\n                setgolf(andy[i]);\n            }\n            break;\n        case 'c':\n            std::cout &lt;&lt; \"\\tName \\t\\t\\tHandicap \\n\";\n            std::cout &lt;&lt; \"\\t---------------------------------\\n\";\n            for (int i = 0; i &lt; iPlayers; ++i)\n            {\n                showgolf(andy[i]);\n            }\n            break;\n        case 'd':\n            do\n            {\n                std::cout &lt;&lt; \"\\nEnter the number of players (default is 1, max is 40): \";\n                std::cin &gt;&gt; iPlayers;\n\n                if (iPlayers &gt; 40 || iPlayers &lt; 1)\n                {\n                    std::cout &lt;&lt; \"Invalid number of players, try again\\n\";\n                }\n            } while (iPlayers &gt; 40 || iPlayers &lt; 1);\n            break;\n        case 'e':\n            std::cout &lt;&lt; \"Bye-bye!\\n\";\n            return 0;\n        default:\n            std::cout &lt;&lt; \"Please enter: a, b, c or d: \";\n            break;\n        }\n        fnPrintMenu();\n        std::cin &gt;&gt; cMenu;\n    }\n\n    // delete [] andy;                      // dynamic memory allocation [2/2]\n    return 0;\n}\n</code></pre> <p>2 - Redo Listing 9.9 (<code>static.cpp</code>), replacing the character array with a string object. The program should no longer have to check whether the input string fits, and it can compare the input string to \"\" to check for an empty line.</p> Code <pre><code>// static.cpp -- using a static local variable\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n// constants\nconst int ArSize = 10;\n\n// function prototype\nvoid strcount(std::string *str);\n\nint main()\n{\n    using namespace std;\n    string input;\n    string *ptrInput = &amp;input;\n    string next;\n\n    cout &lt;&lt; \"Enter a line:\\n\";\n\n    while (cin)\n    {\n        getline(cin, input);\n        strcount(ptrInput); // can be also `&amp;input`\n\n        if (input == \"\")\n            break;\n\n        cout &lt;&lt; \"Enter next line (empty line to quit):\\n\";\n    }\n\n    cout &lt;&lt; \"\\n\\n\";\n    strcount(&amp;input);\n\n    cout &lt;&lt; \"Bye\\n\";\n    return 0;\n}\n\nvoid strcount(std::string *str)\n{\n    using namespace std;\n    static int total = 0; // static local variable\n    int count = 0;        // automatic local variable\n\n    cout &lt;&lt; \"\\\"\" &lt;&lt; *str &lt;&lt; \"\\\" contains \";\n    count = str-&gt;length();\n\n    total += count;\n    cout &lt;&lt; count &lt;&lt; \" characters\\n\";\n    cout &lt;&lt; total &lt;&lt; \" characters total\\n\";\n}\n</code></pre> <p>3 - Begin with the following structure declaration:</p> <pre><code>struct chaff\n{\n    char dross[20];\n    int slag;\n};\n</code></pre> <p>Write a program that uses placement new to place an array of two such structures in a buffer. Then assign values to the structure members (remembering to use strcpy() for the char array) and use a loop to display the contents. Option 1 is to use a static array, like that in:</p> Listing 9.10: <p>=== \"newplace.cpp\"     <pre><code>#include &lt;iostream&gt;\n#include &lt;new&gt; // for placement new\n\nconst int BUF = 512;\nconst int N = 5;\nchar buffer[BUF]; // chunk of memory\n\nint main()\n{\n    using namespace std;\n    double *pd1, *pd2;\n    int i;\n    cout &lt;&lt; \"Calling new and placement new:\\n\";\n    pd1 = new double[N];          // use heap\n    pd2 = new (buffer) double[N]; // use buffer array\n    for (i = 0; i &lt; N; i++)\n        pd2[i] = pd1[i] = 1000 + 20.0 * i;\n    cout &lt;&lt; \"Memory addresses:\\n\"\n         &lt;&lt; \" heap: \" &lt;&lt; pd1\n         &lt;&lt; \" static: \" &lt;&lt; (void *)buffer &lt;&lt; endl;\n    cout &lt;&lt; \"Memory contents:\\n\";\n    for (i = 0; i &lt; N; i++)\n    {\n        cout &lt;&lt; pd1[i] &lt;&lt; \" at \" &lt;&lt; &amp;pd1[i] &lt;&lt; \"; \";\n        cout &lt;&lt; pd2[i] &lt;&lt; \" at \" &lt;&lt; &amp;pd2[i] &lt;&lt; endl;\n    }\n\n    cout &lt;&lt; \"\\nCalling new and placement new a second time:\\n\";\n    double *pd3, *pd4;\n    pd3 = new double[N];          // find new address\n    pd4 = new (buffer) double[N]; // overwrite old data\n    for (i = 0; i &lt; N; i++)\n        pd4[i] = pd3[i] = 1000 + 40.0 * i;\n    cout &lt;&lt; \"Memory contents:\\n\";\n    for (i = 0; i &lt; N; i++)\n    {\n        cout &lt;&lt; pd3[i] &lt;&lt; \" at \" &lt;&lt; &amp;pd3[i] &lt;&lt; \"; \";\n        cout &lt;&lt; pd4[i] &lt;&lt; \" at \" &lt;&lt; &amp;pd4[i] &lt;&lt; endl;\n    }\n\n    cout &lt;&lt; \"\\nCalling new and placement new a third time:\\n\";\n    delete[] pd1;\n    pd1 = new double[N];\n    pd2 = new (buffer + N * sizeof(double)) double[N];\n    for (i = 0; i &lt; N; i++)\n        pd2[i] = pd1[i] = 1000 + 60.0 * i;\n    cout &lt;&lt; \"Memory contents:\\n\";\n    for (i = 0; i &lt; N; i++)\n    {\n        cout &lt;&lt; pd1[i] &lt;&lt; \" at \" &lt;&lt; &amp;pd1[i] &lt;&lt; \"; \";\n        cout &lt;&lt; pd2[i] &lt;&lt; \" at \" &lt;&lt; &amp;pd2[i] &lt;&lt; endl;\n    }\n\n    delete[] pd1;\n    delete[] pd3;\n    return 0;\n}\n\n\n/*\nCalling new and placement new:\nMemory addresses:\n    heap: 006E4AB0 static: 00FD9138\nMemory contents:\n1000 at 006E4AB0; 1000 at 00FD9138\n1020 at 006E4AB8; 1020 at 00FD9140\n1040 at 006E4AC0; 1040 at 00FD9148\n1060 at 006E4AC8; 1060 at 00FD9150\n1080 at 006E4AD0; 1080 at 00FD9158\n\nCalling new and placement new a second time:\nMemory contents:\n1000 at 006E4B68; 1000 at 00FD9138\n1040 at 006E4B70; 1040 at 00FD9140\n1080 at 006E4B78; 1080 at 00FD9148\n1120 at 006E4B80; 1120 at 00FD9150\n1160 at 006E4B88; 1160 at 00FD9158\n\nCalling new and placement new a third time:\nMemory contents:\n1000 at 006E4AB0; 1000 at 00FD9160\n1060 at 006E4AB8; 1060 at 00FD9168\n1120 at 006E4AC0; 1120 at 00FD9170\n1180 at 006E4AC8; 1180 at 00FD9178\n1240 at 006E4AD0; 1240 at 00FD9180\n*/\n</code></pre></p> <p>, for the buffer. Option 2 is to use regular new to allocate the buffer.</p> Code <pre><code>#include &lt;iostream&gt;\n\nstruct chaff\n{\n    char dross[20];\n    int slag;\n};\n\nint main(){\n\n    // [1] Static array\n\n    // [2] New keyword\n    chaff *myStr = new chaff[2];\n\n    for (int i = 0; i &lt; 2; ++i)\n    {\n\n        std::cout &lt;&lt; \"\\nEnter new name   for [\" &lt;&lt; i &lt;&lt; \"] dross : \\t\";\n        std::cin.getline(myStr[i].dross, 20);\n\n        std::cout &lt;&lt; \"Enter new number for [\" &lt;&lt; i &lt;&lt; \"] slag  : \\t\";\n        while (!(std::cin &gt;&gt; myStr[i].slag))\n        {\n            std::cin.clear(); // reset input\n            while (std::cin.get() != '\\n')\n                continue; // get rid of bad input\n            std::cout &lt;&lt; \"Please enter a number: \";\n        }\n\n        std::cin.clear(); // reset input\n        while (std::cin.get() != '\\n')\n            continue; // get rid of bad input\n    }\n\n    std::cout &lt;&lt; \"\\n\";\n\n    for (int i = 0; i &lt; 2; ++i)\n    {\n        std::cout &lt;&lt; \"\\nName of [\" &lt;&lt; i &lt;&lt; \"] dross :    \" &lt;&lt; myStr[i].dross;\n        std::cout &lt;&lt; \"; \\t\\t[\"       &lt;&lt; i &lt;&lt; \"] slag  :    \"  &lt;&lt; myStr[i].slag;\n    }\n\n    std::cout &lt;&lt; \"\\n\";\n\n    delete[] myStr;\n\n    return 0;\n}\n\n/*\nWrite a program that uses placement new to place an array of two such structures in\na buffer. Then assign values to the structure members (remembering to use\nstrcpy() for the char array) and use a loop to display the contents. Option 1 is to\nuse a static array, like that in Listing 9.10, for the buffer. Option 2 is to use regular\nnew to allocate the buffer.\n*/\n</code></pre> <p>4- Write a three-file program based on the following namespace:</p> <pre><code>namespace SALES\n{\n    const int QUARTERS = 4;\n    struct Sales\n    {\n        double sales[QUARTERS];\n        double average;\n        double max;\n        double min;\n    };\n    // copies the lesser of 4 or n items from the array ar\n    // to the sales member of s and computes and stores the\n    // average, maximum, and minimum values of the entered items;\n    // remaining elements of sales, if any, set to 0\n    void setSales(Sales &amp; s, const double ar[], int n);\n    // gathers sales for 4 quarters interactively, stores them\n    // in the sales member of s and computes and stores the\n    // average, maximum, and minimum values\n    void setSales(Sales &amp; s);\n    // display all information in structure s\n    void showSales(const Sales &amp; s);\n}\n</code></pre> <p>The first file should be a header file that contains the namespace.The second file should be a source code file that extends the namespace to provide definitions for the three prototyped functions. The third file should declare two Sales objects. It should use the interactive version of setSales() to provide values for one structure and the non-interactive version of setSales() to provide values for the second structure. It should display the contents of both structures by using showSales().</p> Code - Prototypes <pre><code>#include &lt;iostream&gt;\n#include \"ch9_4_sales.h\"\n\n// copies the lesser of 4 or n items from the array ar\n// to the sales member of s and computes and stores the\n// average, maximum, and minimum values of the entered items;\n// remaining elements of sales, if any, set to 0\nvoid SALES::setSales(Sales &amp;s, const double ar[], int n)\n{\n    if (n &gt; QUARTERS)\n        return;\n\n    s.average = 0;\n    s.min = ar[0];\n    s.max = ar[0];\n    for (int i = 0; i &lt; n; ++i)\n    {\n        if (i &lt; (n - 1))\n        {\n            if (s.min &gt; ar[i + 1])\n                s.min = ar[i + 1];\n\n            if (s.max &lt; ar[i + 1])\n                s.max = ar[i + 1];\n        }\n\n        s.sales[i] += ar[i];\n        s.average += ar[i];\n    }\n\n    s.average /= n;\n}\n// gathers sales for 4 quarters interactively, stores them\n// in the sales member of s and computes and stores the\n// average, maximum, and minimum values\nvoid SALES::setSales(Sales &amp;s)\n{\n    s.average = 0;\n    s.min = 0;\n    s.max = 0;\n\n    std::cout &lt;&lt; \"\\nSet sales for quarters: \";\n    for (int i = 0; i &lt; QUARTERS; ++i)\n    {\n        std::cout &lt;&lt; \"\\n-&gt; sale \" &lt;&lt; i &lt;&lt; \" : \";\n        while (!(std::cin &gt;&gt; s.sales[i]))\n        {\n            std::cin.clear(); // reset input\n            while (std::cin.get() != '\\n')\n                continue; // get rid of bad input\n            std::cout &lt;&lt; \"Please enter a number: \";\n        }\n    }\n\n    s.min = s.sales[0];\n    for (int i = 0; i &lt; QUARTERS; ++i)\n    {\n        if (i &lt; (QUARTERS - 1))\n        {\n            if (s.min &gt; s.sales[i + 1])\n                s.min = s.sales[i + 1];\n\n            if (s.max &lt; s.sales[i + 1])\n                s.max = s.sales[i + 1];\n        }\n        s.average += s.sales[i];\n    }\n\n    s.average /= QUARTERS;\n}\n// display all information in structure s\nvoid SALES::showSales(const Sales &amp;s)\n{\n    std::cout &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"\\t Average: \\t\" &lt;&lt; s.average;\n    std::cout &lt;&lt; \"\\t Max:     \\t\" &lt;&lt; s.max;\n    std::cout &lt;&lt; \"\\t Min:     \\t\" &lt;&lt; s.min &lt;&lt; \"\\n\";\n\n    for (int i = 0; i &lt; QUARTERS; i++)\n        std::cout &lt;&lt; \"\\t Sale [\" &lt;&lt; i &lt;&lt; \"] : \\t\" &lt;&lt; s.sales[i];\n}\n</code></pre> Code - headers <pre><code>#include &lt;iostream&gt;\n\nnamespace SALES\n{\n    const int QUARTERS = 4;\n    struct Sales\n    {\n        double sales[QUARTERS];\n        double average;\n        double max;\n        double min;\n    };\n\n    // copies the lesser of 4 or n items from the array ar\n    // to the sales member of s and computes and stores the\n    // average, maximum, and minimum values of the entered items;\n    // remaining elements of sales, if any, set to 0\n    void setSales(Sales &amp;s, const double ar[], int n);\n\n    // gathers sales for 4 quarters interactively, stores them\n    // in the sales member of s and computes and stores the\n    // average, maximum, and minimum values\n    void setSales(Sales &amp;s);\n\n    // display all information in structure s\n    void showSales(const Sales &amp;s);\n}\n</code></pre> Code - Program <pre><code>#include &lt;iostream&gt;\n#include \"ch9_4_sales.h\"\n\nusing namespace SALES;\n\n\nvoid fnPrintMenu()\n{\n    std::cout\n        &lt;&lt; \"\\nPlease select:\\n\"\n        &lt;&lt; \"\\ta) non-interactive version\\tb) interactive version\\n\"\n        &lt;&lt; \"\\tc) print all sales\"\n        &lt;&lt; \"\\t\\td) quit\" &lt;&lt; std::endl;\n}\n\n\nint main(){\n    char cMenu;\n    Sales *mySales = new Sales[2];\n\n    fnPrintMenu();\n    std::cin &gt;&gt; cMenu;\n\n    while (true)\n    {\n        switch (cMenu)\n        {\n        case 'a':\n            double temp[QUARTERS];\n            for (int i = 0; i &lt; QUARTERS; ++i)\n            {\n                while (!(std::cin &gt;&gt; temp[i]))\n                {\n                    std::cin.clear(); // reset input\n                    while (std::cin.get() != '\\n')\n                        continue; // get rid of bad input\n                    std::cout &lt;&lt; \"Please enter a number: \";\n                }\n            }\n            setSales(mySales[0], temp, QUARTERS);\n            break;\n        case 'b':\n            setSales(mySales[1]);\n            break;\n        case 'c':\n            for (int i = 0; i &lt; 2; ++i)\n                showSales(mySales[i]);\n            break;\n        case 'd':\n        //     break;\n        // case 'e':\n            std::cout &lt;&lt; \"Bye-bye!\\n\";\n            return 0;\n        default:\n            std::cout &lt;&lt; \"Please enter: a, b, c or e: \";\n            break;\n        }\n\n        fnPrintMenu();\n        std::cin &gt;&gt; cMenu;\n    }\n\n    delete[] mySales;\n\n    return 0;\n}\n\n/*\nThe first file should be a header file that contains the namespace.The second file\nshould be a source code file that extends the namespace to provide definitions for\nthe three prototyped functions. The third file should declare two Sales objects. It\nshould use the interactive version of setSales() to provide values for one structure\nand the non-interactive version of setSales() to provide values for the second\nstructure. It should display the contents of both structures by using\nshowSales().\n*/\n</code></pre>"},{"location":"exercises/#chapter-10","title":"Chapter 10","text":"<p>1 - Provide method definitions for the class described in Chapter Review Question 5 and write a short program that illustrates all the features.</p> Code - Prototypes <pre><code>#ifndef BANK_H_\n#define BANK_H_\n\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nclass BankAccount\n{\nprivate:\n    std::string name;    // or std::string name;\n    std::string acctnum; // or std::string acctnum;\n    double balance;\n\npublic:\n    BankAccount(const std::string &amp;client, const std::string &amp;num, double bal = 0.0);\n    void show(void) const;\n    void deposit(double cash);\n    void withdraw(double cash);\n};\n#endif\n</code></pre> Code - Methods <pre><code>#include \"ch10_1.h\"\n\nBankAccount::BankAccount(const std::string &amp;client, const std::string &amp;num, double bal)\n{\n    name = client;\n    acctnum = num;\n    balance = bal;\n}\n\nvoid BankAccount::show(void) const\n{\n    std::cout &lt;&lt; \"Name:           \\t\" &lt;&lt; name &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Account number: \\t\" &lt;&lt; acctnum &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Balance:        \\t\" &lt;&lt; balance &lt;&lt; std::endl &lt;&lt; std::endl;\n}\n\nvoid BankAccount::deposit(double cash)\n{\n    balance += cash;\n}\n\nvoid BankAccount::withdraw(double cash)\n{\n    balance -= cash;\n}\n</code></pre> Code - Program <pre><code>#include &lt;iostream&gt;\n#include \"ch10_1.h\"\n\nint main(){\n\n    BankAccount poorFella(\"Jack Empty\", \"9392012012032416082213\", 200);\n    poorFella.show();\n    poorFella.deposit(10);\n    poorFella.show();\n    poorFella.withdraw(99.99);\n    poorFella.show();\n    poorFella.deposit(50);\n    poorFella.show();\n\n    return 0;\n}\n</code></pre> <p>2 - Here is a rather simple class definition:</p> <pre><code>class Person {\nprivate:\n    static const LIMIT = 25;\n    string lname; // Person\u2019s last name\n    char fname[LIMIT]; // Person\u2019s first name\npublic:\n    Person() {lname = \"\"; fname[0] = \u2018\\0\u2019; } // #1\n    Person(const string &amp; ln, const char * fn = \"Heyyou\"); // #2\n    // the following methods display lname and fname\n    void Show() const; // firstname lastname format\n    void FormalShow() const; // lastname, firstname format\n};\n</code></pre> <p>(It uses both a string object and a character array so that you can compare how the two forms are used.)</p> <p>Write a program that completes the implementation by providing code for the undefined methods. The program in which you use the class should also use the three possible constructor calls (no arguments, one argument, and two arguments) and the two display methods. Here\u2019s an example that uses the constructors and methods:</p> <pre><code>Person one;                         // use default constructor\nPerson two(\"Smythecraft\");          // use #2 with one default argument\nPerson three(\"Dimwiddy\", \"Sam\");    // use #2, no defaults\none.Show();\ncout &lt;&lt; endl;\none.FormalShow();\n// etc. for two and three\n</code></pre> Code - Prototypes <pre><code>#ifndef _PERSON_H_\n#define _PERSON_H_\n\n#include &lt;iostream&gt;\n\nclass Person\n{\nprivate:\n    static const int LIMIT = 25;\n    std::string lname;      // Person\u2019s last name\n    char fname[LIMIT]; // Person\u2019s first name\npublic:\n    Person()\n    {\n        lname = \"\";\n        fname[0] = '\\0';\n    }                                                    // #1\n    Person(const std::string &amp;ln, const char *fn = \"Heyyou\"); // #2\n    // the following methods display lname and fname\n    void Show() const;       // firstname lastname format\n    void FormalShow() const; // lastname, firstname format\n};\n#endif\n</code></pre> Code - Methods <pre><code>#include \"ch10_2.h\"\n#include &lt;string.h&gt;\n\nPerson::Person(const std::string &amp;ln, const char *fn)\n{\n    lname = ln;\n    // strcpy(fname, fn);\n    strcpy_s(fname, sizeof(fname), fn);\n}\n\nvoid Person::Show() const\n{\n    std::cout &lt;&lt; \"\\n\" &lt;&lt; fname;\n    std::cout &lt;&lt; \" \" &lt;&lt; lname;\n}\n\nvoid Person::FormalShow() const\n{\n    std::cout &lt;&lt; \"\\n\" &lt;&lt; lname;\n    std::cout &lt;&lt; \", \" &lt;&lt; fname;\n}\n</code></pre> Code - Program <pre><code>#include &lt;iostream&gt;\n#include \"ch10_2.h\"\n\nint main()\n{\n    using namespace std;\n\n    Person *myMan = new Person;\n    Person *yourMan = new Person(\"Jeff\");\n    Person *ourMan = new Person(\"Jeff\", \"Coke\");\n\n    Person staticMan(\"Live\", \"Longman\");\n\n    cout &lt;&lt; \"\\n\\nDefault init myMan: \";\n    myMan-&gt;Show();\n\n    cout &lt;&lt; \"\\n\\nInit yourMan: \";\n    yourMan-&gt;Show();\n\n    cout &lt;&lt; \"\\n\\nInit ourMan: \";\n    yourMan-&gt;Show();\n\n    cout &lt;&lt; \"\\n\\nInit ourMan formalshow: \";\n    yourMan-&gt;FormalShow();\n\n    cout &lt;&lt; \"\\n\\nInit staticMan: \";\n    yourMan-&gt;Show();\n\n    delete myMan, yourMan, ourMan;\n\n    return 0;\n}\n</code></pre> <p>3 - Do Programming Exercise 1 from Chapter 9 but replace the code shown there with an appropriate golf class declaration. Replace <code>setgolf(golf &amp;, const char,int) with a constructor with the appropriate argument for providing initial values. Retain the interactive version of setgolf() but implement it by using the constructor. (For example, for the code for <code>setgolf()</code>, obtain the data, pass the data to the constructor to create a temporary object, and assign the temporary object to the invoking object, which is <code>this</code>.) Code - Prototypes <pre><code>#ifndef _GOLF_H_\n#define _GOLF_H_\n\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nstatic const int Len = 40;\n\nclass Golf\n{\nprivate:\n    struct sGolf\n    {\n        char fullname[Len];\n        int handicap;\n    };\n    sGolf data;\n\npublic:\n    Golf();\n    ~Golf();\n\n    // non-interactive version:\n    // function sets golf structure to provided name, handicap\n    // using values passed as arguments to the function\n    void setgolf(const char *name, int hc);\n\n    // interactive version:\n    // function solicits name and handicap from user\n    // and sets the members of g to the values entered\n    // returns 1 if name is entered, 0 if name is empty string\n    int setgolf();\n\n    // function resets handicap to new value\n    void handicap(int hc);\n\n    // function displays contents of golf structure\n    void showgolf();\n};\n\n#endif\n</code></pre> Code - Methods <pre><code>#include &lt;iostream&gt;\n#include \"ch10_3_golf.h\"\n\nGolf::Golf()\n{\n    data.fullname[0] = '\\0';\n    data.handicap = 0;\n}\n\nGolf::~Golf()\n{\n}\n\nvoid Golf::setgolf(const char *name, int hc)\n{\n    strcpy(data.fullname, name);\n    data.handicap = hc;\n}\n\nint Golf::setgolf()\n{\n    std::cin.clear(); // reset input\n    while (std::cin.get() != '\\n')\n        continue; // get rid of bad input\n\n    std::cout &lt;&lt; \"\\nEnter the name: \";\n    // std::cin &gt;&gt; data.fullname;\n    std::cin.getline(data.fullname, Len);\n\n    std::cout &lt;&lt; \"Enter the handicap: \";\n    // std::cin &gt;&gt; data.handicap;\n    while (!(std::cin &gt;&gt; data.handicap))\n    {\n        std::cin.clear(); // reset input\n        while (std::cin.get() != '\\n')\n            continue; // get rid of bad input\n        std::cout &lt;&lt; \"Please enter a number: \";\n    }\n    // std::cin.get(); // clear the input buffer\n\n    if (data.fullname == \"\")\n    {\n        return 0;\n    }\n    return 1;\n}\n\nvoid Golf::handicap(int hc)\n{\n    data.handicap = hc;\n}\n\nvoid Golf::showgolf()\n{\n    std::cout &lt;&lt; \"\\t\" &lt;&lt; data.fullname &lt;&lt; \"\\t\\t\";\n    std::cout &lt;&lt; data.handicap &lt;&lt; std::endl;\n}\n</code></pre> Code - Program <pre><code>#include &lt;iostream&gt;\n#include \"ch10_3_golf.h\"\n\nvoid fnPrintMenu()\n{\n    std::cout\n        &lt;&lt; \"\\nPlease select:\\n\"\n        &lt;&lt; \"\\ta) non-interactive version\\tb) interactive version\\n\"\n        &lt;&lt; \"\\tc) print all players\\t\\td) change number of players\\n\"\n        &lt;&lt; \"\\te) quit\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n\n    char strFullname[40];\n    int iHandicap{}, iPlayers{1};\n    char cMenu;\n\n    do\n    {\n        std::cout &lt;&lt; \"\\nEnter the number of players (default is 1, max is 40): \";\n        std::cin &gt;&gt; iPlayers;\n\n        if (iPlayers &gt; 40 || iPlayers &lt; 1)\n        {\n            std::cout &lt;&lt; \"Invalid number of players, try again\\n\";\n        }\n    } while (iPlayers &gt; 40 || iPlayers &lt; 1);\n\n    fnPrintMenu();\n    std::cin &gt;&gt; cMenu;\n\n    Golf *andy = new Golf[40]; // static memory allocation  [1/1]\n\n    while (true)\n    {\n\n        switch (cMenu)\n        {\n        case 'a':\n            for (int i = 0; i &lt; iPlayers; ++i)\n            {\n                // std::cin &gt;&gt; strFullname &gt;&gt; iHandicap;\n                std::cin.clear(); // reset input\n                while (std::cin.get() != '\\n')\n                    continue; // get rid of bad input\n\n                std::cin.getline(strFullname, Len);\n                while (!(std::cin &gt;&gt; iHandicap))\n                {\n                    std::cin.clear(); // reset input\n                    while (std::cin.get() != '\\n')\n                        continue; // get rid of bad input\n                    std::cout &lt;&lt; \"Please enter a number: \";\n                }\n\n                andy[i].setgolf(strFullname, iHandicap);\n            }\n            break;\n        case 'b':\n            for (size_t i = 0; i &lt; iPlayers; ++i)\n            {\n                andy[i].setgolf();\n            }\n            break;\n        case 'c':\n            std::cout &lt;&lt; \"\\tName \\t\\t\\tHandicap \\n\";\n            std::cout &lt;&lt; \"\\t---------------------------------\\n\";\n            for (int i = 0; i &lt; iPlayers; ++i)\n            {\n                andy[i].showgolf();\n            }\n            break;\n        case 'd':\n            do\n            {\n                std::cout &lt;&lt; \"\\nEnter the number of players (default is 1, max is 40): \";\n                std::cin &gt;&gt; iPlayers;\n\n                if (iPlayers &gt; 40 || iPlayers &lt; 1)\n                {\n                    std::cout &lt;&lt; \"Invalid number of players, try again\\n\";\n                }\n            } while (iPlayers &gt; 40 || iPlayers &lt; 1);\n            break;\n        case 'e':\n            std::cout &lt;&lt; \"Bye-bye!\\n\";\n            return 0;\n        default:\n            std::cout &lt;&lt; \"Please enter: a, b, c or d: \";\n            break;\n        }\n        fnPrintMenu();\n        std::cin &gt;&gt; cMenu;\n    }\n\n    // delete [] andy;                      // dynamic memory allocation [2/2]\n    return 0;\n}\n</code></pre> <p>4 - Do Programming Exercise 4 from Chapter 9 but convert the <code>Sales</code> structure and its associated functions to a class and its methods. Replace the <code>setSales(Sales &amp;, double [], int)</code> function with a constructor. Implement the interactive <code>setSales(Sales &amp;)</code> method by using the constructor. Keep the class within the namespace <code>SALES</code>.</p> Code - Prototypes <pre><code>#include &lt;iostream&gt;\n\nnamespace SALES\n{\n    static const int QUARTERS = 4;\n    class Deals\n    {\n    private:\n        struct Sales\n        {\n            double sales[QUARTERS];\n            double average;\n            double max;\n            double min;\n        };\n        Sales data;\n\n    public:\n        Deals(/* args */);\n        ~Deals();\n\n        // copies the lesser of 4 or n items from the array ar\n        // to the sales member of s and computes and stores the\n        // average, maximum, and minimum values of the entered items;\n        // remaining elements of sales, if any, set to 0\n        void setSales(const double ar[], int n);\n\n        // gathers sales for 4 quarters interactively, stores them\n        // in the sales member of s and computes and stores the\n        // average, maximum, and minimum values\n        void setSales();\n\n        // display all information in structure s\n        void showSales() const;\n    };\n\n}\n</code></pre> Code - Methods <pre><code>#include &lt;iostream&gt;\n#include \"ch10_4_sales.h\"\n\nSALES::Deals::Deals(/* args */)\n{\n}\n\nSALES::Deals::~Deals()\n{\n}\n\n// copies the lesser of 4 or n items from the array ar\n// to the sales member of s and computes and stores the\n// average, maximum, and minimum values of the entered items;\n// remaining elements of sales, if any, set to 0\nvoid SALES::Deals::setSales(const double ar[], int n)\n{\n    if (n &gt; QUARTERS)\n        return;\n\n    data.average = 0;\n    data.min = ar[0];\n    data.max = ar[0];\n    for (int i = 0; i &lt; n; ++i)\n    {\n        if (i &lt; (n - 1))\n        {\n            if (data.min &gt; ar[i + 1])\n                data.min = ar[i + 1];\n\n            if (data.max &lt; ar[i + 1])\n                data.max = ar[i + 1];\n        }\n\n        data.sales[i] = ar[i];\n        data.average += ar[i];\n    }\n\n    data.average /= n;\n}\n// gathers sales for 4 quarters interactively, stores them\n// in the sales member of s and computes and stores the\n// average, maximum, and minimum values\nvoid SALES::Deals::setSales()\n{\n    data.average = 0;\n    data.min = 0;\n    data.max = 0;\n\n    std::cout &lt;&lt; \"\\nSet sales for quarters: \";\n    for (int i = 0; i &lt; QUARTERS; ++i)\n    {\n        std::cout &lt;&lt; \"\\n-&gt; sale \" &lt;&lt; i &lt;&lt; \" : \";\n        while (!(std::cin &gt;&gt; data.sales[i]))\n        {\n            std::cin.clear(); // reset input\n            while (std::cin.get() != '\\n')\n                continue; // get rid of bad input\n            std::cout &lt;&lt; \"Please enter a number: \";\n        }\n    }\n\n    data.min = data.sales[0];\n    for (int i = 0; i &lt; QUARTERS; ++i)\n    {\n        if (i &lt; (QUARTERS - 1))\n        {\n            if (data.min &gt; data.sales[i + 1])\n                data.min = data.sales[i + 1];\n\n            if (data.max &lt; data.sales[i + 1])\n                data.max = data.sales[i + 1];\n        }\n        data.average += data.sales[i];\n    }\n\n    data.average /= QUARTERS;\n}\n\n// display all information in structure s\nvoid SALES::Deals::showSales() const\n{\n    std::cout &lt;&lt; \"\\n\\n\";\n    std::cout &lt;&lt; \"\\t Average: \\t\" &lt;&lt; data.average;\n    std::cout &lt;&lt; \"\\t Max:     \\t\" &lt;&lt; data.max;\n    std::cout &lt;&lt; \"\\t Min:     \\t\" &lt;&lt; data.min &lt;&lt; \"\\n\";\n\n    for (int i = 0; i &lt; QUARTERS; i++)\n        std::cout &lt;&lt; \"\\t Sale [\" &lt;&lt; i &lt;&lt; \"] : \\t\" &lt;&lt; data.sales[i];\n}\n</code></pre> Code - Program <pre><code>#include &lt;iostream&gt;\n#include \"ch10_4_sales.h\"\n\nusing namespace SALES;\n\n\nvoid fnPrintMenu()\n{\n    std::cout\n        &lt;&lt; \"\\nPlease select:\\n\"\n        &lt;&lt; \"\\ta) non-interactive version\\tb) interactive version\\n\"\n        &lt;&lt; \"\\tc) print all sales\"\n        &lt;&lt; \"\\t\\td) quit\" &lt;&lt; std::endl;\n}\n\n\nint main(){\n    char cMenu;\n    Deals *mySales = new Deals[2];\n\n    fnPrintMenu();\n    std::cin &gt;&gt; cMenu;\n\n    while (true)\n    {\n        switch (cMenu)\n        {\n        case 'a':\n            double temp[QUARTERS];\n            for (int i = 0; i &lt; QUARTERS; ++i)\n            {\n                while (!(std::cin &gt;&gt; temp[i]))\n                {\n                    std::cin.clear(); // reset input\n                    while (std::cin.get() != '\\n')\n                        continue; // get rid of bad input\n                    std::cout &lt;&lt; \"Please enter a number: \";\n                }\n            }\n            mySales[0].setSales(temp, QUARTERS);\n            break;\n        case 'b':\n            mySales[1].setSales();\n            break;\n        case 'c':\n            for (int i = 0; i &lt; 2; ++i)\n                mySales[i].showSales();\n            break;\n        case 'd':\n        //     break;\n        // case 'e':\n            std::cout &lt;&lt; \"Bye-bye!\\n\";\n            return 0;\n        default:\n            std::cout &lt;&lt; \"Please enter: a, b, c or e: \";\n            break;\n        }\n\n        fnPrintMenu();\n        std::cin &gt;&gt; cMenu;\n    }\n\n    delete[] mySales;\n\n    return 0;\n}\n\n/*\nThe first file should be a header file that contains the namespace.The second file\nshould be a source code file that extends the namespace to provide definitions for\nthe three prototyped functions. The third file should declare two Sales objects. It\nshould use the interactive version of setSales() to provide values for one structure\nand the non-interactive version of setSales() to provide values for the second\nstructure. It should display the contents of both structures by using\nshowSales().\n*/\n</code></pre> <p>5 - Consider the following structure declaration:</p> <pre><code>struct customer {\n    char fullname[35];\n    double payment;\n};\n</code></pre> <p>Write a program that adds and removes customer structures from a stack, represented by a Stack class declaration. Each time a customer is removed, his or her payment should be added to a running total, and the running total should be reported.</p> <p>Note: You should be able to use the Stack class unaltered; just change the typedef declaration so that Item is type customer instead of unsigned long.</p> Code - Prototypes <pre><code>// stack.h -- class definition for the stack ADT\n#ifndef STACK_H_\n#define STACK_H_\n\nstruct Customer {\n    char fullname[35];\n    double payment;\n};\n\nclass Stack\n{\nprivate:\n    enum\n    {\n        MAX = 10\n    };               // constant specific to class\n\n    Customer Client[MAX];   // holds stack structures\n    int top;                // index for top stack item\n\npublic:\n    Stack();\n    bool isempty() const;\n    bool isfull() const;\n    // push() returns false if stack already is full, true otherwise\n    bool push(const Customer &amp;item); // add item to stack\n    // pop() returns false if stack already is empty, true otherwise\n    bool pop(Customer &amp;item); // pop top into item\n};\n#endif\n</code></pre> Code - Methods <pre><code>// stack.cpp -- Stack member functions\n#include \"ch10_5_buisness.h\"\n\nStack::Stack() // create an empty stack\n{\n    top = 0;\n}\n\nbool Stack::isempty() const\n{\n    return top == 0;\n}\n\nbool Stack::isfull() const\n{\n    return top == MAX;\n}\n\nbool Stack::push(const Customer &amp;item)\n{\n    if (top &lt; MAX)\n    {\n        Client[top++] = item;\n        return true;\n    }\n    else\n        return false;\n}\n\nbool Stack::pop(Customer &amp;item)\n{\n    if (top &gt; 0)\n    {\n        item = Client[--top];\n        return true;\n    }\n    else\n        return false;\n}\n\n/*\nThe default constructor guarantees that all stacks are created empty.The code for\npop() and push() guarantees that the top of the stack is managed properly.\n*/\n</code></pre> Code - Program <pre><code>// stacker.cpp -- testing the Stack class\n#include &lt;iostream&gt;\n#include &lt;cctype&gt; // or ctype.h\n#include \"ch10_5_buisness.h\"\n\nint main()\n{\n    using namespace std;\n    Stack st; // create an empty stack\n    char ch;\n    Customer po;\n\n    long double dRunningTotal{};\n\n    cout &lt;&lt; \"Please enter A to add a purchase order,\\n\"\n         &lt;&lt; \"P to process a PO, or Q to quit.\\n\";\n    while (cin &gt;&gt; ch &amp;&amp; toupper(ch) != 'Q')\n    {\n        while (cin.get() != '\\n')\n            continue;\n        if (!isalpha(ch))\n        {\n            cout &lt;&lt; '\\a';\n            continue;\n        }\n        switch (ch)\n        {\n        case 'A':\n        case 'a':\n            cout &lt;&lt; \"Enter a name of a Customer to add: \";\n            cin.getline(po.fullname, 35);\n            if (!isalpha(ch))\n            {\n                cout &lt;&lt; '\\a';\n                continue;\n            }\n\n            cout &lt;&lt; \"Enter a PO price: \";\n            while (!(cin &gt;&gt; po.payment))\n            {\n                cin.clear(); // reset input\n                while (cin.get() != '\\n')\n                    continue; // get rid of bad input\n                cout &lt;&lt; \"Please enter a number: \";\n            }\n            cin.get(); // clear the input buffer\n\n            if (st.isfull())\n                cout &lt;&lt; \"stack already full\\n\";\n            else\n                st.push(po);\n            break;\n        case 'P':\n        case 'p':\n            if (st.isempty())\n                cout &lt;&lt; \"stack already empty\\n\";\n            else\n            {\n                st.pop(po);\n                dRunningTotal += po.payment;\n                cout &lt;&lt; \"PO of a \" &lt;&lt; po.fullname &lt;&lt; \" popped\\n\";\n                cout &lt;&lt; \"PO \" &lt;&lt; po.payment &lt;&lt; \"$ added\\n\";\n                cout &lt;&lt; \"Running total = \" &lt;&lt; dRunningTotal &lt;&lt; \"$\\n\";\n            }\n            break;\n        }\n        cout &lt;&lt; \"\\nPlease enter A to add a purchase order,\\n\"\n             &lt;&lt; \"P to process a PO, or Q to quit.\\n\";\n    }\n    cout &lt;&lt; \"Bye\\n\";\n    return 0;\n}\n</code></pre> <p>6 - Here\u2019s a class declaration:</p> <pre><code>class Move\n{\nprivate:\n    double x;\n    double y;\npublic:\n    Move(double a = 0, double b = 0); // sets x, y to a, b\n    showmove() const; // shows current x, y values\n    Move add(const Move &amp; m) const;\n    // this function adds x of m to x of invoking object to get new x,\n    // adds y of m to y of invoking object to get new y, creates a new\n    // move object initialized to new x, y values and returns it\n    reset(double a = 0, double b = 0); // resets x,y to a, b\n};\n</code></pre> <p>Create member function definitions and a program that exercises the class.</p> Code - Prototypes <pre><code>#ifndef _MOVE_H_\n#define _MOVE_H_\n\nclass Move\n{\nprivate:\n    double x;\n    double y;\n\npublic:\n    Move(double a = 0, double b = 0); // sets x, y to a, b\n    void showmove() const;                 // shows current x, y values\n    Move add(const Move &amp;m) const;\n    // this function adds x of m to x of invoking object to get new x,\n    // adds y of m to y of invoking object to get new y, creates a new\n    // move object initialized to new x, y values and returns it\n    void reset(double a = 0, double b = 0); // resets x,y to a, b\n};\n\n#endif\n</code></pre> Code - Methods <pre><code>#include &lt;iostream&gt;\n#include \"ch10_6_move.h\"\n\n// sets x, y to a, b\nMove::Move(double a, double b)\n{\n    x = a;\n    y = b;\n}\n\n// shows current x, y values\nvoid Move::showmove() const\n{\n    std::cout &lt;&lt; \"\\n x : \" &lt;&lt; x;\n    std::cout &lt;&lt; \"\\n y : \" &lt;&lt; y;\n    std::cout &lt;&lt; std::endl;\n}\n\n// this function adds x of m to x of invoking object to get new x,\n// adds y of m to y of invoking object to get new y, creates a new\n// move object initialized to new x, y values and returns it\nMove Move::add(const Move &amp;m) const\n{\n    Move out;\n    out.x += m.x;\n    out.y += m.y;\n\n    out.x += this-&gt;x;\n    out.y += this-&gt;y;\n\n    return out;\n}\n\n// resets x,y to a, b\nvoid Move::reset(double a, double b)\n{\n    x = a;\n    y = b;\n}\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include \"ch10_6_move.h\"\n\nint main(){\n    Move moveA;\n    Move moveB(10.33, 32.2);\n\n    double dVals[4] {21.22, 32.3, 3.33, 9.52};\n\n    std::cout &lt;&lt; \"\\nmoveA - vals\";\n    moveA.showmove();\n    std::cout &lt;&lt; \"\\nmoveB - vals\";\n    moveB.showmove();\n\n    std::cout &lt;&lt; \"\\nmoveA - reset to \" &lt;&lt; dVals[0] &lt;&lt; \", \" &lt;&lt; dVals[1];\n    moveA.reset(dVals[0], dVals[1]);\n    moveA.showmove();\n\n    std::cout &lt;&lt; \"\\nAdding classes: moveB = moveA + moveB\";\n    moveB = moveA.add(moveB);\n\n    std::cout &lt;&lt; \"\\nmoveB - vals\";\n    moveB.showmove();\n\n    return 0;\n}\n</code></pre> <p>7 - A Betelgeusean plorg has these properties:</p> <pre><code>Data\nA plorg has a name with no more than 19 letters.\nA plorg has a contentment index (CI), which is an integer.\nOperations\nA new plorg starts out with a name and a CI of 50.\nA plorg\u2019s CI can change.\nA plorg can report its name and CI.\nThe default plorg has the name \"Plorga\".\n</code></pre> <p>Write a Plorg class declaration (including data members and member function prototypes) that represents a plorg. Write the function definitions for the member functions. Write a short program that demonstrates all the features of the Plorg class.</p> Code - Prototypes <pre><code>#ifndef _PLORG_H_\n#define _PLORG_H_\n\nclass Plorg\n{\nprivate:\n    int MAX = 19;\n    std::string name;\n    int CI;\n\npublic:\n    Plorg(std::string newName = \"Plorga\", int newCI = 50);\n    void ChangeCI(int newCI);\n    void Report();\n};\n\n#endif\n</code></pre> Code - Methods <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include \"ch10_7_plorg.h\"\n\nPlorg::Plorg(std::string newName, int newCI)\n{\n    if (newName.length() &gt; MAX)\n    {\n        std::cout &lt;&lt; \"Too long name - assigning default\";\n        name = \"Plorga\";\n    }\n    else\n    {\n        name = newName;\n    }\n\n    CI = newCI;\n}\n\nvoid Plorg::ChangeCI(int newCI)\n{\n    CI = newCI;\n}\n\nvoid Plorg::Report()\n{\n    std::cout &lt;&lt; \"\\nThis Plorg is named: \" &lt;&lt; name;\n    std::cout &lt;&lt; \"\\nAnd his contentment index is: \" &lt;&lt; CI;\n}\n</code></pre> Code <pre><code>#include &lt;iostream&gt;\n#include \"ch10_7_plorg.h\"\n\nint main(){\n\n    Plorg leDef;\n    Plorg Fluff(\"Corgi\", 100);\n    Plorg Hulk(\"Destroyemovertion\", 10);\n    Plorg Nerd(\"Book\", 30);\n\n    std::cout &lt;&lt; \"\\n\\n\\tReport: \";\n    std::cout &lt;&lt; \"\\n leDef: \";\n    leDef.Report();\n    std::cout &lt;&lt; \"\\n\\n Fluff: \";\n    Fluff.Report();\n    std::cout &lt;&lt; \"\\n\\n Hulk: \";\n    Hulk.Report();\n    std::cout &lt;&lt; \"\\n\\n Nerd: \";\n    Nerd.Report();\n\n    std::cout &lt;&lt; \"\\n\\n Nerd - changed CI thanks to the unknown device: \";\n    Nerd.ChangeCI(70);\n    Nerd.Report();\n\n    std::cout &lt;&lt; \"\\n\\nBye Bye!\\n\";\n\n    return 0;\n}\n</code></pre> <p>8 - You can describe a simple list as follows:</p> <ul> <li>The simple list can hold zero or more items of some particular type.</li> <li>You can create an empty list.</li> <li>You can add items to the list.</li> <li>You can determine whether the list is empty.</li> <li>You can determine whether the list is full.</li> <li>You can visit each item in the list and perform some action on it.</li> </ul> <p>As you can see, this list really is simple; it doesn\u2019t allow insertion or deletion, for example.  Design a List class to represent this abstract type. You should provide a <code>list.h</code> header file with the class declaration and a <code>list.cpp</code> file with the class method implementations. You should also create a short program that utilizes your design.</p> <p>The main reason for keeping the list specification simple is to simplify this programming exercise.You can implement the list as an array or, if you\u2019re familiar with the data type, as a linked list. But the public interface should not depend on your choice.That is, the public interface should not have array indices, pointers to nodes, and so on. It should be expressed in the general concepts of creating a list, adding an item to the list, and so on.The usual way to handle visiting each item and performing an action is to use a function that takes a function pointer as an argument:</p> <pre><code>void visit(void (*pf)(Item &amp;));\n</code></pre> <p>Here <code>pf</code> points to a function (not a member function) that takes a reference to <code>Item</code> argument, where <code>Item</code> is the type for items in the list.The <code>visit()</code> function applies this function to each item in the list.You can use the <code>Stack</code> class as a general guide.</p> Code - Program <pre><code>#include &lt;iostream&gt;\n#include &lt;cctype&gt; // or ctype.h\n#include \"ch10_8_list.h\"\n\nint main()\n{\n    using namespace std;\n    List st; // create an empty stack\n    char ch;\n\n    cout &lt;&lt; \"Please enter A to add element to the list,\\n\"\n         &lt;&lt; \"D to display values of all elements.\\n\"\n         &lt;&lt; \"M to modify value of selected element.\\n\"\n         &lt;&lt; \"R to remove element from the list.\\n\"\n         &lt;&lt; \"Q to exit the program.\\n\";\n\n    while (cin &gt;&gt; ch &amp;&amp; toupper(ch) != 'Q')\n    {\n        while (cin.get() != '\\n')\n            continue;\n        if (!isalpha(ch))\n        {\n            cout &lt;&lt; '\\a';\n            continue;\n        }\n\n        switch (ch)\n        {\n        case 'A':\n        case 'a':\n            if (st.isFull())\n                cout &lt;&lt; \"list already full\\n\";\n            else\n            {\n                cout &lt;&lt; \"Enter value of element to the list: \";\n                int tmpVal{};\n                while (!(cin &gt;&gt; tmpVal))\n                {\n                    cin.clear(); // reset input\n                    while (cin.get() != '\\n')\n                        continue; // get rid of bad input\n                    cout &lt;&lt; \"Please enter a number: \";\n                }\n                cin.get(); // clear the input buffer\n\n                st.add(tmpVal);\n            }\n            break;\n        case 'D':\n        case 'd':\n            st.display();\n            break;\n        case 'M':\n        case 'm':\n        {\n            int tmpIdx{};\n            int tmpVal{};\n\n            cout &lt;&lt; \"Enter the index of list element to change: \";\n            while (!(cin &gt;&gt; tmpIdx))\n            {\n                cin.clear(); // reset input\n                while (cin.get() != '\\n')\n                    continue; // get rid of bad input\n                cout &lt;&lt; \"Please enter a number: \";\n            }\n            cin.get(); // clear the input buffer\n\n            cout &lt;&lt; \"Enter value of element to the list: \";\n\n            while (!(cin &gt;&gt; tmpVal))\n            {\n                cin.clear(); // reset input\n                while (cin.get() != '\\n')\n                    continue; // get rid of bad input\n                cout &lt;&lt; \"Please enter a number: \";\n            }\n            cin.get(); // clear the input buffer\n\n            st.modify(tmpIdx, tmpVal);\n            break;\n        }\n        case 'R':\n        case 'r':\n            if (st.isEmpty())\n                cout &lt;&lt; \"list already empty\\n\";\n            else\n                st.pop();\n            break;\n        }\n\n        cout &lt;&lt; \"\\nPlease enter A to add element to the list,\\n\"\n             &lt;&lt; \"D to display values of all elements.\\n\"\n             &lt;&lt; \"M to modify value of selected element.\\n\"\n             &lt;&lt; \"R to remove element from the list.\\n\"\n             &lt;&lt; \"Q to exit the program.\\n\";\n    }\n    cout &lt;&lt; \"Bye\\n\";\n    return 0;\n}\n</code></pre> Code - Prototypes <pre><code>#ifndef _LIST_H_\n#define _LIST_H_\n\nclass List\n{\nprivate:\n    enum{\n        MAX = 10\n    };\n    int dataVal[MAX]{};\n    int top{};\n\npublic:\n    List();\n    List(int valTab[], int numEl);\n    ~List();\n    bool isEmpty();\n    bool isFull();\n    bool add(int elVal);\n    bool pop();\n    bool modify(int elNum, int newVal);\n    void display();\n};\n\n\n\n#endif\n</code></pre> Code - Methods <pre><code>#include &lt;iostream&gt;\n#include \"ch10_8_list.h\"\n\nList::List()\n{\n}\n\nList::List(int valTab[], int numEl)\n{\n    if (numEl &gt; MAX)\n    {\n        std::cout &lt;&lt; \"More elements than max allowed\";\n        return;\n    }\n\n    for (int i{}; i &lt; numEl; ++i)\n    {\n        dataVal[i] = valTab[i];\n        ++top;\n    }\n}\n\nList::~List()\n{\n}\n\nbool List::isEmpty()\n{\n    return top == 0;\n}\n\nbool List::isFull()\n{\n    return top == MAX;\n}\n\nbool List::add(int elVal)\n{\n    if (top &lt; MAX)\n    {\n        dataVal[top++] = elVal;\n        return true;\n    }\n    else\n        return false;\n}\n\nbool List::pop()\n{\n    if (top &gt; 0)\n    {\n        dataVal[top--] = 0;\n        return true;\n    }\n    else\n        return false;\n}\n\nvoid List::display()\n{\n    for (int i{}; i &lt; top; ++i)\n        std::cout &lt;&lt; \"\\nItem [\" &lt;&lt; i &lt;&lt; \"]: \" &lt;&lt; dataVal[i];\n}\n\nbool List::modify(int elNum, int newVal)\n{\n    if (elNum &gt;= top)\n    {\n        std::cout &lt;&lt; \"Item does not exist\";\n        return false;\n    }\n\n    std::cout &lt;&lt; \"\\nItem [\" &lt;&lt; elNum &lt;&lt; \"]: \" &lt;&lt; dataVal[elNum];\n    std::cout &lt;&lt; \"\\nChanged value to:\";\n\n    dataVal[elNum] = newVal;\n    std::cout &lt;&lt; \"\\nItem [\" &lt;&lt; elNum &lt;&lt; \"]: \" &lt;&lt; dataVal[elNum];\n\n    return true;\n}\n</code></pre>"},{"location":"exercises/#chapter-11","title":"Chapter 11","text":"<p>1 - Modify Listing 11.15 (randwalk.cpp) so that it writes the successive locations of the random walker into a file. Label each position with the step number.Also have the program write the initial conditions (target distance and step size) and the summarized results to the file.The file contents might look like this:</p> <pre><code>Target Distance: 100, Step Size: 20\n0: (x,y) = (0, 0)\n1: (x,y) = (-11.4715, 16.383)\n2: (x,y) = (-8.68807, -3.42232)\n...\n26: (x,y) = (42.2919, -78.2594)\n27: (x,y) = (58.6749, -89.7309)\nAfter 27 steps, the subject has the following location:\n(x,y) = (58.6749, -89.7309)\nor\n(m,a) = (107.212, -56.8194)\nAverage outward distance per step = 3.97081\n</code></pre> Program <pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt; // rand(), srand() prototypes\n#include &lt;ctime&gt;   // time() prototype\n#include \"ch11_1_vect.h\"\n\n#include &lt;fstream&gt;\n\nint main()\n{\n    using namespace std;\n    using VECTOR::Vector;\n    srand(time(0)); // seed random-number generator\n    double direction;\n\n    Vector step;\n    Vector result(0.0, 0.0);\n\n    unsigned long steps = 0;\n    double target;\n    double dstep;\n\n    // File handling\n    ofstream outFile;\n    outFile.open(\"./ch11_1_randwalk.txt\");\n\n    if (!outFile.is_open())\n    {\n        cout &lt;&lt; \"Could not open file\" &lt;&lt; endl;\n        cout &lt;&lt; \"Terminate program\" &lt;&lt; endl;\n        exit(EXIT_FAILURE);\n    }\n\n    cout &lt;&lt; \"Enter target distance (q to quit): \";\n    while (cin &gt;&gt; target)\n    {\n        cout &lt;&lt; \"Enter step length: \";\n        if (!(cin &gt;&gt; dstep))\n            break;\n\n        // Write initial conditions to file\n        if (outFile.good())\n        {\n            outFile &lt;&lt; \"Target Distance: \" &lt;&lt; target;\n            outFile &lt;&lt; \", Step Size: \" &lt;&lt; dstep &lt;&lt; endl;\n        }\n\n        while (result.magval() &lt; target)\n        {\n            direction = rand() % 360;\n            step.reset(dstep, direction, Vector::POL);\n            result = result + step;\n\n            if (outFile.good())\n                outFile &lt;&lt; steps &lt;&lt; \": (x,y) = (\" &lt;&lt; result.xval() &lt;&lt; \", \" &lt;&lt; result.yval() &lt;&lt; \")\" &lt;&lt; endl;\n\n            steps++;\n        }\n        cout &lt;&lt; \"After \" &lt;&lt; steps &lt;&lt; \n                \" steps, the subject has the following location:\\n\";\n        cout &lt;&lt; result &lt;&lt; endl;\n\n        if (outFile.good())\n        {\n            outFile &lt;&lt; \"After \" &lt;&lt; steps &lt;&lt; \n            \" steps, the subject has the following location:\\n\" &lt;&lt;\n            result &lt;&lt; endl;\n        }\n\n        result.polar_mode();\n        cout &lt;&lt; \" or\\n\"\n             &lt;&lt; result &lt;&lt; endl;\n        cout &lt;&lt; \"Average outward distance per step = \"\n             &lt;&lt; result.magval() / steps &lt;&lt; endl;\n\n        if (outFile.good())\n        {\n            outFile &lt;&lt; \" or\\n\" &lt;&lt; result &lt;&lt; endl;\n            outFile &lt;&lt; \"Average outward distance per step = \" &lt;&lt;\n            result.magval() / steps &lt;&lt; endl;\n        }\n\n        steps = 0;\n        result.reset(0.0, 0.0);\n        cout &lt;&lt; \"Enter target distance (q to quit): \";\n    }\n    cout &lt;&lt; \"Bye!\\n\";\n    cin.clear();\n    while (cin.get() != '\\n')\n        continue;\n    return 0;\n}\n\n/*\nModify Listing 11.15 so that it writes the successive locations of the random walker\ninto a file. Label each position with the step number. Also have the program write\nthe initial conditions (target distance and step size) and the summarized results to\nthe file. The file contents might look like this:\n\nTarget Distance: 100, Step Size: 20\n0: (x,y) = (0, 0)\n1: (x,y) = (-11.4715, 16.383)\n2: (x,y) = (-8.68807, -3.42232)\n...\n26: (x,y) = (42.2919, -78.2594)\n27: (x,y) = (58.6749, -89.7309)\nAfter 27 steps, the subject has the following location:\n(x,y) = (58.6749, -89.7309)\nor\n(m,a) = (107.212, -56.8194)\nAverage outward distance per step = 3.97081\n\n\nListing 11.15 randwalk.cpp\n// randwalk.cpp -- using the Vector class\n// compile with the vect.cpp file\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt; // rand(), srand() prototypes\n#include &lt;ctime&gt;   // time() prototype\n#include \"vect.h\"\n    int\n    main()\n{\n    using namespace std;\n    using VECTOR::Vector;\n    srand(time(0)); // seed random-number generator\n    double direction;\n    Vector step;\n    Vector result(0.0, 0.0);\n    unsigned long steps = 0;\n    double target;\n    double dstep;\n    cout &lt;&lt; \"Enter target distance (q to quit): \";\n    while (cin &gt;&gt; target)\n    {\n        cout &lt;&lt; \"Enter step length: \";\n        if (!(cin &gt;&gt; dstep))\n            break;\n        while (result.magval() &lt; target)\n        {\n            direction = rand() % 360;\n            step.reset(dstep, direction, Vector::POL);\n            result = result + step;\n            steps++;\n        }\n        cout &lt;&lt; \"After \" &lt;&lt; steps &lt;&lt; \" steps, the subject \"\n                                     \"has the following location:\\n\";\n        cout &lt;&lt; result &lt;&lt; endl;\n        result.polar_mode();\n        cout &lt;&lt; \" or\\n\"\n             &lt;&lt; result &lt;&lt; endl;\n        cout &lt;&lt; \"Average outward distance per step = \"\n             &lt;&lt; result.magval() / steps &lt;&lt; endl;\n        steps = 0;\n        result.reset(0.0, 0.0);\n        cout &lt;&lt; \"Enter target distance (q to quit): \";\n    }\n    cout &lt;&lt; \"Bye!\\n\";\n    cin.clear();\n    while (cin.get() != '\\n')\n        continue;\n    return 0;\n}\n*/\n\n/*\nHere is a sample run of the program in Listings 11.13, 11.14, and 11.15:\nEnter target distance (q to quit): 50\nEnter step length: 2\nAfter 253 steps, the subject has the following location:\n(x,y) = (46.1512, 20.4902)\nor\n(m,a) = (50.495, 23.9402)\nAverage outward distance per step = 0.199587\nEnter target distance (q to quit): 50\nEnter step length: 2\nAfter 951 steps, the subject has the following location:\n(x,y) = (-21.9577, 45.3019)\nor\n(m,a) = (50.3429, 115.8593)\nAverage outward distance per step = 0.0529362\nEnter target distance (q to quit): 50\nEnter step length: 1\nAfter 1716 steps, the subject has the following location:\n(x,y) = (40.0164, 31.1244)\nor\n(m,a) = (50.6956, 37.8755)\nAverage outward distance per step = 0.0295429\nEnter target distance (q to quit): q\nBye!\n*/\n</code></pre> Prototypes <pre><code>// vect.h -- Vector class with &lt;&lt;, mode state\n#ifndef VECTOR_H_\n#define VECTOR_H_\n#include &lt;iostream&gt;\nnamespace VECTOR\n{\n    class Vector\n    {\n    public:\n        enum Mode\n        {\n            RECT,\n            POL\n        };\n        // RECT for rectangular, POL for Polar modes\n    private:\n        double x;   // horizontal value\n        double y;   // vertical value\n        double mag; // length of vector\n        double ang; // direction of vector in degrees\n        Mode mode;  // RECT or POL\n        // private methods for setting values\n        void set_mag();\n        void set_ang();\n        void set_x();\n        void set_y();\n\n    public:\n        Vector();\n        Vector(double n1, double n2, Mode form = RECT);\n        void reset(double n1, double n2, Mode form = RECT);\n        ~Vector();\n        double xval() const { return x; }     // report x value\n        double yval() const { return y; }     // report y value\n        double magval() const { return mag; } // report magnitude\n        double angval() const { return ang; } // report angle\n        void polar_mode();                    // set mode to POL\n        void rect_mode();                     // set mode to RECT\n        // operator overloading\n        Vector operator+(const Vector &amp;b) const;\n        Vector operator-(const Vector &amp;b) const;\n        Vector operator-() const;\n        Vector operator*(double n) const;\n        // friends\n        friend Vector operator*(double n, const Vector &amp;a);\n        friend std::ostream &amp;\n        operator&lt;&lt;(std::ostream &amp;os, const Vector &amp;v);\n    };\n} // end namespace VECTOR\n#endif\n</code></pre> Methods <pre><code>// vect.cpp -- methods for the Vector class\n#include &lt;cmath&gt;\n#include \"ch11_1_vect.h\" // includes &lt;iostream&gt;\n\nusing std::atan;\nusing std::atan2;\nusing std::cos;\nusing std::cout;\nusing std::sin;\nusing std::sqrt;\n\nnamespace VECTOR\n{\n    // compute degrees in one radian\n    const double Rad_to_deg = 45.0 / atan(1.0);\n\n    // should be about 57.2957795130823\n    // private methods\n    // calculates magnitude from x and y\n    void Vector::set_mag()\n    {\n        mag = sqrt(x * x + y * y);\n    }\n\n    void Vector::set_ang()\n    {\n        if (x == 0.0 &amp;&amp; y == 0.0)\n            ang = 0.0;\n        else\n            ang = atan2(y, x);\n    }\n\n    // set x from polar coordinate\n    void Vector::set_x()\n    {\n        x = mag * cos(ang);\n    }\n\n    // set y from polar coordinate\n    void Vector::set_y()\n    {\n        y = mag * sin(ang);\n    }\n\n    // public methods\n    Vector::Vector() // default constructor\n    {\n        x = y = mag = ang = 0.0;\n        mode = RECT;\n    }\n\n    // construct vector from rectangular coordinates if form is r\n    // (the default) or else from polar coordinates if form is p\n    Vector::Vector(double n1, double n2, Mode form)\n    {\n        mode = form;\n        if (form == RECT)\n        {\n            x = n1;\n            y = n2;\n            set_mag();\n            set_ang();\n        }\n        else if (form == POL)\n        {\n            mag = n1;\n            ang = n2 / Rad_to_deg;\n            set_x();\n            set_y();\n        }\n        else\n        {\n            cout &lt;&lt; \"Incorrect 3rd argument to Vector() -- \";\n            cout &lt;&lt; \"vector set to 0\\n\";\n            x = y = mag = ang = 0.0;\n            mode = RECT;\n        }\n    }\n\n    // reset vector from rectangular coordinates if form is\n    // RECT (the default) or else from polar coordinates if\n    // form is POL\n    void Vector::reset(double n1, double n2, Mode form)\n    {\n        mode = form;\n        if (form == RECT)\n        {\n            x = n1;\n            y = n2;\n            set_mag();\n            set_ang();\n        }\n        else if (form == POL)\n        {\n            mag = n1;\n            ang = n2 / Rad_to_deg;\n            set_x();\n            set_y();\n        }\n        else\n        {\n            cout &lt;&lt; \"Incorrect 3rd argument to Vector() -- \";\n            cout &lt;&lt; \"vector set to 0\\n\";\n            x = y = mag = ang = 0.0;\n            mode = RECT;\n        }\n    }\n\n    Vector::~Vector() // destructor\n    {\n    }\n\n    void Vector::polar_mode() // set to polar mode\n    {\n        mode = POL;\n    }\n\n    void Vector::rect_mode() // set to rectangular mode\n    {\n        mode = RECT;\n    }\n\n    // operator overloading\n    // add two Vectors\n    Vector Vector::operator+(const Vector &amp;b) const\n    {\n        return Vector(x + b.x, y + b.y);\n    }\n\n    // subtract Vector b from a\n    Vector Vector::operator-(const Vector &amp;b) const\n    {\n        return Vector(x - b.x, y - b.y);\n    }\n\n    // reverse sign of Vector\n    Vector Vector::operator-() const\n    {\n        return Vector(-x, -y);\n    }\n\n    // multiply vector by n\n    Vector Vector::operator*(double n) const\n    {\n        return Vector(n * x, n * y);\n    }\n\n    // friend methods\n    // multiply n by Vector a\n    Vector operator*(double n, const Vector &amp;a)\n    {\n        return a * n;\n    }\n\n    // display rectangular coordinates if mode is RECT,\n    // else display polar coordinates if mode is POL\n    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Vector &amp;v)\n    {\n        if (v.mode == Vector::RECT)\n            os &lt;&lt; \"(x,y) = (\" &lt;&lt; v.x &lt;&lt; \", \" &lt;&lt; v.y &lt;&lt; \")\";\n        else if (v.mode == Vector::POL)\n        {\n            os &lt;&lt; \"(m,a) = (\" &lt;&lt; v.mag &lt;&lt; \", \"\n               &lt;&lt; v.ang * Rad_to_deg &lt;&lt; \")\";\n        }\n        else\n            os &lt;&lt; \"Vector object mode is invalid\";\n        return os;\n    }\n} // end namespace VECTOR\n</code></pre> <p>2 - Modify the <code>Vector</code> class header and implementation files (Listings 11.13 and 11.14) so that the magnitude and angle are no longer stored as data components. Instead, they should be calculated on demand when the <code>magval()</code> and <code>angval()</code> methods are called. You should leave the public interface unchanged (the same public methods with the same arguments) but alter the private section, including some of the private method and the method implementations. Test the modified version with Listing 11.15, which should be left unchanged because the public interface of the <code>Vector</code> class is unchanged.</p> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt; // rand(), srand() prototypes\n#include &lt;ctime&gt;   // time() prototype\n#include \"ch11_2_vect.h\"\n\n#include &lt;fstream&gt;\n\nint main()\n{\n    using namespace std;\n    using VECTOR::Vector;\n    srand(time(0)); // seed random-number generator\n    double direction;\n\n    Vector step;\n    Vector result(0.0, 0.0);\n\n    unsigned long steps = 0;\n    double target;\n    double dstep;\n\n    // File handling\n    ofstream outFile;\n    outFile.open(\"./ch11_2_randwalk.txt\");\n\n    if (!outFile.is_open())\n    {\n        cout &lt;&lt; \"Could not open file\" &lt;&lt; endl;\n        cout &lt;&lt; \"Terminate program\" &lt;&lt; endl;\n        exit(EXIT_FAILURE);\n    }\n\n    cout &lt;&lt; \"Enter target distance (q to quit): \";\n    while (cin &gt;&gt; target)\n    {\n        cout &lt;&lt; \"Enter step length: \";\n        if (!(cin &gt;&gt; dstep))\n            break;\n\n        // Write initial conditions to file\n        if (outFile.good())\n        {\n            outFile &lt;&lt; \"Target Distance: \" &lt;&lt; target;\n            outFile &lt;&lt; \", Step Size: \" &lt;&lt; dstep &lt;&lt; endl;\n        }\n\n        while (result.magval() &lt; target)\n        {\n            direction = rand() % 360;\n            step.reset(dstep, direction, Vector::POL);\n            result = result + step;\n\n            if (outFile.good())\n                outFile &lt;&lt; steps &lt;&lt; \": (x,y) = (\" &lt;&lt; result.xval() &lt;&lt; \", \" &lt;&lt; result.yval() &lt;&lt; \")\" &lt;&lt; endl;\n\n            steps++;\n        }\n        cout &lt;&lt; \"After \" &lt;&lt; steps &lt;&lt; \n                \" steps, the subject has the following location:\\n\";\n        cout &lt;&lt; result &lt;&lt; endl;\n\n        if (outFile.good())\n        {\n            outFile &lt;&lt; \"After \" &lt;&lt; steps &lt;&lt; \n            \" steps, the subject has the following location:\\n\" &lt;&lt;\n            result &lt;&lt; endl;\n        }\n\n        result.polar_mode();\n        cout &lt;&lt; \" or\\n\"\n             &lt;&lt; result &lt;&lt; endl;\n        cout &lt;&lt; \"Average outward distance per step = \"\n             &lt;&lt; result.magval() / steps &lt;&lt; endl;\n\n        if (outFile.good())\n        {\n            outFile &lt;&lt; \" or\\n\" &lt;&lt; result &lt;&lt; endl;\n            outFile &lt;&lt; \"Average outward distance per step = \" &lt;&lt;\n            result.magval() / steps &lt;&lt; endl;\n        }\n\n        steps = 0;\n        result.reset(0.0, 0.0);\n        cout &lt;&lt; \"Enter target distance (q to quit): \";\n    }\n    cout &lt;&lt; \"Bye!\\n\";\n    cin.clear();\n    while (cin.get() != '\\n')\n        continue;\n    return 0;\n}\n\n/*\nModify the &lt;code&gt;Vector&lt;/code&gt; class header and implementation files (Listings 11.13 and 11.14)\nso that the magnitude and angle are no longer stored as data components. Instead,\nthey should be calculated on demand when the &lt;code&gt;magval()&lt;/code&gt; and &lt;code&gt;angval()&lt;/code&gt; methods\nare called. You should leave the public interface unchanged (the same public methods\nwith the same arguments) but alter the private section, including some of the\nprivate method and the method implementations. Test the modified version with\nListing 11.15, which should be left unchanged because the public interface of the\n&lt;code&gt;Vector&lt;/code&gt; class is unchanged.\n*/\n</code></pre> Code - prototypes [Test with ch11_2_base.cpp] <pre><code>// vect.h -- Vector class with &lt;&lt;, mode state\n#ifndef VECTOR_H_\n#define VECTOR_H_\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nnamespace VECTOR\n{\n    class Vector\n    {\n    public:\n        enum Mode\n        {\n            RECT,\n            POL\n        };\n        // RECT for rectangular, POL for Polar modes\n    private:\n        double x;   // horizontal value\n        double y;   // vertical value\n        Mode mode;  // RECT or POL\n        // private methods for setting values\n        void set_x();\n        void set_y();\n\n    public:\n        Vector();\n        Vector(double n1, double n2, Mode form = RECT);\n        void reset(double n1, double n2, Mode form = RECT);\n        ~Vector();\n        double xval() const { return x; }     // report x value\n        double yval() const { return y; }     // report y value\n        double magval() const { return std::sqrt(x * x + y * y); } // report magnitude\n        double angval() const { return ((x == 0.0 &amp;&amp; y == 0.0) ? 0.0 : std::atan2(y, x)); } // report angle\n        void polar_mode();                    // set mode to POL\n        void rect_mode();                     // set mode to RECT\n        // operator overloading\n        Vector operator+(const Vector &amp;b) const;\n        Vector operator-(const Vector &amp;b) const;\n        Vector operator-() const;\n        Vector operator*(double n) const;\n        // friends\n        friend Vector operator*(double n, const Vector &amp;a);\n        friend std::ostream &amp;\n        operator&lt;&lt;(std::ostream &amp;os, const Vector &amp;v);\n    };\n} // end namespace VECTOR\n#endif\n</code></pre> Code - methods <pre><code>// vect.cpp -- methods for the Vector class\n#include \"ch11_2_vect.h\" // includes &lt;iostream&gt;\n\nusing std::atan;\nusing std::atan2;\nusing std::cos;\nusing std::cout;\nusing std::sin;\nusing std::sqrt;\n\nnamespace VECTOR\n{\n    // compute degrees in one radian\n    const double Rad_to_deg = 45.0 / atan(1.0);\n\n    // should be about 57.2957795130823\n    // private methods\n    // calculates magnitude from x and y\n    // void Vector::set_mag()\n    // {\n    //     mag = sqrt(x * x + y * y);\n    // }\n\n    // void Vector::set_ang()\n    // {\n    //     if (x == 0.0 &amp;&amp; y == 0.0)\n    //         ang = 0.0;\n    //     else\n    //         ang = atan2(y, x);\n    // }\n\n\n\n    // set x from polar coordinate\n    void Vector::set_x()\n    {\n        x = sqrt(x * x + y * y) * cos((x == 0.0 &amp;&amp; y == 0.0) ? (0.0) : atan2(y, x));\n    }\n\n    // set y from polar coordinate\n    void Vector::set_y()\n    {\n        y = sqrt(x * x + y * y) * sin((x == 0.0 &amp;&amp; y == 0.0) ? (0.0) : atan2(y, x));\n    }\n\n    // public methods\n    Vector::Vector() // default constructor\n    {\n        x = y = 0.0;\n        mode = RECT;\n    }\n\n    // construct vector from rectangular coordinates if form is r\n    // (the default) or else from polar coordinates if form is p\n    Vector::Vector(double n1, double n2, Mode form)\n    {\n        mode = form;\n        if (form == RECT)\n        {\n            x = n1;\n            y = n2;\n            // set_mag();\n            // set_ang();\n        }\n        else if (form == POL)\n        {\n            // sqrt(x * x + y * y) = n1;\n            // (x == 0.0 &amp;&amp; y == 0.0) ? (0.0) : atan2(y, x) = n2 / Rad_to_deg;\n\n            x = n1 * cos(n2 / Rad_to_deg);\n            y = n1 * sin(n2 / Rad_to_deg);\n\n            set_x();\n            set_y();\n        }\n        else\n        {\n            cout &lt;&lt; \"Incorrect 3rd argument to Vector() -- \";\n            cout &lt;&lt; \"vector set to 0\\n\";\n            x = y = 0.0;\n            mode = RECT;\n        }\n    }\n\n    // reset vector from rectangular coordinates if form is\n    // RECT (the default) or else from polar coordinates if\n    // form is POL\n    void Vector::reset(double n1, double n2, Mode form)\n    {\n        mode = form;\n        if (form == RECT)\n        {\n            x = n1;\n            y = n2;\n            // set_mag();\n            // set_ang();\n        }\n        else if (form == POL)\n        {\n            // sqrt(x * x + y * y) = n1;\n            // (x == 0.0 &amp;&amp; y == 0.0) ? (0.0) : atan2(y, x) = n2 / Rad_to_deg;\n\n            //\n            //Both options are essentially doing the same thing, which is converting\n            //the angle from degrees to radians and then using it in the cosine function. The difference is just in the way they are written.\n\n            // 1.\n            // double theta = n2 * (3.14159265 / Rad_to_deg);\n            // x = n1 * cos(theta);\n            // y = n1 * sin(theta);\n\n            // 2. \n            // x = n1 * cos(n2 / Rad_to_deg);\n            // y = n1 * sin(n2 / Rad_to_deg);\n\n            x = n1 * cos(n2 / Rad_to_deg);\n            y = n1 * sin(n2 / Rad_to_deg);\n\n            set_x();\n            set_y();\n        }\n        else\n        {\n            cout &lt;&lt; \"Incorrect 3rd argument to Vector() -- \";\n            cout &lt;&lt; \"vector set to 0\\n\";\n            x = y = 0.0;\n            mode = RECT;\n        }\n    }\n\n    Vector::~Vector() // destructor\n    {\n    }\n\n    void Vector::polar_mode() // set to polar mode\n    {\n        mode = POL;\n    }\n\n    void Vector::rect_mode() // set to rectangular mode\n    {\n        mode = RECT;\n    }\n\n    // operator overloading\n    // add two Vectors\n    Vector Vector::operator+(const Vector &amp;b) const\n    {\n        return Vector(x + b.x, y + b.y);\n    }\n\n    // subtract Vector b from a\n    Vector Vector::operator-(const Vector &amp;b) const\n    {\n        return Vector(x - b.x, y - b.y);\n    }\n\n    // reverse sign of Vector\n    Vector Vector::operator-() const\n    {\n        return Vector(-x, -y);\n    }\n\n    // multiply vector by n\n    Vector Vector::operator*(double n) const\n    {\n        return Vector(n * x, n * y);\n    }\n\n    // friend methods\n    // multiply n by Vector a\n    Vector operator*(double n, const Vector &amp;a)\n    {\n        return a * n;\n    }\n\n    // display rectangular coordinates if mode is RECT,\n    // else display polar coordinates if mode is POL\n    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Vector &amp;v)\n    {\n        if (v.mode == Vector::RECT)\n            os &lt;&lt; \"(x,y) = (\" &lt;&lt; v.x &lt;&lt; \", \" &lt;&lt; v.y &lt;&lt; \")\";\n        else if (v.mode == Vector::POL)\n        {\n            os &lt;&lt; \"(m,a) = (\" &lt;&lt; sqrt(v.x * v.x + v.y * v.y) &lt;&lt; \", \"\n               &lt;&lt; ((v.x == 0.0 &amp;&amp; v.y == 0.0) ? (0.0) : atan2(v.y, v.x)) * Rad_to_deg &lt;&lt; \")\";\n        }\n        else\n            os &lt;&lt; \"Vector object mode is invalid\";\n        return os;\n    }\n} // end namespace VECTOR\n</code></pre> <p>3 - Modify Listing 11.15 (randwalk.cpp) so that instead of reporting the results of a single trial for a particular target/step combination, it reports the highest, lowest, and average number of steps for N trials, where N is an integer entered by the user.</p> Code <pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt; // rand(), srand() prototypes\n#include &lt;ctime&gt;   // time() prototype\n#include \"ch11_3_vect.h\"\n\n#include &lt;fstream&gt;\n\n// struct for highest, lowest, and average number of steps for trials\nstruct trialsData{\n    int iNumTrials;\n    double dMax;\n    double dMin;\n    double dAvg;\n};\n\nint main()\n{\n    using namespace std;\n    using VECTOR::Vector;\n    srand(time(0)); // seed random-number generator\n    double direction;\n\n    Vector step;\n    Vector prevStep;\n    Vector result(0.0, 0.0);\n\n    unsigned long steps = 0;\n    double target;\n    double dstep;\n\n    double dTmpMin;\n    double dTmpMax;\n\n    trialsData tData;\n    tData.dMax = 0;\n    tData.dMin = 0;\n    tData.dAvg = 0;\n\n    cout &lt;&lt; \"Enter target distance (q to quit): \";\n    while (cin &gt;&gt; target)\n    {\n        cout &lt;&lt; \"Enter step length: \";\n        if (!(cin &gt;&gt; dstep))\n            break;\n\n        cout &lt;&lt; \"Enter number of trials: \";\n        if (!(cin &gt;&gt; tData.iNumTrials))\n            break;\n\n        for (int i = 0; i &lt; tData.iNumTrials; i++)\n        {\n            while (result.magval() &lt; target)\n            {\n                prevStep = step;\n                direction = rand() % 360;\n                step.reset(dstep, direction, Vector::POL);\n\n                result = result + step;\n                steps++;\n            }\n            cout &lt;&lt; \"After \" &lt;&lt; steps &lt;&lt; \" steps, the subject has the following location:\\n\";\n            cout &lt;&lt; result &lt;&lt; endl;\n\n            result.polar_mode();\n            cout &lt;&lt; \" or\\n\"\n                 &lt;&lt; result &lt;&lt; endl;\n            cout &lt;&lt; \"Average outward distance per step = \"\n                 &lt;&lt; result.magval() / steps &lt;&lt; endl;\n\n            tData.dAvg = tData.dAvg + steps;\n            tData.dMax = tData.dMax &gt; steps ? tData.dMax : steps;\n\n            if(tData.dMin &gt; 0)\n                tData.dMin = tData.dMin &lt; steps ? tData.dMin : steps;\n            else\n                tData.dMin = steps;\n\n            steps = 0;\n            result.reset(0.0, 0.0);\n        }\n\n        tData.dAvg = tData.dAvg / tData.iNumTrials;\n\n        cout &lt;&lt; \"\\n\\nNumber of steps for \" &lt;&lt; tData.iNumTrials &lt;&lt; \" trials:\\n\";\n        cout &lt;&lt; \"\\t Highest:\\t \" &lt;&lt; tData.dMax &lt;&lt; endl;\n        cout &lt;&lt; \"\\t Lowest:\\t \" &lt;&lt; tData.dMin &lt;&lt; endl;\n        cout &lt;&lt; \"\\t Average:\\t \" &lt;&lt; tData.dAvg &lt;&lt; endl &lt;&lt; endl;\n\n        cout &lt;&lt; \"Enter target distance (q to quit): \";\n    }\n    cout &lt;&lt; \"Bye!\\n\";\n    cin.clear();\n    while (cin.get() != '\\n')\n        continue;\n    return 0;\n}\n</code></pre> <p>4 - Rewrite the final <code>Time</code> class example (<code>mytime2.h</code>, <code>mytime2.cpp</code>, and <code>usetime2.cpp</code>) so that all the overloaded operators are implemented using friend functions.</p> Code - prototypes <pre><code>// mytime2.h -- Time class after operator overloading\n#ifndef MYTIME3_H_\n#define MYTIME3_H_\n#include &lt;iostream&gt;\nclass Time\n{\nprivate:\n    int hours;\n    int minutes;\n\npublic:\n    Time();\n    Time(int h, int m = 0);\n    void AddMin(int m);\n    void AddHr(int h);\n    void Reset(int h = 0, int m = 0);\n    friend Time operator+(const Time &amp;t_inp, const Time &amp;t);\n    friend Time operator-(const Time &amp;t_inp, const Time &amp;t);\n    friend Time operator*(double mult, const Time &amp;t);\n    friend Time operator*(const Time &amp;t,double mult){\n        return mult*t;\n    }\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Time &amp;t);\n};\n#endif\n</code></pre> Code - methods <pre><code>// mytime1.cpp -- implementing Time methods\n#include &lt;iostream&gt;\n#include \"ch11_4_time.h\"\n\nTime::Time()\n{\n    hours = minutes = 0;\n}\n\nTime::Time(int h, int m)\n{\n    hours = h;\n    minutes = m;\n}\n\nvoid Time::AddMin(int m)\n{\n    minutes += m;\n    hours += minutes / 60;\n    minutes %= 60;\n}\n\nvoid Time::AddHr(int h)\n{\n    hours += h;\n}\n\nvoid Time::Reset(int h, int m)\n{\n    hours = h;\n    minutes = m;\n}\n\nTime operator+(const Time &amp;t_inp, const Time &amp;t)\n{\n    Time sum;\n    sum.minutes = t_inp.minutes + t.minutes;\n    sum.hours = t_inp.hours + t.hours + sum.minutes / 60;\n    sum.minutes %= 60;\n    return sum;\n}\n\nTime operator-(const Time &amp;t_inp, const Time &amp;t)\n{\n    Time diff;\n    int tot1, tot2;\n    tot1 = t.minutes + 60 * t.hours;\n    tot2 = t_inp.minutes + 60 * t_inp.hours;\n    diff.minutes = (tot2 - tot1) % 60;\n    diff.hours = (tot2 - tot1) / 60;\n    return diff;\n}\n\nTime operator*(double mult, const Time &amp;t)\n{\n    Time result;\n    long totalminutes = t.hours * mult * 60 + t.minutes * mult;\n    result.hours = totalminutes / 60;\n    result.minutes = totalminutes % 60;\n    return result;\n}\n\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Time &amp;t)\n{\n    os &lt;&lt; t.hours &lt;&lt; \" hours, \" &lt;&lt; t.minutes &lt;&lt; \" minutes\";\n    return os;\n}\n</code></pre> Code - program <pre><code>// usetime3.cpp -- using the fourth draft of the Time class\n//  compile usetime3.cpp and mytime3.cpp together\n#include &lt;iostream&gt;\n#include \"ch11_4_time.h\"\n\nint main()\n{\n    using std::cout;\n    using std::endl;\n    Time aida(3, 35);\n    Time tosca(2, 48);\n    Time temp;\n    cout &lt;&lt; \"Aida and Tosca:\\n\";\n    cout &lt;&lt; aida &lt;&lt; \"; \" &lt;&lt; tosca &lt;&lt; endl;\n    temp = aida + tosca; // operator+()\n    cout &lt;&lt; \"Aida + Tosca: \" &lt;&lt; temp &lt;&lt; endl;\n    temp = aida - tosca; // operator+()\n    cout &lt;&lt; \"Aida - Tosca: \" &lt;&lt; temp &lt;&lt; endl;\n    temp = aida * 1.17; // member operator*()\n    cout &lt;&lt; \"Aida * 1.17: \" &lt;&lt; temp &lt;&lt; endl;\n    cout &lt;&lt; \"10.0 * Tosca: \" &lt;&lt; 10.0 * tosca &lt;&lt; endl;\n    return 0;\n}\n\n/*\nAida and Tosca:\n3 hours, 35 minutes; 2 hours, 48 minutes\nAida + Tosca: 6 hours, 23 minutes\nAida * 1.17: 4 hours, 11 minutes\n10.0 * Tosca: 28 hours, 0 minutes\n*/\n</code></pre> <p>5 - Rewrite the <code>Stonewt</code> class (<code>stonewt.h</code> and <code>stonewt.cpp</code>) so that it has a <code>state member</code> that governs whether the object is interpreted in stone form, integer pounds form, or floating-point pounds form. Overload the <code>&lt;&lt;</code> operator to replace the <code>show_stn()</code> and <code>show_lbs()</code> methods. Overload the addition, subtraction, and multiplication operators so that one can add, subtract, and multiply <code>Stonewt</code> values. Test your class with a short program that uses all the class methods and friends.</p> Code - program <pre><code>// stone.cpp -- user-defined conversions\n#include &lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n#include \"ch11_5_stone.h\"\nvoid display(const Stonewt &amp;st, int n);\nint main()\n{\n    Stonewt incognito = 275; // uses constructor to initialize\n    Stonewt wolfe(285.7);    // same as Stonewt wolfe = 285.7;\n    Stonewt taft(21, 8);\n\n    Stonewt informalStone(30, Stonewt::Mode::STONE);\n    Stonewt formalStone(60.5, Stonewt::Mode::STONE);\n    Stonewt stupidPound(90.5, Stonewt::Mode::POUND);\n    Stonewt formalPound(120.5, Stonewt::Mode::POUND_FP);\n\n    cout &lt;&lt; \"informal Stone weight: \"\n        &lt;&lt; informalStone &lt;&lt; endl;\n    cout &lt;&lt; \"formal Stone weight: \"\n        &lt;&lt; formalStone &lt;&lt; endl;\n    cout &lt;&lt; \"stupid Pound weight: \"\n        &lt;&lt; stupidPound &lt;&lt; endl;\n    stupidPound.changeMode(Stonewt::Mode::STONE);\n    cout &lt;&lt; \"stupid Pound weight: \"\n        &lt;&lt; stupidPound &lt;&lt; endl;\n    cout &lt;&lt; \"formal Pound weight: \"\n        &lt;&lt; formalPound &lt;&lt; endl;\n\n    Stonewt addedStone(0, Stonewt::Mode::STONE);\n    addedStone = formalPound + stupidPound;\n    cout &lt;&lt; \"Formal pound + stupid pound = \"\n        &lt;&lt; addedStone &lt;&lt; endl;\n\n    addedStone = formalPound - stupidPound;\n    cout &lt;&lt; \"Formal pound - stupid pound = \"\n        &lt;&lt; addedStone &lt;&lt; endl;\n\n    addedStone = formalPound * stupidPound;\n    cout &lt;&lt; \"Formal pound * stupid pound = \"\n        &lt;&lt; addedStone &lt;&lt; endl;\n\n    // cout &lt;&lt; \"The celebrity weighed \";\n    // incognito.show_stn();\n    // cout &lt;&lt; \"The detective weighed \";\n    // wolfe.show_stn();\n    // cout &lt;&lt; \"The President weighed \";\n    // taft.show_lbs();\n    // incognito = 276.8; // uses constructor for conversion\n    // taft = 325;        // same as taft = Stonewt(325);\n    // cout &lt;&lt; \"After dinner, the celebrity weighed \";\n    // incognito.show_stn();\n    // cout &lt;&lt; \"After dinner, the President weighed \";\n    // taft.show_lbs();\n    // display(taft, 2);\n    // cout &lt;&lt; \"The wrestler weighed even more.\\n\";\n    // display(422, 2);\n    // cout &lt;&lt; \"No stone left unearned\\n\";\n    return 0;\n}\n// void display(const Stonewt &amp;st, int n)\n// {\n//     for (int i = 0; i &lt; n; i++)\n//     {\n//         cout &lt;&lt; \"Wow! \";\n        // st.show_stn();\n//     }\n// }\n\n/*\nThe celebrity weighed 19 stone, 9 pounds\nThe detective weighed 20 stone, 5.7 pounds\nThe President weighed 302 pounds\nAfter dinner, the celebrity weighed 19 stone, 10.8 pounds\nAfter dinner, the President weighed 325 pounds\nWow! 23 stone, 3 pounds\nWow! 23 stone, 3 pounds\nThe wrestler weighed even more.\nWow! 30 stone, 2 pounds\nWow! 30 stone, 2 pounds\nNo stone left unearned\n*/\n</code></pre> Code - Prototypes <pre><code>// stonewt.h -- definition for the Stonewt class\n#ifndef STONEWT_H_\n#define STONEWT_H_\n#include \"ch11_5_stone.h\"\nclass Stonewt\n{\npublic:\n    enum Mode{\n        STONE,\n        POUND,      // integer pounds\n        POUND_FP    // floating-point pounds\n    };\n\nprivate:\n    enum\n    {\n        Lbs_per_stn = 14\n    };               // pounds per stone\n    int stone;       // whole stones\n    double pds_left; // fractional pounds\n    double pounds;   // entire weight in pounds\n    Mode mode;       // Stone, integer pounds or floating-point pounds\npublic:\n    Stonewt(double in, Mode form);// constructor for Stonewt with mode object\n    Stonewt(int in, Mode form) : Stonewt(static_cast&lt;double&gt;(in), form) {};\n\n    Stonewt(double lbs);          // constructor for double pounds\n    Stonewt(int stn, double lbs); // constructor for stone, lbs\n    Stonewt();                    // default constructor\n    ~Stonewt();\n\n    void changeMode(Mode form);\n\n    Stonewt operator+(const Stonewt &amp;s) const;\n    Stonewt operator-(const Stonewt &amp;s) const;\n    Stonewt operator*(const Stonewt &amp;s) const;\n\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Stonewt &amp;stn);\n    // void show_lbs() const; // show weight in pounds format\n    // void show_stn() const; // show weight in stone format\n};\n#endif\n</code></pre> Code - Methods <pre><code>// stonewt.cpp -- Stonewt methods\n#include &lt;iostream&gt;\nusing std::cout;\n#include \"ch11_5_stone.h\"\n\n// construct Stonewt object from double value\nStonewt::Stonewt(double lbs)\n{\n    mode = POUND_FP;\n    stone = int(lbs) / Lbs_per_stn; // integer division\n    pds_left = int(lbs) % Lbs_per_stn + lbs - int(lbs);\n    pounds = lbs;\n}\n\n// construct Stonewt object from stone, double values\nStonewt::Stonewt(int stn, double lbs)\n{\n    mode = STONE;\n    stone = stn;\n    pds_left = lbs;\n    pounds = stn * Lbs_per_stn + lbs;\n}\n\nStonewt::Stonewt(double in, Mode form){\n    mode = form;\n\n    if(STONE == mode){\n        stone = in;\n        pounds = in * Lbs_per_stn;\n        pds_left = int(pounds) % Lbs_per_stn + pounds - int(pounds);\n    }\n    else if(POUND_FP == mode || POUND == mode){\n        pounds = in;\n        stone = pounds / Lbs_per_stn;\n        pds_left = int(pounds) % Lbs_per_stn + pounds - int(pounds);\n    }\n}\n\nStonewt::Stonewt() // default constructor, wt = 0\n{\n    mode = STONE;\n    stone = pounds = pds_left = 0;\n}\n\nStonewt::~Stonewt() // destructor\n{\n}\n\nStonewt Stonewt::operator+(const Stonewt &amp;s) const{\n\n    Stonewt temp;\n\n    temp.pounds = pounds + s.pounds;\n    temp.stone = int(temp.pounds) / Lbs_per_stn;\n    temp.pds_left = int(pounds + s.pounds) % Lbs_per_stn + (pds_left + s.pds_left) - int(pds_left + s.pds_left);\n\n    return temp;\n}\n\nStonewt Stonewt::operator-(const Stonewt &amp;s) const{\n\n    Stonewt temp;\n\n    temp.pounds = pounds - s.pounds;\n    temp.stone = int(temp.pounds) / Lbs_per_stn;\n    temp.pds_left = int(temp.pounds) % Lbs_per_stn + temp.pounds - int(temp.pounds);\n\n    return temp;\n}\n\nStonewt Stonewt::operator*(const Stonewt &amp;s) const{\n\n    Stonewt temp;\n\n    temp.pounds = pounds * s.pounds;\n    temp.stone = int(temp.pounds) / Lbs_per_stn;\n    temp.pds_left = int(temp.pounds) % Lbs_per_stn + temp.pounds - int(temp.pounds);\n\n    return temp;\n}\n\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Stonewt &amp;s){\n    if(s.STONE == s.mode)\n        os &lt;&lt; s.stone &lt;&lt; \" stone, \" &lt;&lt; s.pds_left &lt;&lt; \" pounds\";\n    else if(s.POUND == s.mode)\n        os &lt;&lt; int(s.pounds) &lt;&lt; \" pounds\";\n    else if(s.POUND_FP == s.mode)\n        os &lt;&lt; s.pounds &lt;&lt; \" pounds\";\n\n    return os;\n}\n\n\n// // show weight in stones\n// void Stonewt::show_stn() const\n// {\n//     cout &lt;&lt; stone &lt;&lt; \" stone, \" &lt;&lt; pds_left &lt;&lt; \" pounds\\n\";\n// }\n\n// // show weight in pounds\n// void Stonewt::show_lbs() const\n// {\n//     cout &lt;&lt; pounds &lt;&lt; \" pounds\\n\";\n// }\n\nvoid Stonewt::changeMode(Mode form){\n    mode = form;\n}\n</code></pre> <p>6 - Rewrite the <code>Stonewt</code> class (<code>stonewt.h</code> and <code>stonewt.cpp</code>) so that it overloads all six relational operators (&gt;, &gt;=, ==, &lt;=, &lt;, and != ). The operators should compare the pounds members and return a type <code>bool</code> value. Write a program that declares an array of six <code>Stonewt</code> objects and initializes the first three objects in the array declaration. Then it should use a loop to read in values used to set the remaining three array elements. Then it should report the smallest element, the largest element, and how many elements are greater or equal to 11 stone. (The simplest approach is to create a <code>Stonewt</code> object initialized to 11 stone and to compare the other objects with that object.)</p> Code - Program <pre><code>// stone1.cpp -- user-defined conversion functions\n// compile with stonewt1.cpp\n#include &lt;iostream&gt;\n#include \"ch11_6_stone.h\"\n\nint main()\n{\n    using std::cout;\n    using std::endl;\n    Stonewt poppins(9, 2.8); // 9 stone, 2.8 pounds\n    double p_wt = poppins;   // implicit conversion\n\n    Stonewt wolfe(285.7); // same as Stonewt wolfe = 285.7;\n    Stonewt tafte(21, 8);\n    Stonewt glock(21, 8);\n\n    cout &lt;&lt; \"Convert to double =&gt; \";\n    cout &lt;&lt; \"Poppins: \" &lt;&lt; p_wt &lt;&lt; \" pounds.\\n\";\n    cout &lt;&lt; \"Convert to int =&gt; \";\n    cout &lt;&lt; \"Poppins: \" &lt;&lt; int(poppins) &lt;&lt; \" pounds.\\n\\n\";\n\n    cout &lt;&lt; \"Wolfe weight: \" &lt;&lt; wolfe &lt;&lt; endl;\n    cout &lt;&lt; \"Tafte weight: \" &lt;&lt; tafte &lt;&lt; endl;\n    cout &lt;&lt; \"glock weight: \" &lt;&lt; glock &lt;&lt; endl;\n    cout &lt;&lt; endl;\n\n    std::cout &lt;&lt; std::boolalpha;\n    cout &lt;&lt; \"Is Wolfe &gt; Tafte?:  \" &lt;&lt; (wolfe &gt; tafte) &lt;&lt; endl;    \n    cout &lt;&lt; \"Is Wolfe &lt; Tafte?:  \" &lt;&lt; (wolfe &lt; tafte) &lt;&lt; endl;    \n    cout &lt;&lt; \"Is Wolfe &gt;= Tafte?: \" &lt;&lt; (wolfe &gt;= tafte) &lt;&lt; endl;    \n    cout &lt;&lt; \"Is Wolfe &lt;= Tafte?: \" &lt;&lt; (wolfe &lt;= tafte) &lt;&lt; endl;    \n    cout &lt;&lt; \"Is Wolfe == Tafte?: \" &lt;&lt; (wolfe == tafte) &lt;&lt; endl;    \n    cout &lt;&lt; \"Is Wolfe != Tafte?: \" &lt;&lt; (wolfe != tafte) &lt;&lt; endl;\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; \"Is glock &gt; Tafte?:  \" &lt;&lt; (glock &gt; tafte) &lt;&lt; endl;    \n    cout &lt;&lt; \"Is glock &lt; Tafte?:  \" &lt;&lt; (glock &lt; tafte) &lt;&lt; endl;    \n    cout &lt;&lt; \"Is glock &gt;= Tafte?: \" &lt;&lt; (glock &gt;= tafte) &lt;&lt; endl;    \n    cout &lt;&lt; \"Is glock &lt;= Tafte?: \" &lt;&lt; (glock &lt;= tafte) &lt;&lt; endl;    \n    cout &lt;&lt; \"Is glock == Tafte?: \" &lt;&lt; (glock == tafte) &lt;&lt; endl;    \n    cout &lt;&lt; \"Is glock != Tafte?: \" &lt;&lt; (glock != tafte) &lt;&lt; endl;\n    cout &lt;&lt; endl;\n    std::cout &lt;&lt; std::noboolalpha;\n\n    return 0;\n}\n</code></pre> Code - Prototypes <pre><code>// stonewt1.h -- revised definition for the Stonewt class\n#ifndef STONEWT1_H_\n#define STONEWT1_H_\n#include &lt;iostream&gt;\n\nclass Stonewt\n{\nprivate:\n    enum\n    {\n        Lbs_per_stn = 14\n    };               // pounds per stone\n    int stone;       // whole stones\n    double pds_left; // fractional pounds\n    double pounds;   // entire weight in pounds\npublic:\n    Stonewt(double lbs);          // construct from double pounds\n    Stonewt(int stn, double lbs); // construct from stone, lbs\n    Stonewt();                    // default constructor\n    ~Stonewt();\n    void show_lbs() const; // show weight in pounds format\n    void show_stn() const; // show weight in stone format\n    // conversion functions\n    operator int() const;\n    operator double() const;\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Stonewt &amp;stn);\n\n    inline bool operator&gt;(const Stonewt &amp;s) const\n    {\n        return (pounds &gt; s.pounds) ? true : false;\n    }\n\n    inline bool operator&lt;(const Stonewt &amp;s) const\n    {\n        return (pounds &lt; s.pounds) ? true : false;\n    }\n\n    inline bool operator&gt;=(const Stonewt &amp;s) const\n    {\n        return (pounds &gt;= s.pounds) ? true : false;\n    }\n\n    inline bool operator&lt;=(const Stonewt &amp;s) const\n    {\n        return (pounds &lt;= s.pounds) ? true : false;\n    }\n\n    inline bool operator==(const Stonewt &amp;s) const\n    {\n        return (pounds == s.pounds) ? true : false;\n    }\n\n    inline bool operator!=(const Stonewt &amp;s) const\n    {\n        return (pounds != s.pounds) ? true : false;\n    }\n\n};\n#endif\n</code></pre> Code - Methods <pre><code>// stonewt1.cpp -- Stonewt class methods + conversion functions\nusing std::cout;\n#include \"ch11_6_stone.h\"\n\n// construct Stonewt object from double value\nStonewt::Stonewt(double lbs)\n{\n    stone = int(lbs) / Lbs_per_stn; // integer division\n    pds_left = int(lbs) % Lbs_per_stn + lbs - int(lbs);\n    pounds = lbs;\n}\n\n// construct Stonewt object from stone, double values\nStonewt::Stonewt(int stn, double lbs)\n{\n    stone = stn;\n    pds_left = lbs;\n    pounds = stn * Lbs_per_stn + lbs;\n}\n\nStonewt::Stonewt() // default constructor, wt = 0\n{\n    stone = pounds = pds_left = 0;\n}\n\nStonewt::~Stonewt() // destructor\n{\n}\n\n// show weight in stones\nvoid Stonewt::show_stn() const\n{\n    cout &lt;&lt; stone &lt;&lt; \" stone, \" &lt;&lt; pds_left &lt;&lt; \" pounds\\n\";\n}\n\n// show weight in pounds\nvoid Stonewt::show_lbs() const\n{\n    cout &lt;&lt; pounds &lt;&lt; \" pounds\\n\";\n}\n\n// conversion functions\nStonewt::operator int() const\n{\n    return int(pounds + 0.5);\n}\n\nStonewt::operator double() const\n{\n    return pounds;\n}\n\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Stonewt &amp;s){\n    os &lt;&lt; s.stone &lt;&lt; \" stone, \" &lt;&lt; s.pds_left &lt;&lt; \" pounds\";\n    return os;\n}\n</code></pre> <p>7 -</p> <p>A complex number has two parts: a <code>real part</code> and an <code>imaginary part</code>. One way to write an imaginary number is this: <code>(3.0, 4.0)</code>. Here 3.0 is the real part and 4.0 is the <code>imaginary part</code>. Suppose <code>a = (A,Bi)</code> and <code>c = (C,Di)</code>. Here are some complex operations:</p> <ul> <li>Addition: <code>a + c = (A + C, (B + D)i)</code></li> <li>Subtraction: <code>a - c = (A - C, (B - D)i)</code></li> <li>Multiplication: <code>a \u00d7 c = (A \u00d7 C - B\u00d7D, (A\u00d7D + B\u00d7C)i)</code></li> <li>Multiplication: <code>(x a real number): x \u00d7 c = (x\u00d7C,x\u00d7Di)</code></li> <li>Conjugation: <code>~a = (A, - Bi)</code></li> </ul> <p>Define a complex class so that the following program can use it with correct results:</p> <pre><code>#include &lt;iostream&gt;\n#include \"complex0.h\" // to avoid confusion with complex.h\n\nusing namespace std;\nint main()\n{\n    complex a(3.0, 4.0); // initialize to (3,4i)\n    complex c;\n    cout &lt;&lt; \"Enter a complex number (q to quit):\\n\";\n    while (cin &gt;&gt; c)\n    {\n        cout &lt;&lt; \"c is \" &lt;&lt; c &lt;&lt; '\\n';\n        cout &lt;&lt; \"complex conjugate is \" &lt;&lt; ~c &lt;&lt; '\\n';\n        cout &lt;&lt; \"a is \" &lt;&lt; a &lt;&lt; '\\n';\n        cout &lt;&lt; \"a + c is \" &lt;&lt; a + c &lt;&lt; '\\n';\n        cout &lt;&lt; \"a - c is \" &lt;&lt; a - c &lt;&lt; '\\n';\n        cout &lt;&lt; \"a * c is \" &lt;&lt; a * c &lt;&lt; '\\n';\n        cout &lt;&lt; \"2 * c is \" &lt;&lt; 2 * c &lt;&lt; '\\n';\n        cout &lt;&lt; \"Enter a complex number (q to quit):\\n\";\n    }\n    cout &lt;&lt; \"Done!\\n\";\n    return 0;\n}\n</code></pre> <p>Note that you have to overload the <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators. Standard C++ already has complex support \u2014 rather more extensive than in this example \u2014 in a complex header file, so use <code>complex0.h</code> to avoid conflicts. Use <code>const</code> whenever warranted.</p> <p>Here is a sample run of the program:</p> <pre><code>Enter a complex number (q to quit):\nreal: 10\nimaginary: 12\nc is (10,12i)\ncomplex conjugate is (10,-12i)\na is (3,4i)\na + c is (13,16i)\na - c is (-7,-8i)\na * c is (-18,76i)\n2 * c is (20,24i)\nEnter a complex number (q to quit):\nreal: q\nDone!\n</code></pre> Code - Program <pre><code>#include &lt;iostream&gt;\n#include \"ch11_7_complex.h\" // to avoid confusion with complex.h\n\nusing namespace std;\nint main()\n{\n    complex a(3.0, 4.0); // initialize to (3,4i)\n    complex c;\n    cout &lt;&lt; \"Enter a complex number (q to quit):\\n\";\n    while (cin &gt;&gt; c)\n    {\n        cout &lt;&lt; \"c is \" &lt;&lt; c &lt;&lt; '\\n';\n        cout &lt;&lt; \"complex conjugate is \" &lt;&lt; ~c &lt;&lt; '\\n';\n        cout &lt;&lt; \"a is \" &lt;&lt; a &lt;&lt; '\\n';\n        cout &lt;&lt; \"a + c is \" &lt;&lt; a + c &lt;&lt; '\\n';\n        cout &lt;&lt; \"a - c is \" &lt;&lt; a - c &lt;&lt; '\\n';\n        cout &lt;&lt; \"a * c is \" &lt;&lt; a * c &lt;&lt; '\\n';\n        cout &lt;&lt; \"2 * c is \" &lt;&lt; 2 * c &lt;&lt; '\\n';\n        cout &lt;&lt; \"Enter a complex number (q to quit):\\n\";\n    }\n    cout &lt;&lt; \"Done!\\n\";\n    return 0;\n}\n</code></pre> Code - Prototypes <pre><code>#ifndef _COMPLEX_H_\n#define _COMPLEX_H_\n#include &lt;iostream&gt;\nclass complex\n{\nprivate:\n    double rNum; // real number\n    double iNum; // imaginary number\n\npublic:\n    complex();\n    complex(double r, double i);\n    ~complex();\n\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const complex&amp; c);\n    friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, complex&amp; c);\n    complex operator+(const complex&amp; c) const;\n    complex operator-(const complex&amp; c) const;\n    complex operator~() const;\n    complex operator*(const complex&amp; c) const;\n    complex operator*(const double c) const;\n    friend complex operator*(const int num, const complex&amp; c) {\n        return c * double(num);\n    }\n\n};\n\n#endif\n</code></pre> Code - Methods <pre><code>#include \"ch11_7_complex.h\"\n\ncomplex::complex()\n{\n    rNum = 0;\n    iNum = 0;\n}\n\ncomplex::complex(double r, double i)\n{\n    rNum = r;\n    iNum = i;\n}\n\ncomplex::~complex()\n{\n}\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const complex&amp; c){\n    os &lt;&lt; \"(\" &lt;&lt; c.rNum &lt;&lt; \",\" &lt;&lt; c.iNum &lt;&lt; \"i)\";\n    return os;\n}\n\nstd::istream&amp; operator&gt;&gt;(std::istream&amp; is, complex&amp; c){\n    std::cout &lt;&lt; \"real: \";\n    is &gt;&gt; c.rNum;\n    std::cout &lt;&lt; \"imaginary: \";\n    is &gt;&gt; c.iNum;\n    return is;\n}\n\ncomplex complex::operator+(const complex&amp; c) const{\n    complex temp;\n    temp.rNum = rNum + c.rNum;\n    temp.iNum = iNum + c.iNum;\n    return temp;  \n}\n\ncomplex complex::operator-(const complex&amp; c) const{\n    complex temp;\n    temp.rNum = rNum - c.rNum;\n    temp.iNum = iNum - c.iNum;\n    return temp;  \n}\n\n// (a+bi)(c+di) = (ac\u2212bd) + (ad+bc)i\ncomplex complex::operator*(const complex&amp; c) const{\n    complex temp;\n    temp.rNum = rNum * c.rNum - iNum * c.iNum;\n    temp.iNum = rNum * c.iNum + iNum * c.rNum;\n    return temp;  \n}\n\ncomplex complex::operator*(const double c) const{\n    complex temp;\n    temp.rNum = rNum * c;\n    temp.iNum = iNum * c;\n    return temp;  \n}\n\ncomplex complex::operator~() const{\n    complex temp;\n    temp.rNum = rNum;\n    temp.iNum = iNum * -1;\n    return temp;  \n}\n</code></pre> <p>Note that <code>cin &gt;&gt; c</code>, through overloading, now prompts for real and imaginary parts.</p>"},{"location":"exercises/#chapter-12","title":"Chapter 12","text":"<p>1 - Consider the following class declaration:</p> <pre><code>class Cow\n{\n    char name[20];\n    char *hobby;\n    double weight;\n\npublic:\n    Cow();\n    Cow(const char *nm, const char *ho, double wt);\n    Cow(const Cow c &amp;);\n    Programming Exercises 703 ~Cow();\n    Cow &amp;operator=(const Cow &amp;c);\n    void ShowCow() const; // display all cow data\n};\n</code></pre> <p>Provide the implementation for this class and write a short program that uses all the member functions.</p> Code - Program <pre><code>#include &lt;iostream&gt;\n#include \"ch12_1_cow.h\"\n\nint main(){\n\n    {\n        Cow notMyCow;\n        Cow Mooo(\"Moo\", \"Eat grass\",  253);\n        Cow Boo(\"EmBoo\", \"Scaring cows\", 199);\n\n        Cow myCow = Mooo;\n        Cow initMyCow(Mooo);\n\n        Boo.ShowCow();\n        Mooo.ShowCow();\n        notMyCow.ShowCow();\n        myCow.ShowCow();\n        initMyCow.ShowCow();\n    }\n    return 0;\n}\n</code></pre> Code - Prototypes <pre><code>#ifndef _COW_H_\n#define _COW_H_\n#include &lt;iostream&gt;\n\nclass Cow\n{\n    char name[20];\n    char *hobby;\n    double weight;\n\npublic:\n    Cow();\n    Cow(const char *nm, const char *ho, double wt);\n    Cow(const Cow &amp;c);\n    ~Cow();\n    Cow &amp;operator=(const Cow &amp;c);\n    void ShowCow() const; // display all cow data\n};\n\n#endif\n</code></pre> Code - Methods <pre><code>#include \"ch12_1_cow.h\"\n#include &lt;cstring&gt;\n\nCow::Cow(){\n    name[0] = '\\0';\n    hobby = new char[1];\n    hobby[0] = '\\0';\n    weight = 0;\n}\n\nCow::Cow(const char *nm, const char *ho, double wt){\n    if(std::strlen(nm) &lt; 20)\n        std::strcpy(name, nm);\n    else\n        name[0] = '\\0';\n\n    hobby = new char[std::strlen(ho) + 1];\n    std::strcpy(hobby, ho);\n\n    weight = wt;\n}\n\nCow::Cow(const Cow &amp;c)\n{\n    std::strcpy(name, c.name);\n\n    hobby = new char[std::strlen(c.hobby) + 1];\n    std::strcpy(hobby, c.hobby);\n\n    weight = c.weight;\n}\n\nCow::~Cow()\n{\n    std::cout &lt;&lt; \"\\nDelete: \" &lt;&lt; hobby;\n    delete[] hobby;\n}\n\nCow &amp;Cow::operator=(const Cow &amp;c){\n    if (this == &amp;c)\n        return *this;\n\n    std::strcpy(name, c.name);\n\n    delete[] hobby;\n    hobby = new char[std::strlen(c.hobby) + 1];\n    std::strcpy(hobby, c.hobby);\n\n    weight = c.weight;\n\n    return *this;\n}\n\nvoid Cow::ShowCow() const{\n    std::cout &lt;&lt; \"\\nName: \" &lt;&lt; name;\n    std::cout &lt;&lt; \"\\nHobby: \" &lt;&lt; hobby;\n    std::cout &lt;&lt; \"\\nWeight: \" &lt;&lt; weight;\n}\n</code></pre> <p>2 - Enhance the <code>String</code> class declaration (that is, upgrade <code>string1.h</code> to <code>string2.h</code>) by doing the following:     a. Overload the <code>+</code> operator to allow you to join two strings into one.     b. Provide a <code>stringlow()</code> member function that converts all alphabetic characters     in a string to lowercase. (Don\u2019t forget the cctype family of character functions.)     c. Provide a <code>stringup()</code> member function that converts all alphabetic characters in a string to uppercase.     d. Provide a member function that takes a <code>char</code> argument and returns the number of times the character appears in the string.</p> <p>Test your work in the following program:</p> Code - Program <pre><code>// pe12_2.cpp\n#include &lt;iostream&gt;\nusing namespace std;\n#include \"ch12_2_str.h\"\n\nint main()\n{\n    {\n        String s1(\" and I am a C++ student.\");\n        String s2 = \"Please enter your name: \";\n        String s3;\n        cout &lt;&lt; s2;              // overloaded &lt;&lt; operator\n        cin &gt;&gt; s3;               // overloaded &gt;&gt; operator\n        s2 = \"My name is \" + s3; // overloaded =, + operators\n        cout &lt;&lt; s2 &lt;&lt; \".\\n\";\n        s2 = s2 + s1;\n        s2.stringup(); // converts string to uppercase\n        cout &lt;&lt; \"The string\\n\"\n             &lt;&lt; s2 &lt;&lt; \"\\ncontains \" &lt;&lt; s2.has('A')\n             &lt;&lt; \" 'A' characters in it.\\n\";\n        s1 = \"red\"; // String(const char *),\n        // then String &amp; operator=(const String&amp;)\n        String rgb[3] = {String(s1), String(\"green\"), String(\"blue\")};\n        cout &lt;&lt; \"Enter the name of a primary color for mixing light: \";\n        String ans;\n        bool success = false;\n        while (cin &gt;&gt; ans)\n        {\n            ans.stringlow(); // converts string to lowercase\n            for (int i = 0; i &lt; 3; i++)\n            {\n                if (ans == rgb[i]) // overloaded == operator\n                {\n                    cout &lt;&lt; \"That's right!\\n\";\n                    success = true;\n                    break;\n                }\n            }\n            if (success)\n                break;\n            else\n                cout &lt;&lt; \"Try again!\\n\";\n        }\n        cout &lt;&lt; \"Bye\\n\";\n        return 0;\n    }\n}\n\n/*\nPlease enter your name: Maciej\ndeleted : My name is\ndeleted : My name is Maciej\nMy name is Maciej.\ndeleted : My name is Maciej and I am a C++ student.\nThe string\nMY NAME IS MACIEJ AND I AM A C++ STUDENT.\ncontains 5 'A' characters in it.\nEnter the name of a primary color for mixing light: red\nThat's right!\nBye\ndeleted : red\ndeleted : blue\ndeleted : green\ndeleted : red\ndeleted : Maciej\ndeleted : MY NAME IS MACIEJ AND I AM A C++ STUDENT.\ndeleted : red\n*/\n</code></pre> Code - Prototypes <pre><code>// string1.h -- fixed and augmented string class definition\n#ifndef STR_H_\n#define STR_H_\n\n#include &lt;iostream&gt;\nusing std::istream;\nusing std::ostream;\n\nclass String\n{\nprivate:\n    char *str;                    // pointer to string\n    int len;                      // length of string\n    static int num_strings;       // number of objects\n    static const int CINLIM = 80; // cin input limit\npublic:\n    // constructors and other methods\n    String(const char *s);  // constructor\n    String();               // default constructor\n    String(const String &amp;); // copy constructor\n    ~String();              // destructor\n    int length() const { return len; }\n    void stringlow();      // b)\n    void stringup();       // c)\n    int has(const char s); // d)\n\n    // overloaded operator methods\n    String &amp;operator=(const String &amp;);\n    String &amp;operator=(const char *);\n    String operator+(const String &amp;);  // a)\n    String operator+(const char &amp;cstr); // a) const char [12] + String\n\n    char &amp;operator[](int i);\n    const char &amp;operator[](int i) const;\n\n    // overloaded operator friends\n    friend bool operator&lt;(const String &amp;st, const String &amp;st2);\n    friend bool operator&gt;(const String &amp;st1, const String &amp;st2);\n    friend bool operator==(const String &amp;st, const String &amp;st2);\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const String &amp;st);\n    friend istream &amp;operator&gt;&gt;(istream &amp;is, String &amp;st);\n    friend ostream &amp;operator+(String &amp;st, ostream os) { return os + st; }\n    friend ostream &amp;operator+(ostream &amp;os, String &amp;st)\n    {\n        os &lt;&lt; st.str;\n        return os;\n    };\n    friend String operator+(const char cstr[], const String &amp;st)\n    {\n        String tmp(cstr);\n        return tmp + st;\n    };\n\n    // static function\n    static int HowMany();\n};\n#endif\n</code></pre> Code - Methods <pre><code>// string1.cpp -- String class methods\n#include &lt;cstring&gt;      // string.h for some\n#include \"ch12_2_str.h\" // includes &lt;iostream&gt;\nusing std::cin;\nusing std::cout;\n\n// initializing static class member\nint String::num_strings = 0;\n\n// static method\nint String::HowMany()\n{\n    return num_strings;\n}\n\n// class methods\nString::String(const char *s) // construct String from C string\n{\n    len = std::strlen(s);    // set size\n    str = new char[len + 1]; // allot storage\n    std::strcpy(str, s);     // initialize pointer\n    num_strings++;           // set object count\n}\n\nString::String() // default constructor\n{\n    len = 4;\n    str = new char[1];\n    str[0] = '\\0'; // default string\n    num_strings++;\n}\n\nString::String(const String &amp;st)\n{\n    num_strings++;            // handle static member update\n    len = st.len;             // same length\n    str = new char[len + 1];  // allot space\n    std::strcpy(str, st.str); // copy string to new location\n}\n\nString::~String() // necessary destructor\n{\n    --num_strings; // required\n    cout &lt;&lt; \"deleted : \" &lt;&lt; str &lt;&lt; \"\\n\";\n    delete[] str;  // required\n}\n\nvoid String::stringlow()\n{\n    for (int i = 0; i &lt; len; i++)\n        str[i] = tolower(str[i]);\n}\n\nvoid String::stringup()\n{\n    for (int i = 0; i &lt; len; i++)\n        str[i] = toupper(str[i]);\n}\n\nint String::has(const char s)\n{\n    int retVal{};\n    for (int i = 0; i &lt; len; i++)\n        if (s == str[i])\n            ++retVal;\n\n    return retVal;\n}\n\n// overloaded operator methods\n// assign a String to a String\nString &amp;String::operator=(const String &amp;st)\n{\n    if (this == &amp;st)\n        return *this;\n    delete[] str;\n    len = st.len;\n    str = new char[len + 1];\n    std::strcpy(str, st.str);\n    return *this;\n}\n\n// assign a C string to a String\nString &amp;String::operator=(const char *s)\n{\n    delete[] str;\n    len = std::strlen(s);\n    str = new char[len + 1];\n    std::strcpy(str, s);\n    return *this;\n}\n\n// a)\nString String::operator+(const String &amp;st)\n{\n    String temp;\n    temp.len = st.len + this-&gt;len;\n    temp.str = new char[temp.len + 1];\n    std::strcpy(temp.str, this-&gt;str);\n    std::strcat(temp.str, st.str);\n    return temp;\n}\n\nString String::operator+(const char &amp;cstr)\n{\n    String tmp{str};\n    return *this + tmp;\n}\n\n// read-write char access for non-const String\nchar &amp;String::operator[](int i)\n{\n    return str[i];\n}\n\n// read-only char access for const String\nconst char &amp;String::operator[](int i) const\n{\n    return str[i];\n}\n\n// overloaded operator friends\nbool operator&lt;(const String &amp;st1, const String &amp;st2)\n{\n    return (std::strcmp(st1.str, st2.str) &lt; 0);\n}\n\nbool operator&gt;(const String &amp;st1, const String &amp;st2)\n{\n    return st2 &lt; st1;\n}\n\nbool operator==(const String &amp;st1, const String &amp;st2)\n{\n    return (std::strcmp(st1.str, st2.str) == 0);\n}\n\n// simple String output\nostream &amp;operator&lt;&lt;(ostream &amp;os, const String &amp;st)\n{\n    os &lt;&lt; st.str;\n    return os;\n}\n\n// quick and dirty String input\nistream &amp;operator&gt;&gt;(istream &amp;is, String &amp;st)\n{\n    char temp[String::CINLIM];\n    is.get(temp, String::CINLIM);\n    if (is)\n        st = temp;\n    while (is &amp;&amp; is.get() != '\\n')\n        continue;\n    return is;\n}\n</code></pre> <p>Test your work in the following program:</p> <pre><code>// pe12_2.cpp\n#include &lt;iostream&gt;\nusing namespace std;\n#include \"string2.h\"\n\nint main()\n{\n    String s1(\" and I am a C++ student.\");\n    String s2 = \"Please enter your name: \";\n    String s3;\n    cout &lt;&lt; s2;              // overloaded &lt;&lt; operator\n    cin &gt;&gt; s3;               // overloaded &gt;&gt; operator\n    s2 = \"My name is \" + s3; // overloaded =, + operators\n    cout &lt;&lt; s2 &lt;&lt; \".\\n\";\n    s2 = s2 + s1;\n    s2.stringup(); // converts string to uppercase\n    cout &lt;&lt; \"The string\\n\"\n         &lt;&lt; s2 &lt;&lt; \"\\ncontains \" &lt;&lt; s2.has('A')\n         &lt;&lt; \" 'A' characters in it.\\n\";\n    s1 = \"red\"; // String(const char *),\n    // then String &amp; operator=(const String&amp;)\n    String rgb[3] = {String(s1), String(\"green\"), String(\"blue\")};\n    cout &lt;&lt; \"Enter the name of a primary color for mixing light: \";\n    String ans;\n    bool success = false;\n    while (cin &gt;&gt; ans)\n    {\n        ans.stringlow(); // converts string to lowercase\n        for (int i = 0; i &lt; 3; i++)\n        {\n            if (ans == rgb[i]) // overloaded == operator\n            {\n                cout &lt;&lt; \"That's right!\\n\";\n                success = true;\n                break;\n            }\n        }\n        if (success)\n            break;\n        else\n            cout &lt;&lt; \"Try again!\\n\";\n    }\n    cout &lt;&lt; \"Bye\\n\";\n    return 0;\n}\n</code></pre> <p>Your output should look like this sample run:</p> <pre><code>Please enter your name: Fretta Farbo\nMy name is Fretta Farbo.\nThe string\nMY NAME IS FRETTA FARBO AND I AM A C++ STUDENT.\ncontains 6 'A' characters in it.\nEnter the name of a primary color for mixing light: yellow\nTry again!\nBLUE\nThat's right!\nBye\n</code></pre> <p>3 - Rewrite the <code>Stock</code> class, as described in Listings 10.7 (stock20.h) and 10.8 (stock20.cpp) in Chapter 10 so that it uses dynamically allocated memory directly instead of using <code>string</code> class objects to hold the stock names. Also replace the <code>show()</code> member function with an overloaded <code>operator&lt;&lt;()</code> definition. Test the new definition program in Listing 10.9 (usestok2.cpp).</p> Code - prototypes <pre><code>// stock20.h -- augmented version\n#ifndef STOCK20_H_\n#define STOCK20_H_\n#include &lt;string&gt;\nclass Stock\n{\nprivate:\n    std::string *company;\n    int shares;\n    double share_val;\n    double total_val;\n    void set_tot() { total_val = shares * share_val; }\n\npublic:\n    Stock();\n    // default constructor\n    Stock(const std::string &amp;co, long n = 0, double pr = 0.0);\n    ~Stock();\n    // do-nothing destructor\n    void buy(long num, double price);\n    void sell(long num, double price);\n    void update(double price);\n    // void show() const;\n    const Stock &amp;topval(const Stock &amp;s) const;\n\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp; os, const Stock &amp; st);\n};\n#endif\n</code></pre> Code - methods <pre><code>// stock20.cpp -- augmented version\n#include &lt;iostream&gt;\n#include \"ch12_3_stock.h\"\n\n// constructors\nStock::Stock()\n// default constructor\n{\n    company = new std::string(\"no name\");\n    shares = 0;\n\n    share_val = 0.0;\n    total_val = 0.0;\n}\n\nStock::Stock(const std::string &amp;co, long n, double pr)\n{\n    company = new std::string(co);\n\n    if (n &lt; 0)\n    {\n        std::cout &lt;&lt; \"Number of shares can't be negative; \"\n                  &lt;&lt; company &lt;&lt; \" shares set to 0.\\n\";\n        shares = 0;\n    }\n    else\n        shares = n;\n    share_val = pr;\n    set_tot();\n}\n\n// class destructor\nStock::~Stock()\n{\n    delete company;\n}\n\n// quiet class destructor\n// other methods\nvoid Stock::buy(long num, double price)\n{\n    if (num &lt; 0)\n    {\n        std::cout &lt;&lt; \"Number of shares purchased can't be negative. \"\n                  &lt;&lt; \"Transaction is aborted.\\n\";\n    }\n    else\n    {\n        shares += num;\n        share_val = price;\n        set_tot();\n    }\n}\n\nvoid Stock::sell(long num, double price)\n{\n    using std::cout;\n    if (num &lt; 0)\n    {\n\n        cout &lt;&lt; \"Number of shares sold can't be negative. \"\n             &lt;&lt; \"Transaction is aborted.\\n\";\n    }\n    else if (num &gt; shares)\n    {\n        cout &lt;&lt; \"You can't sell more than you have! \"\n             &lt;&lt; \"Transaction is aborted.\\n\";\n    }\n    else\n    {\n        shares -= num;\n        share_val = price;\n        set_tot();\n    }\n}\n\nvoid Stock::update(double price)\n{\n    share_val = price;\n    set_tot();\n}\n\n// void Stock::show() const\n// {\n//     using std::cout;\n//     using std::ios_base;\n//     // set format to #.###\n//     ios_base::fmtflags orig =\n//         cout.setf(ios_base::fixed, ios_base::floatfield);\n//     std::streamsize prec = cout.precision(3);\n//     cout &lt;&lt; \"Company: \" &lt;&lt; company\n//          &lt;&lt; \" Shares: \" &lt;&lt; shares &lt;&lt; '\\n';\n//     cout &lt;&lt; \" Share Price: $\" &lt;&lt; share_val;\n//     // set format to #.##\n//     cout.precision(2);\n//     cout &lt;&lt; \" Total Worth: $\" &lt;&lt; total_val &lt;&lt; '\\n';\n//     // restore original format\n//     cout.setf(orig, ios_base::floatfield);\n//     cout.precision(prec);\n// }\n\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp; os, const Stock &amp; st){\n    using std::ios_base;\n    // set format to #.###\n    ios_base::fmtflags orig =\n        os.setf(ios_base::fixed, ios_base::floatfield);\n    std::streamsize prec = os.precision(3);\n    os &lt;&lt; \"Company: \" &lt;&lt; *st.company\n         &lt;&lt; \" Shares: \" &lt;&lt; st.shares &lt;&lt; '\\n';\n    os &lt;&lt; \" Share Price: $\" &lt;&lt; st.share_val;\n    // set format to #.##\n    os.precision(2);\n    os &lt;&lt; \" Total Worth: $\" &lt;&lt; st.total_val &lt;&lt; '\\n';\n    // restore original format\n    os.setf(orig, ios_base::floatfield);\n    os.precision(prec);\n    return os;\n}\n\nconst Stock &amp;Stock::topval(const Stock &amp;s) const\n{\n    if (s.total_val &gt; total_val)\n        return s;\n    else\n        return *this;\n}\n</code></pre> Code - program <pre><code>// usestok2.cpp -- using the Stock class\n// compile with stock20.cpp\n#include &lt;iostream&gt;\n#include \"ch12_3_stock.h\"\n\nconst int STKS = 4;\nint main()\n{\n    // create an array of initialized objects\n    Stock stocks[STKS] = {\n        Stock(\"NanoSmart\", 12, 20.0),\n        Stock(\"Boffo Objects\", 200, 2.0),\n        Stock(\"Monolithic Obelisks\", 130, 3.25),\n        Stock(\"Fleep Enterprises\", 60, 6.5)};\n    std::cout &lt;&lt; \"Stock holdings:\\n\";\n    int st;\n    for (st = 0; st &lt; STKS; st++)\n        std::cout &lt;&lt; stocks[st];    // stocks[st].show();\n    // set pointer to first element\n    const Stock *top = &amp;stocks[0];\n    for (st = 1; st &lt; STKS; st++)\n        top = &amp;top-&gt;topval(stocks[st]);\n    // now top points to the most valuable holding\n    std::cout &lt;&lt; \"\\nMost valuable holding:\\n\";\n    std::cout &lt;&lt; *top;              // top-&gt;show();\n    return 0;\n}\n\n/*\nStock holdings:\nCompany: NanoSmart Shares: 12\nShare Price: $20.000 Total Worth: $240.00\nCompany: Boffo Objects Shares: 200\nShare Price: $2.000 Total Worth: $400.00\nCompany: Monolithic Obelisks Shares: 130\nShare Price: $3.250 Total Worth: $422.50\nCompany: Fleep Enterprises Shares: 60\nShare Price: $6.500 Total Worth: $390.00\nMost valuable holding:\nCompany: Monolithic Obelisks Shares: 130\nShare Price: $3.250 Total Worth: $422.50\n*/\n</code></pre> <p>4 - Consider the following variation of the <code>Stack</code> class defined in Listing 10.10 (stack.h):</p> <pre><code>// stack.h -- class declaration for the stack ADT\n</code></pre> <p>typedef unsigned long Item;</p> <pre><code>class Stack\n{\nprivate:\n    enum\n    {\n        MAX = 10\n    };            // constant specific to class\n    Item *pitems; // holds stack items\n    int size;     // number of elements in stack\n    int top;      // index for top stack item\npublic:\n    Stack(int n = MAX); // creates stack with n elements\n    Stack(const Stack &amp;st);\n    ~Stack();\n    bool isempty() const;\n    bool isfull() const;\n    // push() returns false if stack already is full, true otherwise\n    bool push(const Item &amp;item); // add item to stack\n    // pop() returns false if stack already is empty, true otherwise\n    bool pop(Item &amp;item); // pop top into item\n    Stack &amp;operator=(const Stack &amp;st);\n};\n</code></pre> <p>As the private members suggest, this class uses a dynamically allocated array to hold the stack items. Rewrite the methods to fit this new representation and write a program that demonstrates all the methods, including the copy constructor and assignment operator.</p> Code - prototypes <pre><code>// stack.h -- class definition for the stack ADT\n#ifndef STACK_H_\n#define STACK_H_\n\ntypedef unsigned long Item;\n\nclass Stack\n{\nprivate:\n    enum\n    {\n        MAX = 10\n    };            // constant specific to class\n    Item *pitems; // holds stack items\n    int size;     // number of elements in stack\n    int top;      // index for top stack item\npublic:\n    Stack(int n = MAX); // creates stack with n elements\n    Stack(const Stack &amp;st);\n    ~Stack();\n    bool isempty() const;\n    bool isfull() const;\n    // push() returns false if stack already is full, true otherwise\n    bool push(const Item &amp;item); // add item to stack\n    // pop() returns false if stack already is empty, true otherwise\n    bool pop(Item &amp;item); // pop top into item\n    Stack &amp;operator=(const Stack &amp;st);\n};\n#endif\n</code></pre> Code - methods <pre><code>// stack.cpp -- Stack member functions\n#include \"ch12_4_stack.h\"\nStack::Stack(int n)\n// create an empty stack\n{\n    pitems = new Item[n]{};\n    size = n;\n    top = 0;\n}\n\nStack::Stack(const Stack &amp;st)\n{\n    pitems = new Item[st.size]{};\n\n    for (int i = 0; i &lt; st.size; i++)\n        pitems[i] = st.pitems[i];\n\n    size = st.size;\n    top = st.top;\n}\n\nStack::~Stack(){\n    delete [] pitems;\n}\n\nbool Stack::isempty() const\n{\n    return top == 0;\n}\n\nbool Stack::isfull() const\n{\n    return top == MAX;\n}\n\nbool Stack::push(const Item &amp;item)\n{\n    if (top &lt; MAX)\n    {\n        Item *newPitems = new Item[++size]{};\n        for (int i = 0; i &lt; (size - 1); i++)\n            newPitems[i] = pitems[i];\n        delete[] pitems;\n        pitems = newPitems;\n\n        pitems[top++] = item;\n        return true;\n    }\n    else\n        return false;\n}\n\nbool Stack::pop(Item &amp;item)\n{\n    if (top &gt; 0)\n    {\n        Item *newPitems = new Item[--size]{};\n        for (int i = 0; i &lt; size; i++)\n            newPitems[i] = pitems[i];\n        delete[] pitems;\n        pitems = newPitems;\n\n        item = pitems[--top];\n        return true;\n    }\n    else\n        return false;\n}\n\nStack &amp;Stack::operator=(const Stack &amp;st)\n{\n    pitems = new Item[st.size]{};\n\n    for (int i = 0; i &lt; st.size; i++)\n        pitems[i] = st.pitems[i];\n\n    size = st.size;\n    top = st.top;\n\n    return *this;\n}\n</code></pre> Code - program <pre><code>// stacker.cpp -- testing the Stack class\n#include &lt;iostream&gt;\n#include &lt;cctype&gt; // or ctype.h\n#include \"ch12_4_stack.h\"\nint main()\n{\n    using namespace std;\n    Stack st; // create an empty stack\n    char ch;\n    unsigned long po;\n    cout &lt;&lt; \"Please enter A to add a purchase order,\\n\"\n         &lt;&lt; \"P to process a PO, or Q to quit.\\n\";\n    while (cin &gt;&gt; ch &amp;&amp; toupper(ch) != 'Q')\n    {\n        while (cin.get() != '\\n')\n            continue;\n        if (!isalpha(ch))\n        {\n            cout &lt;&lt; '\\a';\n            continue;\n        }\n        switch (ch)\n        {\n        case 'A':\n        case 'a':\n            cout &lt;&lt; \"Enter a PO number to add: \";\n            cin &gt;&gt; po;\n            if (st.isfull())\n                cout &lt;&lt; \"stack already full\\n\";\n            else\n                st.push(po);\n            break;\n        case 'P':\n        case 'p':\n            if (st.isempty())\n                cout &lt;&lt; \"stack already empty\\n\";\n            else\n            {\n                st.pop(po);\n                cout &lt;&lt; \"PO #\" &lt;&lt; po &lt;&lt; \" popped\\n\";\n            }\n            break;\n        }\n        cout &lt;&lt; \"Please enter A to add a purchase order,\\n\"\n             &lt;&lt; \"P to process a PO, or Q to quit.\\n\";\n    }\n    cout &lt;&lt; \"Bye\\n\";\n    return 0;\n}\n\n/*\nPlease enter A to add a purchase order,\nP to process a PO, or Q to quit.\nA\nEnter a PO number to add: 17885\nPlease enter A to add a purchase order,\nP to process a PO, or Q to quit.\nP\nPO #17885 popped\nPlease enter A to add a purchase order,\nP to process a PO, or Q to quit.\nA\nEnter a PO number to add: 17965\nPlease enter A to add a purchase order,\nP to process a PO, or Q to quit.\nA\nEnter a PO number to add: 18002\nPlease enter A to add a purchase order,\nP to process a PO, or Q to quit.\nP\nPO #18002 popped\nPlease enter A to add a purchase order,\nP to process a PO, or Q to quit.\nP\nPO #17965 popped\nPlease enter A to add a purchase order,\nP to process a PO, or Q to quit.\nP\nstack already empty\nPlease enter A to add a purchase order,\nP to process a PO, or Q to quit.\nQ\nBye\n*/\n</code></pre> <p>5 - The Bank of Heather has performed a study showing that ATM customers won\u2019t wait more than one minute in line. Using the simulation from Listing 12.10 (queue.h), find a value for number of customers per hour that leads to an average wait time of one minute. (Use at least a 100-hour trial period.)</p> Code - prototypes <pre><code>#ifndef QUEUE_H_\n#define QUEUE_H_\n\n// This queue will contain Customer items\nclass Customer\n{\nprivate:\n    long arrive;     // arrival time for customer\n    int processtime; // processing time for customer\npublic:\n    Customer() { arrive = processtime = 0; }\n    void set(long when);\n    long when() const { return arrive; }\n    int ptime() const { return processtime; }\n};\n\ntypedef Customer Item;\n\nclass Queue\n{\nprivate:\n    // class scope definitions\n    // Node is a nested structure definition local to this class\n    struct Node\n    {\n        Item item;\n        struct Node *next;\n    };\n    enum\n    {\n        Q_SIZE = 10\n    };\n    // private class members\n    Node *front;     // pointer to front of Queue\n    Node *rear;      // pointer to rear of Queue\n    int items;       // current number of items in Queue\n    const int qsize; // maximum number of items in Queue\n\n    // preemptive definitions to prevent public copying\n    Queue(const Queue &amp;q) : qsize(0) {}\n    Queue &amp;operator=(const Queue &amp;q) { return *this; }\n\npublic:\n    Queue(int qs = Q_SIZE);         // create queue with a qs limit\n    ~Queue();\n    bool isempty() const;\n    bool isfull() const;\n    int queuecount() const;\n    bool enqueue(const Item &amp;item); // add item to end\n    bool dequeue(Item &amp;item);       // remove item from front\n};\n\n#endif\n</code></pre> Code - methods <pre><code>// queue.cpp -- Queue and Customer methods\n#include \"ch12_5_queue.h\"\n#include &lt;cstdlib&gt;\n// (or stdlib.h) for rand()\n\n// Queue methods\nQueue::Queue(int qs) : qsize(qs)\n{\n    front = rear = NULL; // or nullptr\n    items = 0;\n}\n\nQueue::~Queue()\n{\n    Node *temp;\n    while (front != NULL) // while queue is not yet empty\n    {\n        temp = front;        // save address of front item\n        front = front-&gt;next; // reset pointer to next item\n        delete temp;         // delete former front\n    }\n}\n\nbool Queue::isempty() const\n{\n    return items == 0;\n}\n\nbool Queue::isfull() const\n{\n    return items == qsize;\n}\n\nint Queue::queuecount() const\n{\n    return items;\n}\n\n// Add item to queue\nbool Queue::enqueue(const Item &amp;item)\n{\n    if (isfull())\n        return false;\n    Node *add = new Node; // create node\n    // on failure, new throws std::bad_alloc exception\n    add-&gt;item = item; // set node pointers\n    add-&gt;next = NULL; // or nullptr;\n    items++;\n    if (front == NULL) // if queue is empty,\n        front = add;   // place item at front\n    else\n        rear-&gt;next = add; // else place at rear\n    rear = add;           // have rear point to new node\n    return true;\n}\n\n// Place front item into item variable and remove from queue\nbool Queue::dequeue(Item &amp;item)\n{\n    if (front == NULL)\n        return false;\n    item = front-&gt;item; // set item to first item in queue\n    items--;\n    Node *temp = front;  // save location of first item\n    front = front-&gt;next; // reset front to next item\n    delete temp;         // delete former first item\n    if (items == 0)\n        rear = NULL;\n    return true;\n}\n\n// customer method\n// when is the time at which the customer arrives\n// the arrival time is set to when and the processing\n// time set to a random value in the range 1 - 3\nvoid Customer::set(long when)\n{\n    processtime = std::rand() % 3 + 1;\n    arrive = when;\n}\n</code></pre> Code - program <pre><code>// bank.cpp -- using the Queue interface\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt; // for rand() and srand()\n#include &lt;ctime&gt;   // for time()\n#include \"ch12_5_queue.h\"\n\nconst int MIN_PER_HR = 60;\nbool newcustomer(double x); // is there a new customer?\ndouble simulation(int qs, int hours, double perhour);\n\nint main()\n{\n    // hard-coded data for simulation \n    int qs = 150;               // rand() % 100 + 1; // size of queue 1 - 100\n    int hours = 1000;           // hours of simulation \n    double perhour = 10000;     // rand() % 10 + 1;  // average # of arrival per hour\n\n    double avgWait{};\n\n    do\n    {\n        avgWait = simulation(qs, hours, perhour--);\n    }\n    while(avgWait &gt; 1);\n\n    std::cout &lt;&lt; \"\\nNumber of customers per hour that leads\"\n              &lt;&lt; \" to an average wait time of one minute : \"\n              &lt;&lt; perhour &lt;&lt; \"\\n\"\n              &lt;&lt; \"for queue size: \" &lt;&lt; qs &lt;&lt; \"; and \" &lt;&lt; hours &lt;&lt; \" hours of simulation\";\n\n    std::cout &lt;&lt; \"Done!\\n\";\n    return 0;\n}\n\ndouble simulation(int qs, int hours, double perhour)\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n\n    Item temp;          // new customer data\n    long turnaways = 0; // turned away by full queue\n    long customers = 0; // joined the queue\n    long served = 0;    // served during the simulation\n    long sum_line = 0;  // cumulative line length\n    int wait_time = 0;  // time until autoteller is free\n    long line_wait = 0; // cumulative time in line\n\n    // setting things up\n    using std::ios_base;\n    std::srand(std::time(0)); //    random initializing of rand()\n\n    cout &lt;&lt; \"Case Study: Bank of Heather Automatic Teller\\n\";\n    // cout &lt;&lt; \"Enter maximum size of queue: \";\n\n    // value in the range 1 - 100\n    // qs = rand() % 100 + 1;    // cin &gt;&gt; qs;\n    cout &lt;&lt; \"; Max queue for simulation: \" &lt;&lt; qs;\n\n    Queue line(qs); // line queue holds up to qs people\n    // cout &lt;&lt; \"Enter the number of simulation hours: \";\n\n    // hours of simulation // cin &gt;&gt; hours; // simulation will run 1 cycle per minute\n    cout &lt;&lt; \"; Simulation hours: \" &lt;&lt; hours;\n\n    long cyclelimit = MIN_PER_HR * hours; // # of cycles\n    // cout &lt;&lt; \"Enter the average number of customers per hour: \";\n    cout &lt;&lt; \"; Average number of customers per hour: \" &lt;&lt; perhour &lt;&lt; \" \";\n\n    // cin &gt;&gt; perhour;\n\n    double min_per_cust; // average time between arrivals\n    min_per_cust = MIN_PER_HR / perhour;\n\n\n\n    // running the simulation\n    for (int cycle = 0; cycle &lt; cyclelimit; cycle++)\n    {\n        if (newcustomer(min_per_cust)) // have newcomer\n        {\n            if (line.isfull())\n                turnaways++;\n            else\n            {\n                customers++;\n                temp.set(cycle);\n                // cycle = time of arrival\n                line.enqueue(temp); // add newcomer to line\n            }\n        }\n        if (wait_time &lt;= 0 &amp;&amp; !line.isempty())\n        {\n            line.dequeue(temp);       // attend next customer\n            wait_time = temp.ptime(); // for wait_time minutes\n            line_wait += cycle - temp.when();\n            served++;\n        }\n        if (wait_time &gt; 0)\n            wait_time--;\n        sum_line += line.queuecount();\n    }\n\n    // reporting results\n    if (customers &gt; 0)\n    {\n        cout &lt;&lt; \"customers accepted: \" &lt;&lt; customers &lt;&lt; endl;\n        cout &lt;&lt; \" customers served: \" &lt;&lt; served &lt;&lt; endl;\n        cout &lt;&lt; \"turnaways : \" &lt;&lt; turnaways &lt;&lt; endl;\n        cout &lt;&lt; \"average queue size: \";\n        cout.precision(2);\n        cout.setf(ios_base::fixed, ios_base::floatfield);\n        cout &lt;&lt; (double)sum_line / cyclelimit &lt;&lt; endl;\n        cout &lt;&lt; \" average wait time: \"\n             &lt;&lt; (double)line_wait / served &lt;&lt; \" minutes\\n\";\n    }\n    else\n        cout &lt;&lt; \"No customers!\\n\";\n\n    return (double)line_wait / served;\n}\n\n// x = average time, in minutes, between customers\n// return value is true if customer shows up this minute\nbool newcustomer(double x)\n{\n    return (std::rand() * x / RAND_MAX &lt; 1);\n}\n\n/*\n\u22ee\n; Max queue for simulation: 150; Simulation hours: 1000; Average number of customers per hour: 18.00 customers accepted: 18151\n customers served: 18151\nturnaways : 0\naverage queue size: 0.31\n average wait time: 1.03 minutes\nCase Study: Bank of Heather Automatic Teller\n; Max queue for simulation: 150; Simulation hours: 1000; Average number of customers per hour: 17.00 customers accepted: 17100\n customers served: 17099\nturnaways : 0\naverage queue size: 0.25\n average wait time: 0.88 minutes\n\nNumber of customers per hour that leads to an average wait time of one minute : 16.00\n\nDone!\n*/\n</code></pre> <p>6 - The Bank of Heather would like to know what would happen if it added a second ATM. Modify the simulation in this chapter so that it has two queues. Assume that a customer will join the first queue if it has fewer people in it than the second queue and that the customer will join the second queue otherwise. Again, find a value for number of customers per hour that leads to an average wait time of one minute. (Note:This is a nonlinear problem in that doubling the number of ATMs doesn\u2019t double the number of customers who can be handled per hour with a oneminute wait maximum.)</p> Code - program <pre><code>// bank.cpp -- using the Queue interface\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt; // for rand() and srand()\n#include &lt;ctime&gt;   // for time()\n#include \"ch12_5_queue.h\"\n\nconst int MIN_PER_HR = 60;\nbool newcustomer(double x); // is there a new customer?\ndouble simulation(int qs, int hours, double perhour);\n\nint main()\n{\n    // hard-coded data for simulation\n    int qs = 150;           // rand() % 100 + 1; // size of queue 1 - 100\n    int hours = 1000;       // hours of simulation\n    double perhour = 10000; // rand() % 10 + 1;  // average # of arrival per hour\n\n    double avgWait{};\n\n    do\n    {\n        avgWait = simulation(qs, hours, perhour--);\n    } while (avgWait &gt; 1);\n\n    std::cout &lt;&lt; \"\\nNumber of customers per hour that leads\"\n              &lt;&lt; \" to an average wait time of one minute : \"\n              &lt;&lt; perhour &lt;&lt; \"\\n\"\n              &lt;&lt; \"for queue size: \" &lt;&lt; qs &lt;&lt; \"; and \" &lt;&lt; hours &lt;&lt; \" hours of simulation\";\n\n    std::cout &lt;&lt; \"\\n\\nDone!\\n\";\n    return 0;\n}\n\ndouble simulation(int qs, int hours, double perhour)\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n\n    Item temp;          // new customer data\n    long turnaways = 0; // turned away by full queue\n    long customers = 0; // joined the queue\n    long served = 0;    // served during the simulation\n    long sum_line = 0;  // cumulative line length\n    int wait_time[2]{}; // time until autoteller is free\n    long line_wait = 0; // cumulative time in line\n\n    // setting things up\n    using std::ios_base;\n    std::srand(std::time(0)); //    random initializing of rand()\n\n    cout &lt;&lt; \"Case Study: Bank of Heather Automatic Teller\\n\";\n    // cout &lt;&lt; \"Enter maximum size of queue: \";\n\n    // value in the range 1 - 100\n    // qs = rand() % 100 + 1;    // cin &gt;&gt; qs;\n    cout &lt;&lt; \"; Max queue for simulation: \" &lt;&lt; qs;\n\n    Queue line[2]{qs, qs}; // line queue holds up to qs people\n    // cout &lt;&lt; \"Enter the number of simulation hours: \";\n\n    // hours of simulation // cin &gt;&gt; hours; // simulation will run 1 cycle per minute\n    cout &lt;&lt; \"; Simulation hours: \" &lt;&lt; hours;\n\n    long cyclelimit = MIN_PER_HR * hours; // # of cycles\n    // cout &lt;&lt; \"Enter the average number of customers per hour: \";\n    cout &lt;&lt; \"; Average number of customers per hour: \" &lt;&lt; perhour &lt;&lt; \" \";\n\n    // cin &gt;&gt; perhour;\n\n    double min_per_cust; // average time between arrivals\n    min_per_cust = MIN_PER_HR / perhour;\n\n    // running the simulation\n    for (int cycle = 0; cycle &lt; cyclelimit; cycle++)\n    {\n        if (newcustomer(min_per_cust)) // have newcomer\n        {\n            if (line[0].queuecount() &gt; line[1].queuecount())\n            {\n                if (line[1].isfull())\n                    turnaways++;\n                else\n                {\n                    customers++;\n                    temp.set(cycle);\n                    // cycle = time of arrival\n                    line[1].enqueue(temp); // add newcomer to line\n                }\n            }\n            else\n            {\n                if (line[0].isfull())\n                    turnaways++;\n                else\n                {\n                    customers++;\n                    temp.set(cycle);\n                    // cycle = time of arrival\n                    line[0].enqueue(temp); // add newcomer to line\n                }\n            }\n        }\n\n        if (wait_time[0] &lt;= 0 &amp;&amp; !line[0].isempty())\n        {\n            line[0].dequeue(temp);       // attend next customer\n            wait_time[0] = temp.ptime(); // for wait_time minutes\n            line_wait += cycle - temp.when();\n            served++;\n        }\n\n        if (wait_time[1] &lt;= 0 &amp;&amp; !line[1].isempty())\n        {\n            line[1].dequeue(temp);       // attend next customer\n            wait_time[1] = temp.ptime(); // for wait_time minutes\n            line_wait += cycle - temp.when();\n            served++;\n        }\n\n        if (wait_time[0] &gt; 0)\n            wait_time[0]--;\n        if (wait_time[1] &gt; 0)\n            wait_time[1]--;\n\n        sum_line += line[0].queuecount();\n        sum_line += line[1].queuecount();\n    }\n\n    // reporting results\n    if (customers &gt; 0)\n    {\n        cout &lt;&lt; \"customers accepted: \" &lt;&lt; customers &lt;&lt; endl;\n        cout &lt;&lt; \" customers served: \" &lt;&lt; served &lt;&lt; endl;\n        cout &lt;&lt; \"turnaways : \" &lt;&lt; turnaways &lt;&lt; endl;\n        cout &lt;&lt; \"average queue size: \";\n        cout.precision(2);\n        cout.setf(ios_base::fixed, ios_base::floatfield);\n        cout &lt;&lt; (double)sum_line / cyclelimit &lt;&lt; endl;\n        cout &lt;&lt; \" average wait time: \"\n             &lt;&lt; (double)line_wait / served &lt;&lt; \" minutes\\n\";\n    }\n    else\n        cout &lt;&lt; \"No customers!\\n\";\n\n    return (double)line_wait / served;\n}\n\n// x = average time, in minutes, between customers\n// return value is true if customer shows up this minute\nbool newcustomer(double x)\n{\n    return (std::rand() * x / RAND_MAX &lt; 1);\n}\n</code></pre>"},{"location":"exercises/#chapter-13","title":"Chapter 13","text":"<p>1 - Start with the following class declaration:</p> <pre><code>// base class\nclass Cd\n{ // represents a CD disk\nprivate:\n    char performers[50];\n    char label[20];\n    int selections;  // number of selections\n    double playtime; // playing time in minutes\npublic:\n    Cd(char *s1, char *s2, int n, double x);\n    Cd(const Cd &amp;d);\n    Cd();\n    ~Cd();\n    void Report() const; // reports all CD data\n    Cd &amp;operator=(const Cd &amp;d);\n};\n</code></pre> <p>Derive a <code>Classic</code> class that adds an array of <code>char</code> members that will hold a string identifying the primary work on the <code>CD</code>. If the base class requires that any functions be <code>virtual</code>, modify the base-class declaration to make it so. If a declared method is not needed, remove it from the definition. Test your product with the following program:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n#include \"classic.h\" // which will contain #include cd.h\nvoid Bravo(const Cd &amp;disk);\nint main()\n{\n    Cd c1(\"Beatles\", \"Capitol\", 14, 35.5);\n    Classic c2 = Classic(\"Piano Sonata in B flat, Fantasia in C\",\n                         \"Alfred Brendel\", \"Philips\", 2, 57.17);\n    Cd *pcd = &amp;c1;\n    cout &lt;&lt; \"Using object directly:\\n\";\n    c1.Report(); // use Cd method\n    c2.Report(); // use Classic method\n    cout &lt;&lt; \"Using type cd * pointer to objects:\\n\";\n    pcd-&gt;Report(); // use Cd method for cd object\n    pcd = &amp;c2;\n    pcd-&gt;Report(); // use Classic method for classic object\n    cout &lt;&lt; \"Calling a function with a Cd reference argument:\\n\";\n    Bravo(c1);\n    Bravo(c2);\n    cout &lt;&lt; \"Testing assignment: \";\n    Classic copy;\n    copy = c2;\n    copy.Report();\n\n    return 0;\n}\nvoid Bravo(const Cd &amp;disk)\n{\n    disk.Report();\n}\n</code></pre> Code - CD <code>base</code> class prototypes <pre><code>#ifndef _CD_H_\n#define _CD_H_\n\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\n// base class\nclass Cd\n{ // represents a CD disk\nprivate:\n    char performers[50];\n    char label[20];\n    int selections;  // number of selections\n    double playtime; // playing time in minutes\npublic:\n    Cd(const char *s1,const  char *s2, int n, double x);\n    Cd(const Cd &amp;d);\n    Cd();       // needed - Classic() \n    // ~Cd();   // not needed - lack of dynamic memory allocation in both (thus default is ok)\n    virtual void Report() const; // reports all CD data\n    Cd &amp;operator=(const Cd &amp;d);\n};\n\n#endif\n</code></pre> Code - CD methods <pre><code>#include \"ch13_1_cd.h\"\n\nCd::Cd(const char *s1, const char *s2, int n, double x)\n{\n    strcpy(performers, s1);\n    strcpy(label, s2);\n    selections = n;\n    playtime = x;\n}\n\nCd::Cd(const Cd &amp;d)\n{\n    strcpy(performers, d.performers);\n    strcpy(label, d.label);\n    selections = d.selections;\n    playtime = d.playtime;\n}\n\nCd::Cd()\n{\n    performers[0] = '\\0';\n    label[0] = '\\0';\n    selections = 0;\n    playtime = 0;\n}\n\nvoid Cd::Report() const\n{\n    std::cout &lt;&lt; \"\\n Performance by: \" &lt;&lt; performers\n              &lt;&lt; \"\\n Album: \" &lt;&lt; label\n              &lt;&lt; \"\\n Number of selections: \" &lt;&lt; selections\n              &lt;&lt; \"\\n Playtime: \" &lt;&lt; playtime &lt;&lt; \"\\n\";\n}\n\nCd &amp;Cd::operator=(const Cd &amp;d)\n{\n    if (this == &amp;d)\n        return *this;\n    strcpy(performers, d.performers);\n    strcpy(label, d.label);\n    selections = d.selections;\n    playtime = d.playtime;\n    return *this;\n}\n</code></pre> Code - Classic <code>derived</code> class prototypes <pre><code>// Derive a &lt;code&gt;Classic&lt;/code&gt; class that adds an array of &lt;code&gt;char&lt;/code&gt; members that will hold a string\n// identifying the primary work on the `CD`. \n\n#include \"ch13_1_cd.h\"\n\nclass Classic : public Cd {\n\n    private:\n        char primaryWork[100];\n\n    public: \n        Classic(const char *pw,const char *pd,const char *lb, int n, double x);\n        Classic(const Classic &amp;d);\n        Classic();      // needed - line 29\n        // ~Classic();  // not needed - lack of dynamic memory allocation in both (thus default is ok)\n        virtual void Report() const; // reports all Classic data\n        Classic &amp;operator=(const Classic &amp;d);\n};\n</code></pre> Code - Classic methods <pre><code>#include \"ch13_1_classic.h\"\n\nClassic::Classic(const char *pw,const char *pf,const  char *lb, int n, double x)\n    : Cd(pf, lb, n, x)\n{\n    strcpy(primaryWork, pw);\n}\n\nClassic::Classic(const Classic &amp;d)\n    : Cd(d)\n{\n    strcpy(primaryWork, d.primaryWork);\n}\n\nClassic::Classic()\n    : Cd()\n{\n    primaryWork[0] = '\\0';\n}\n\nvoid Classic::Report() const\n{\n    Cd::Report();\n    std::cout &lt;&lt;\n        \"\\n Primary work: \" &lt;&lt; primaryWork &lt;&lt;\n        \"\\n\";\n}\n\nClassic &amp;Classic::operator=(const Classic &amp;d)\n{\n    if(this == &amp;d)\n        return *this;\n    Cd::operator=(d);\n    strcpy(primaryWork, d.primaryWork);\n    return *this;\n}\n</code></pre> Code - program <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n#include \"ch13_1_classic.h\" // which will contain #include cd.h\n\nvoid Bravo(const Cd &amp;disk);\n\nint main()\n{\n    {\n        Cd c1(\"Beatles\", \"Capitol\", 14, 35.5);\n        Classic c2 = Classic(\"Piano Sonata in B flat, Fantasia in C\",\n                             \"Alfred Brendel\", \"Philips\", 2, 57.17);\n\n        Cd *pcd = &amp;c1;\n\n        cout &lt;&lt; \"Using object directly:\\n\";\n        c1.Report(); // use Cd method\n        c2.Report(); // use Classic method\n\n        cout &lt;&lt; \"Using type cd * pointer to objects:\\n\";\n        pcd-&gt;Report(); // use Cd method for cd object\n        pcd = &amp;c2;\n        pcd-&gt;Report(); // use Classic method for classic object\n\n        cout &lt;&lt; \"Calling a function with a Cd reference argument:\\n\";\n        Bravo(c1);\n        Bravo(c2);\n\n        cout &lt;&lt; \"Testing assignment: \";\n        Classic copy;\n        copy = c2;\n        copy.Report();\n    }\n    return 0;\n}\n\nvoid Bravo(const Cd &amp;disk)\n{\n    disk.Report();\n}\n</code></pre> <p>2 - Do Programming Exercise 1 but use dynamic memory allocation instead of fixedsize arrays for the various strings tracked by the two classes.</p> Code - CD <code>base</code> class prototypes <pre><code>#ifndef _CD_H_\n#define _CD_H_\n\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\n// base class\nclass Cd\n{ // represents a CD disk\nprivate:\n    char *performers;\n    char *label;\n    int selections;  // number of selections\n    double playtime; // playing time in minutes\npublic:\n    Cd(const char *s1, const char *s2, int n, double x);\n    Cd(const Cd &amp;d);\n    Cd();                        // needed - Classic()\n    virtual ~Cd();               // needed - dynamic memory allocation\n    virtual void Report() const; // reports all CD data\n    virtual Cd &amp;operator=(const Cd &amp;d);\n};\n\n#endif\n</code></pre> Code - CD methods <pre><code>#include \"ch13_2_cd.h\"\n\nCd::Cd(const char *s1,const char *s2, int n, double x)\n{\n    performers = new char[strlen(s1) + 1];\n    strcpy(performers, s1);\n\n    label = new char[strlen(s2) + 1];\n    strcpy(label, s2);\n\n    selections = n;\n    playtime = x;\n}\n\nCd::Cd(const Cd &amp;d){\n    performers = new char[strlen(d.performers) + 1];\n    strcpy(performers, d.performers);\n\n    label = new char[strlen(d.label) + 1];\n    strcpy(label, d.label);\n\n    selections = d.selections;\n    playtime = d.playtime;\n}\n\nCd::Cd()\n{\n    performers = new char[1];\n    performers[0] = '\\0';\n\n    label = new char[1];\n    label[0] = '\\0';\n\n    selections = 0;\n    playtime = 0;\n}\n\nCd::~Cd()\n{\n    std::cout &lt;&lt; \"\\nper delete: \" &lt;&lt; performers;\n    std::cout &lt;&lt; \"\\nlbl delete: \" &lt;&lt; label;\n    delete [] performers;\n    delete [] label;\n}\n\nvoid Cd::Report() const\n{\n    std::cout &lt;&lt;\n        \"\\n Performance by: \" &lt;&lt; performers &lt;&lt;\n        \"\\n Album: \" &lt;&lt; label &lt;&lt;\n        \"\\n Number of selections: \" &lt;&lt; selections &lt;&lt; \n        \"\\n Playtime: \" &lt;&lt; playtime &lt;&lt;\n        \"\\n\";\n}\n\nCd &amp;Cd::operator=(const Cd &amp;d)\n{\n    if(this == &amp;d)\n        return *this;\n\n    delete [] performers;\n    performers = new char[strlen(d.performers) + 1];\n    strcpy(performers, d.performers);\n\n    delete [] label;\n    label = new char[strlen(d.label) + 1];\n    strcpy(label, d.label);    \n\n    selections = d.selections;\n    playtime = d.playtime;\n\n    return *this;\n}\n</code></pre> Code - Classic <code>derived</code> class prototypes <pre><code>// Derive a &lt;code&gt;Classic&lt;/code&gt; class that adds an array of &lt;code&gt;char&lt;/code&gt; members that will hold a string\n// identifying the primary work on the `CD`.\n\n#include \"ch13_2_cd.h\"\n\nclass Classic : public Cd\n{\nprivate:\n    char *primaryWork;\n\npublic:\n    Classic(const char *pw, const char *pd, const char *lb, int n, double x);\n    Classic(const Classic &amp;d);\n    Classic();                   // needed - line 29\n    virtual ~Classic();          // needed - dynamic memory allocation\n    virtual void Report() const; // reports all Classic data\n    virtual Classic &amp;operator=(const Classic &amp;d);\n};\n</code></pre> Code - Classic methods <pre><code>#include \"ch13_2_classic.h\"\n\nClassic::Classic(const char *pw,const char *pf,const  char *lb, int n, double x)\n    : Cd(pf, lb, n, x)\n{\n    primaryWork = new char[strlen(pw) + 1];\n    strcpy(primaryWork, pw);\n}\n\nClassic::Classic(const Classic &amp;d)\n    : Cd(d)\n{\n    primaryWork = new char[strlen(d.primaryWork) + 1];\n    strcpy(primaryWork, d.primaryWork);\n}\n\nClassic::Classic()\n    : Cd()\n{\n    primaryWork = new char[1];\n    primaryWork[0] = '\\0';\n}\n\nClassic::~Classic()\n{\n    std::cout &lt;&lt; \"\\nprw delete: \" &lt;&lt; primaryWork;\n    delete [] primaryWork;\n}\n\nvoid Classic::Report() const\n{\n    Cd::Report();\n    std::cout &lt;&lt;\n        \"\\n Primary work: \" &lt;&lt; primaryWork &lt;&lt;\n        \"\\n\";\n}\n\nClassic &amp;Classic::operator=(const Classic &amp;d)\n{\n    if(this == &amp;d)\n        return *this;\n    Cd::operator=(d);\n    delete [] primaryWork;\n    primaryWork = new char[strlen(d.primaryWork) + 1];\n    strcpy(primaryWork, d.primaryWork);\n    return *this;\n}\n</code></pre> Code - program <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n#include \"ch13_2_classic.h\" // which will contain #include cd.h\n\nvoid Bravo(const Cd &amp;disk);\n\nint main()\n{\n    {\n        Cd c1(\"Beatles\", \"Capitol\", 14, 35.5);\n        Classic c2 = Classic(\"Piano Sonata in B flat, Fantasia in C\",\n                             \"Alfred Brendel\", \"Philips\", 2, 57.17);\n\n        Cd *pcd = &amp;c1;\n\n        cout &lt;&lt; \"Using object directly:\\n\";\n        c1.Report(); // use Cd method\n        c2.Report(); // use Classic method\n\n        cout &lt;&lt; \"Using type cd * pointer to objects:\\n\";\n        pcd-&gt;Report(); // use Cd method for cd object\n        pcd = &amp;c2;\n        pcd-&gt;Report(); // use Classic method for classic object\n\n        cout &lt;&lt; \"Calling a function with a Cd reference argument:\\n\";\n        Bravo(c1);\n        Bravo(c2);\n\n        cout &lt;&lt; \"Testing assignment: \";\n        Classic copy;\n        copy = c2;\n        copy.Report();\n    }\n    return 0;\n}\nvoid Bravo(const Cd &amp;disk)\n{\n    disk.Report();\n}\n</code></pre> <p>3 - Revise the <code>baseDMA-lacksDMA-hasDMA</code> class hierarchy so that all three classes are derived from an ABC. Test the result with a program similar to the one in Listing 13.10 (usebrass2.cpp). That is, it should feature an array of pointers to the ABC and allow the user to make runtime decisions as to what types of objects are created. Add virtual <code>View()</code> methods to the class definitions to handle displaying the data.</p> Code - classes prototypes <pre><code>// dma.h -- inheritance and dynamic memory allocation\n#ifndef DMA_H_\n#define DMA_H_\n\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;string&gt;\n\n// ABC (Abstract Base Class) class\nclass absDMA\n{\nprotected:\n    char *label;\n    int rating;\n\npublic:\n    absDMA(const std::string &amp;l = \"null\", int r = 0);\n    absDMA(const char *l = \"null\", int r = 0);\n    absDMA(const absDMA &amp;ab);\n    virtual void View() = 0; // pure virtual function\n    virtual ~absDMA();\n};\n\n// Base Class Using DMA - can be deleted and changed into absDMA \n// (left only for sake of double inheritance)\nclass baseDMA : public absDMA\n{\npublic:\n    baseDMA(const std::string &amp;l = \"null\", int r = 0) : absDMA(l, r) {};\n    baseDMA(const char *l = \"null\", int r = 0) : absDMA(l, r) {};\n    baseDMA(const baseDMA &amp;rs) : absDMA(rs) {};\n    baseDMA &amp;operator=(const baseDMA &amp;rs);\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os,\n                                    const baseDMA &amp;rs);\n};\n\n// derived class without DMA\n// no destructor needed\n// uses implicit copy constructor\n// uses implicit assignment operator\nclass lacksDMA : public baseDMA\n{\nprivate:\n    enum\n    {\n        COL_LEN = 40\n    };\n    char color[COL_LEN];\n\npublic:\n    lacksDMA(const std::string &amp;c = \"blank\", const std::string &amp;l = \"null\",\n                int r = 0);\n    lacksDMA(const char *c = \"blank\", const char *l = \"null\",\n             int r = 0);\n    lacksDMA(const char *c, const baseDMA &amp;rs);\n    virtual void View();\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os,\n                                    const lacksDMA &amp;rs);\n};\n\n// derived class with DMA\nclass hasDMA : public baseDMA\n{\nprivate:\n    char *style;\n\npublic:\n    hasDMA(const std::string &amp;s = \"none\", const std::string &amp;l = \"null\",\n           int r = 0);\n    hasDMA(const char *s = \"none\", const char *l = \"null\",\n           int r = 0);\n    hasDMA(const char *s, const baseDMA &amp;rs);\n    hasDMA(const hasDMA &amp;hs);\n    ~hasDMA();\n    virtual void View();\n    hasDMA &amp;operator=(const hasDMA &amp;rs);\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os,\n                                    const hasDMA &amp;rs);\n};\n#endif\n</code></pre> Code - classes methods <pre><code>// dma.cpp --dma class methods\n#include \"ch13_3_dma.h\"\n\n// absDMA methods\nvoid absDMA::View()\n{\n    std::cout &lt;&lt; \"Label:  \"  &lt;&lt; label  &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Rating: \" &lt;&lt; rating &lt;&lt; std::endl;\n}\n\nabsDMA::absDMA(const std::string &amp;l, int r)\n{\n    label = new char[l.length() + 1];\n    l.copy(label, l.length());\n    label[l.length()] = '\\0';\n    rating = r;\n}\n\nabsDMA::absDMA(const char *l, int r)\n{\n    label = new char[std::strlen(l) + 1];\n    std::strcpy(label, l);\n    label[std::strlen(l)] = '\\0';\n    rating = r;\n}\n\nabsDMA::absDMA(const absDMA &amp;ab)\n{\n    label = new char[std::strlen(ab.label) + 1];\n    std::strcpy(label, ab.label);\n    label[std::strlen(ab.label)] = '\\0'; // without it, there will be printed trash at the end \n    rating = ab.rating;\n}\n\nabsDMA::~absDMA()\n{\n    delete[] label;\n}\n\n// baseDMA methods\nbaseDMA &amp;baseDMA::operator=(const baseDMA &amp;rs)\n{\n    if (this == &amp;rs)\n        return *this;\n    delete[] label;\n    label = new char[std::strlen(rs.label) + 1];\n    std::strcpy(label, rs.label);\n    rating = rs.rating;\n    return *this;\n}\n\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const baseDMA &amp;rs)\n{\n    os &lt;&lt; \"Label: \" &lt;&lt; rs.label &lt;&lt; std::endl;\n    os &lt;&lt; \"Rating: \" &lt;&lt; rs.rating &lt;&lt; std::endl;\n    return os;\n}\n\n// lacksDMA methods\nvoid lacksDMA::View()\n{\n    std::cout &lt;&lt; \"Label:  \" &lt;&lt; label  &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Rating: \" &lt;&lt; rating &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Color:  \" &lt;&lt; color  &lt;&lt; std::endl;\n}\n\nlacksDMA::lacksDMA(const std::string &amp;c, const std::string &amp;l, int r)\n    : baseDMA(l, r)\n{\n    c.copy(color, c.length());\n    color[c.length()] = '\\0';\n}\n\nlacksDMA::lacksDMA(const char *c, const char *l, int r)\n    : baseDMA(l, r)\n{\n    std::strncpy(color, c, COL_LEN - 1);\n    color[COL_LEN - 1] = '\\0';\n}\n\nlacksDMA::lacksDMA(const char *c, const baseDMA &amp;rs)\n    : baseDMA(rs)\n{\n    std::strncpy(color, c, COL_LEN - 1);\n    color[COL_LEN - 1] = '\\0';\n}\n\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const lacksDMA &amp;ls)\n{\n    os &lt;&lt; (const baseDMA &amp;)ls;\n    os &lt;&lt; \"Color: \" &lt;&lt; ls.color &lt;&lt; std::endl;\n    return os;\n}\n\n// hasDMA methods\nvoid hasDMA::View()\n{\n    std::cout &lt;&lt; \"Label:  \" &lt;&lt; label  &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Rating: \" &lt;&lt; rating &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Style:  \" &lt;&lt; style  &lt;&lt; std::endl;\n}\n\nhasDMA::hasDMA(const std::string &amp;s, const std::string &amp;l, int r)\n    : baseDMA(l, r)\n{\n    style = new char[s.length() + 1];\n    s.copy(style, s.length());\n    style[s.length()] = '\\0';\n}\n\nhasDMA::hasDMA(const char *s, const char *l, int r)\n    : baseDMA(l, r)\n{\n    style = new char[std::strlen(s) + 1];\n    std::strcpy(style, s);\n    style[std::strlen(s)] = '\\0';\n}\n\nhasDMA::hasDMA(const char *s, const baseDMA &amp;rs)\n    : baseDMA(rs)\n{\n    style = new char[std::strlen(s) + 1];\n    std::strcpy(style, s);\n}\n\nhasDMA::hasDMA(const hasDMA &amp;hs)\n    : baseDMA(hs) // invoke base class copy constructor\n{\n    style = new char[std::strlen(hs.style) + 1];\n    std::strcpy(style, hs.style);\n}\n\nhasDMA::~hasDMA()\n{\n    delete[] style;\n}\n\nhasDMA &amp;hasDMA::operator=(const hasDMA &amp;hs)\n{\n    if (this == &amp;hs)\n        return *this;\n    baseDMA::operator=(hs); // copy base portion\n    delete[] style;         // prepare for new style\n    style = new char[std::strlen(hs.style) + 1];\n    std::strcpy(style, hs.style);\n    style[std::strlen(hs.style)] = '\\0';\n\n    return *this;\n}\n\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const hasDMA &amp;hs)\n{\n    os &lt;&lt; (const baseDMA &amp;)hs;\n    os &lt;&lt; \"Style: \" &lt;&lt; hs.style &lt;&lt; std::endl;\n    return os;\n}\n</code></pre> Code - program <pre><code>// usebrass2.cpp -- polymorphic example - modified for exercise\n// compile with brass.cpp\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include \"ch13_3_dma.h\"\n\nconst int ALBUMS = 2;\nint main()\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n    baseDMA *p_albums[ALBUMS];\n    std::string tmp_lbl, temp_color;\n    long tmp_rtg;\n    char kind;\n    for (int i = 0; i &lt; ALBUMS; i++)\n    {\n        cout &lt;&lt; \"Enter name of \" &lt;&lt; i + 1 &lt;&lt; \" music album: \";\n        getline(cin, tmp_lbl);\n        cout &lt;&lt; \"Enter rating of the album: \";\n        cin &gt;&gt; tmp_rtg;\n        cout &lt;&lt; \"Enter 1 for baseDMA (Album with Dynamic Music Arrangement filter) album or \"\n             &lt;&lt; \"2 for lacksDMA (Album without Dynamic Music Arrangement filter) album : \";\n        while (cin &gt;&gt; kind &amp;&amp; (kind != '1' &amp;&amp; kind != '2'))\n            cout &lt;&lt; \"Enter either 1 or 2: \";\n        if (kind == '1')\n        {\n            cout &lt;&lt; \"Enter dominating color of the album: $\";\n            cin &gt;&gt; temp_color;\n            p_albums[i] = new lacksDMA(temp_color, tmp_lbl, tmp_rtg);\n        }\n        else\n        {\n            std::string tmp_style;\n            cout &lt;&lt; \"Enter the style of \" &lt;&lt; i &lt;&lt; \" the album \";\n            cin &gt;&gt; tmp_style;\n            p_albums[i] = new hasDMA(tmp_style, tmp_lbl, tmp_rtg);\n        }\n        while (cin.get() != '\\n')\n            continue;\n    }\n    cout &lt;&lt; endl;\n    for (int i = 0; i &lt; ALBUMS; i++)\n    {\n        p_albums[i]-&gt;View();\n        cout &lt;&lt; endl;\n    }\n    for (int i = 0; i &lt; ALBUMS; i++)\n    {\n        delete p_albums[i]; // free memory\n    }\n    cout &lt;&lt; \"Done.\\n\";\n    return 0;\n}\n</code></pre> <p>4 - The Benevolent Order of Programmers maintains a collection of bottled port. To describe it, the BOP Portmaster has devised a <code>Port</code> class, as declared here:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass Port\n{\nprivate:\n    char *brand;\n    char style[20]; // i.e., tawny, ruby, vintage\n    int bottles;\n\npublic:\n    Port(const char *br = \"none\", const char *st = \"none\", int b = 0);\n    Port(const Port &amp;p); // copy constructor\n    virtual ~Port() { delete[] brand; }\n    Port &amp;operator=(const Port &amp;p);\n    Port &amp;operator+=(int b); // adds b to bottles\n    Port &amp;operator-=(int b); // subtracts b from bottles, if\n    available int BottleCount() const { return bottles; }\n    virtual void Show() const;\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Port &amp;p);\n};\n</code></pre> <p>The <code>Show()</code> method presents information in the following format:</p> <pre><code>Brand: Gallo\nKind: tawny\nBottles: 20\n</code></pre> <p>The <code>operator&lt;&lt;()</code> function presents information in the following format (with no newline character at the end):</p> <pre><code>Gallo, tawny, 20\n</code></pre> <p>The Portmaster completed the method definitions for the <code>Port</code> class and then derived the <code>VintagePort</code> class as follows before being relieved of his position for accidentally routing a bottle of \u201945 Cockburn to someone preparing an experimental barbecue sauce:</p> <pre><code>class VintagePort : public Port // style necessarily = \"vintage\"\n{\nprivate:\n    char *nickname; // i.e., \"The Noble\" or \"Old Velvet\", etc.\n    int year;       // vintage year\npublic:\n    VintagePort();\n    VintagePort(const char *br, int b, const char *nn, int y);\n    VintagePort(const VintagePort &amp;vp);\n    ~VintagePort() { delete[] nickname; }\n    VintagePort &amp;operator=(const VintagePort &amp;vp);\n    void Show() const;\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const VintagePort &amp;vp);\n};\n</code></pre> <p>You get the job of completing the VintagePort work.</p> <p>A. Your first task is to re-create the <code>Port</code> method definitions because the former Portmaster immolated his upon being relieved. B. Your second task is to explain why certain methods are redefined and others are not. C. Your third task is to explain why <code>operator=()</code> and <code>operator&lt;&lt;()</code> are not virtual. D. Your fourth task is to provide definitions for the <code>VintagePort</code> methods.</p> Code - class prototypes - Port <pre><code>#ifndef _PORT_H_\n#define _PORT_H_\n\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\n// base class\nusing namespace std;\nclass Port\n{\nprivate:\n    char *brand;\n    char style[20]; // i.e., tawny, ruby, vintage\n    int bottles;\n\npublic:\n    Port(const char *br = \"none\", const char *st = \"none\", int b = 0);\n    Port(const Port &amp;p); // copy constructor\n    virtual ~Port() { delete[] brand; }\n\n    Port &amp;operator=(const Port &amp;p);\n    Port &amp;operator+=(int b); // adds b to bottles\n    Port &amp;operator-=(int b); // subtracts b from bottles, if available \n\n    int BottleCount() const { return bottles; }\n    virtual void Show() const;\n\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Port &amp;p);\n};\n\n#endif\n</code></pre> Code - class methods - Port <pre><code>// &gt;&gt;&gt;&gt;&gt; A &lt;&lt;&lt;&lt;&lt;\n#include \"ch13_4_port.h\"\n\nPort::Port(const char *br, const char *st, int b)\n{\n    brand = new char[strlen(br) + 1];\n    strcpy(brand, br);\n    brand[strlen(br)] = '\\0';\n\n    strcpy(style, st);\n    style[strlen(st)] = '\\0';\n    bottles = b;\n}\n\nPort::Port(const Port &amp;p) // copy constructor\n{\n    brand = new char[strlen(p.brand) + 1];\n    strcpy(brand, p.brand);\n    brand[strlen(p.brand)] = '\\0';\n\n    strcpy(style, p.style);\n    style[strlen(p.style)] = '\\0';\n\n    bottles = p.bottles;\n}\n\nPort &amp;Port::operator=(const Port &amp;p)\n{\n    if(this == &amp;p)\n        return *this;\n    delete[] brand;\n    brand = new char[strlen(p.brand) + 1];\n    strcpy(brand, p.brand);\n    brand[strlen(p.brand)] = '\\0';\n\n    strcpy(style, p.style);\n    style[strlen(p.style)] = '\\0';\n\n    bottles = p.bottles;\n\n    return *this;\n}\n\nPort &amp;Port::operator+=(int b) // adds b to bottles\n{\n    this-&gt;bottles += b;\n    return *this;\n}\n\nPort &amp;Port::operator-=(int b) // subtracts b from bottles, if available\n{\n    this-&gt;bottles -= b;\n    return *this;\n}\n\nvoid Port::Show() const\n{\n    cout &lt;&lt; \"Brand: \"   &lt;&lt; brand &lt;&lt; endl;\n    cout &lt;&lt; \"Kind: \"    &lt;&lt; style &lt;&lt; endl;\n    cout &lt;&lt; \"Bottles: \" &lt;&lt; bottles &lt;&lt; endl;\n}\n\nostream &amp;operator&lt;&lt;(ostream &amp;os, const Port &amp;p)\n{\n    os &lt;&lt; p.brand &lt;&lt; \", \" &lt;&lt; p.style &lt;&lt; \", \" &lt;&lt; p.bottles;\n    return os;\n}\n</code></pre> Code - class prototypes - VintagePort <pre><code>#ifndef _VPORT_H_\n#define _VPORT_H_\n\n#include \"ch13_4_port.h\"\n\n// derived class\nclass VintagePort : public Port // style necessarily = \"vintage\"\n{\nprivate:\n    char *nickname; // i.e., \"The Noble\" or \"Old Velvet\", etc.\n    int year;       // vintage year\npublic:\n    VintagePort();\n    VintagePort(const char *br, int b, const char *nn, int y);\n    VintagePort(const VintagePort &amp;vp);\n    ~VintagePort() { delete[] nickname; }\n\n    // &gt;&gt;&gt;&gt;&gt; B &lt;&lt;&lt;&lt;&lt;\n    // The rest of the methiods don't need to be redefined\n    // because there the same operations are used in both cases\n    VintagePort &amp;operator=(const VintagePort &amp;vp);\n\n    // virtual in the base class remains virtual in the derived class,\n    // even if the virtual keyword is omitted in the derived class\n    // The result is the same as if it would be vitrtual void Show() const below \n    void Show() const;\n\n    // &gt;&gt;&gt;&gt;&gt; C &lt;&lt;&lt;&lt;&lt;\n    // It is not virtual, because friend keyword\n    // cannot be combined with keyword virtual \n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const VintagePort &amp;vp);\n};\n\n#endif\n</code></pre> Code - class methods - VintagePort <pre><code>// &gt;&gt;&gt;&gt;&gt; D &lt;&lt;&lt;&lt;&lt;\n#include \"ch13_4_vport.h\"\n\nVintagePort::VintagePort() \n    : Port()\n{\n    nickname = new char[1];\n    nickname[0] = '\\0';\n\n    year = 0;\n}\n\nVintagePort::VintagePort(const char *br, int b, const char *nn, int y) \n    : Port(br, \"none\", b)\n{\n    nickname = new char[strlen(nn) + 1];\n    strcpy(nickname, nn);\n    nickname[strlen(nn)]  = '\\0';\n\n    year = y;\n}\n\nVintagePort::VintagePort(const VintagePort &amp;vp)\n    : Port(vp)\n{\n    nickname = new char[strlen(vp.nickname) + 1];\n    strcpy(nickname, vp.nickname);\n    nickname[strlen(vp.nickname)] = '\\0';\n\n    year = vp.year;\n}\n\nVintagePort &amp;VintagePort::operator=(const VintagePort &amp;vp)\n{\n    if(this == &amp;vp)\n        return *this;\n\n    Port::operator=(vp);\n\n    delete[] nickname;\n    nickname = new char[strlen(vp.nickname) + 1];\n    strcpy(nickname, vp.nickname);\n    nickname[strlen(vp.nickname)] = '\\0';\n\n    year = vp.year;\n\n    return *this;\n}\n\nvoid VintagePort::Show() const\n{\n    Port::Show();\n    cout &lt;&lt; \"Nickname: \"   &lt;&lt; nickname &lt;&lt; endl;\n    cout &lt;&lt; \"Year\"         &lt;&lt; year &lt;&lt; endl;\n}\n\nostream &amp;operator&lt;&lt;(ostream &amp;os, const VintagePort &amp;vp)\n{\n    os &lt;&lt; (const Port &amp;)vp;\n    os &lt;&lt; \", \" &lt;&lt; vp.nickname &lt;&lt; \", \" &lt;&lt; vp.year;\n    return os;\n}\n</code></pre> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include \"ch13_4_vport.h\"\n\nconst int BASES = 2;\nint main(){\n    using std::cin;\n    using std::cout;\n    using std::endl;\n\n    Port *civBases[BASES];\n    VintagePort *civHist[BASES];\n\n    char *tmp_brand, *tmp_style;\n    char *tmp_nickname;\n\n    int bottles;\n    int years; \n\n    for (int i = 0; i &lt; BASES; ++i)\n    {\n        cout &lt;&lt; \"\\nEnter brand of \" &lt;&lt; i + 1 &lt;&lt; \" bottled port: \";\n        tmp_brand = new char[30];\n        cin.getline(tmp_brand, 30);\n\n        cout &lt;&lt; \"Enter type of the bottled port: \";\n        tmp_style = new char[30];\n        cin.getline(tmp_style, 30);\n\n        cout &lt;&lt; \"Enter number of bottles in \" &lt;&lt; tmp_brand &lt;&lt; \" port: \";\n        while (!(cin &gt;&gt; bottles))\n        {\n            cin.clear();    // reset input\n            while (cin.get() != '\\n')\n                continue;   // get rid of bad input\n            cout &lt;&lt; \"Please enter a number: \";\n        }\n\n        civBases[i] = new Port(tmp_brand, tmp_style, bottles);\n\n        delete tmp_brand, tmp_style;\n\n        while (cin.get() != '\\n')\n            continue;\n    }\n\n    for (int i = 0; i &lt; BASES; ++i)\n    {\n        cout &lt;&lt; \"\\nEnter brand of \" &lt;&lt; i + 1 &lt;&lt; \" historical bottled port: \";\n        tmp_brand = new char[30];\n        cin.getline(tmp_brand, 30);\n\n        cout &lt;&lt; \"Enter nickname of the historical bottled port: \";\n        tmp_nickname = new char[30];\n        cin.getline(tmp_nickname, 30);\n\n        cout &lt;&lt; \"Enter number of bottles in \" &lt;&lt; tmp_brand &lt;&lt; \" historical port: \";\n        while (!(cin &gt;&gt; bottles))\n        {\n            cin.clear();    // reset input\n            while (cin.get() != '\\n')\n                continue;   // get rid of bad input\n            cout &lt;&lt; \"Please enter a number: \";\n        }\n\n        cout &lt;&lt; \"Enter founding year of \" &lt;&lt; tmp_brand &lt;&lt; \" historical port: \";\n        while (!(cin &gt;&gt; years))\n        {\n            cin.clear();    // reset input\n            while (cin.get() != '\\n')\n                continue;   // get rid of bad input\n            cout &lt;&lt; \"Please enter a number: \";\n        }\n\n        civHist[i] = new VintagePort(tmp_brand, bottles, tmp_nickname, years);\n\n        delete tmp_brand, tmp_nickname;\n\n        while (cin.get() != '\\n')\n            continue;\n    }\n\n    cout &lt;&lt; endl;\n    cout &lt;&lt; \"Result : \\n\";\n    for (int i = 0; i &lt; BASES; i++)\n    {\n        civBases[i]-&gt;Show();\n        cout &lt;&lt; endl;\n    }\n\n    for (int i = 0; i &lt; BASES; i++)\n    {\n        civHist[i]-&gt;Show();\n        cout &lt;&lt; endl;\n    }\n\n    cout &lt;&lt; \"\\nAssigning first two Ports as the same and display via &lt;&lt; :\\n\";\n\n    *civBases[0] = *civBases[1];\n    *civHist[0] = *civHist[1];\n\n    for (int i = 0; i &lt; BASES; i++)\n    {\n        cout &lt;&lt; \"Port \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt;  *civBases[i];\n        cout &lt;&lt; endl;\n    }\n\n    for (int i = 0; i &lt; BASES; i++)\n    {\n        cout &lt;&lt; \"Historical port \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt;  *civHist[i];\n        cout &lt;&lt; endl;\n    }\n\n    cout &lt;&lt; \"\\nDefault constructor:\\n\";\n    Port emptyPort;\n    VintagePort EmptyHPort;\n\n    cout &lt;&lt; \"Empty, default ports: \\n\";\n    cout &lt;&lt; emptyPort &lt;&lt; EmptyHPort;\n\n    for (int i = 0; i &lt; BASES; i++)\n    {\n        delete civBases[i];\n        delete civHist[i];\n    }\n    cout &lt;&lt; \"Done.\\n\";\n\n    return 0;\n}\n</code></pre>"},{"location":"exercises/#chapter-14","title":"Chapter 14","text":"<p>1 - The <code>Wine</code> class has a <code>string</code> class object member (see Chapter 4) that holds the name of a wine and a <code>Pair</code> object (as discussed in this chapter) of <code>valarray objects (as discussed in this chapter).The first member of each <code>Pair</code> object holds the vintage years, and the second member holds the numbers of bottles owned for the corresponding particular vintage year. For example, the first <code>valarray</code> object of the <code>Pair</code> object might hold the years 1988, 1992, and 1996, and the second <code>valarray</code> object might hold the bottle counts 24, 48, and 144. It may be convenient for <code>Wine</code> to have an <code>int</code> member that stores the number of years. Also some typedefs might be useful to simplify the coding: <pre><code>typedef std::valarray&lt;int&gt; ArrayInt;\ntypedef Pair&lt;ArrayInt, ArrayInt&gt; PairArray;\n</code></pre> <p>Thus, the <code>PairArray</code> type represents type <code>Pair&lt;std::valarray, std::valarray . Implement the <code>Wine</code> class by using containment. The class should have a default constructor and at least the following constructors: <pre><code>// initialize label to l, number of years to y,\n// vintage years to yr[], bottles to bot[]\nWine(const char * l, int y, const int yr[], const int bot[]);\n// initialize label to l, number of years to y,\n// create array objects of length y\nWine(const char * l, int y);\n</code></pre> <p>The <code>Wine</code> class should have a method <code>GetBottles()</code> that, given a <code>Wine</code> object with <code>y</code> years, prompts the user to enter the corresponding number of vintage years and bottle counts. A method <code>Label()</code> should return a reference to the wine name. A method <code>sum()</code> should return the total number of bottles in the second <code>valarray object in the <code>Pair</code> object. <p>The program should prompt the user to enter a wine name, the number of elements of the array, and the year and bottle count information for each array element. The program should use this data to construct a <code>Wine</code> object and then display the information stored in the object. For guidance, here\u2019s a sample test program:</p> <pre><code>// pe14-1.cpp -- using Wine class with containment\n#include &lt;iostream&gt;\n#include \"winec.h\"\nint main(void)\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n\n    cout &lt;&lt; \"Enter name of wine: \";\n    char lab[50];\n    cin.getline(lab, 50);\n\n    cout &lt;&lt; \"Enter number of years: \";\n    int yrs;\n    cin &gt;&gt; yrs;\n\n    Wine holding(lab, yrs); // store label, years, give arrays yrs elements\n    holding.GetBottles();   // solicit input for year, bottle count\n    holding.Show();         // display object contents\n\n    const int YRS = 3;\n    int y[YRS] = {1993, 1995, 1998};\n    int b[YRS] = {48, 60, 72};\n    // create new object, initialize using data in arrays y and b\n    Wine more(\"Gushing Grape Red\", YRS, y, b);\n    more.Show();\n    cout &lt;&lt; \"Total bottles for \" &lt;&lt; more.Label() // use Label() method\n         &lt;&lt; \": \" &lt;&lt; more.sum() &lt;&lt; endl;          // use sum() method\n    cout &lt;&lt; \"Bye\\n\";\n    return 0;\n}\n</code></pre> <pre><code>And here\u2019s some sample output:\nEnter name of wine: Gully Wash\nEnter number of years: 4\nEnter Gully Wash data for 4 year(s):\nEnter year: 1988\nEnter bottles for that year: 42\nEnter year: 1994\nEnter bottles for that year: 58\nEnter year: 1998\nEnter bottles for that year: 122\nEnter year: 2001\nEnter bottles for that year: 144\nWine: Gully Wash\nYear Bottles\n1988 42\n1994 58\n1998 122\n2001 144\nWine: Gushing Grape Red\nYear Bottles\n1993 48\n1995 60\n1998 72\nTotal bottles for Gushing Grape Red: 180\nBye\n</code></pre> Code - classes prototypes <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;valarray&gt;\n\n#ifndef _WINE_H_\n#define _WINE_H_\n\nclass Wine\n{\nprivate:\n    typedef std::valarray&lt;int&gt; ArrayInt;\n    typedef std::pair&lt;ArrayInt, ArrayInt&gt; PairArray;\n    std::string s_Name;\n    PairArray pa_Data; // Pair &lt;vintage years, bootles&gt;\npublic:\n    // default constructor\n    Wine();\n    // initialize label to l, number of years to y,\n    // vintage years to yr[], bottles to bot[]\n    Wine(const char *l, int y, const int yr[], const int bot[]);\n    // initialize label to l, number of years to y,\n    // create array objects of length y\n    Wine(const char *l, int y);\n\n    ~Wine();\n\n    void GetBottles();\n    void Show();\n\n    const std::string &amp;Label();\n    int sum(); \n};\n\n#endif\n</code></pre> Code - classes methods <pre><code>#include \"ch14_1_wine.h\"\n\n/// Constructors ///\nWine::Wine()\n{\n    s_Name = \"\";\n}\n\nWine::Wine(const char *l, int y)\n{\n    s_Name = l;\n    pa_Data.first.resize(y);\n    pa_Data.second.resize(y);\n}\n\nWine::Wine(const char *l, int y, const int yr[], const int bot[])\n{\n    s_Name = l;\n    pa_Data.first.resize(y);\n    pa_Data.second.resize(y);\n\n    for (int i{}; i &lt; y; i++)\n    {\n        pa_Data.first[i] = yr[i];\n        pa_Data.second[i] = bot[i];\n    }\n}\n\n/// Destructors ///\nWine::~Wine()\n{\n}\n\n/// Methods ///\nvoid Wine::GetBottles()\n{\n    std::cout &lt;&lt; \"Enter \" &lt;&lt; s_Name &lt;&lt; \" data for \"\n              &lt;&lt; pa_Data.first.size() &lt;&lt; \" year(s): \" &lt;&lt; std::endl;\n    for (int i = 0; i &lt; pa_Data.first.size(); ++i)\n    {\n        std::cout &lt;&lt; \"Enter year: \";\n        std::cin &gt;&gt; pa_Data.first[i];\n        std::cout &lt;&lt; \"Enter bootles for that year: \";\n        std::cin &gt;&gt; pa_Data.second[i];\n    }\n}\n\nconst std::string &amp;Wine::Label()\n{\n    return s_Name;\n}\n\nvoid Wine::Show()\n{\n    std::cout &lt;&lt; \"Wine: \" &lt;&lt; s_Name &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Year  Bottles\" &lt;&lt; std::endl;\n    for (int i = 0; i &lt; pa_Data.first.size(); ++i)\n    {\n        std::cout &lt;&lt; pa_Data.first[i] &lt;&lt; \"  \";\n        std::cout &lt;&lt; pa_Data.second[i] &lt;&lt; std::endl;\n    }\n}\n\nint Wine::sum()\n{\n    int _sum{};\n    for (int i = 0; i &lt; pa_Data.first.size(); ++i)\n    {\n        _sum += pa_Data.second[i];\n    }\n    return _sum;\n}\n</code></pre> Code - program <pre><code>// pe14-1.cpp -- using Wine class with containment\n#include &lt;iostream&gt;\n#include \"ch14_1_wine.h\"\n\nint main(void)\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n\n    cout &lt;&lt; \"Enter name of wine: \";\n    char lab[50];\n    cin.getline(lab, 50);\n\n    cout &lt;&lt; \"Enter number of years: \";\n    int yrs;\n    cin &gt;&gt; yrs;\n\n    Wine holding(lab, yrs); // store label, years, give arrays yrs elements\n    holding.GetBottles();   // solicit input for year, bottle count\n    holding.Show();         // display object contents\n\n    const int YRS = 3;\n    int y[YRS] = {1993, 1995, 1998};\n    int b[YRS] = {48, 60, 72};\n    // create new object, initialize using data in arrays y and b\n    Wine more(\"Gushing Grape Red\", YRS, y, b);\n    more.Show();\n    cout &lt;&lt; \"Total bottles for \" &lt;&lt; more.Label() // use Label() method\n         &lt;&lt; \": \" &lt;&lt; more.sum() &lt;&lt; endl;          // use sum() method\n    cout &lt;&lt; \"Bye\\n\";\n    return 0;\n}\n\n/*\nAnd here\u2019s some sample of expected output:\nEnter name of wine: Gully Wash\nEnter number of years: 4\nEnter Gully Wash data for 4 year(s):\nEnter year: 1988\nEnter bottles for that year: 42\nEnter year: 1994\nEnter bottles for that year: 58\nEnter year: 1998\nEnter bottles for that year: 122\nEnter year: 2001\nEnter bottles for that year: 144\nWine: Gully Wash\nYear Bottles\n1988 42\n1994 58\n1998 122\n2001 144\nWine: Gushing Grape Red\nYear Bottles\n1993 48\n1995 60\n1998 72\nTotal bottles for Gushing Grape Red: 180\nBye\n*/\n</code></pre> <p>2 - This exercise is the same as Programming Exercise 1, except that you should use private inheritance instead of containment. Again, a few <code>typedefs<code> might prove handy. Also you might contemplate the meaning of statements such as the following: <pre><code>PairArray::operator=(PairArray(ArrayInt(),ArrayInt()));\ncout &lt;&lt; (const string &amp;)(*this);\n</code></pre> <p>The class should work with the same test program as shown in Programming Exercise 1.</p> Code - classes prototypes <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;valarray&gt;\n\n#ifndef _WINE_H_\n#define _WINE_H_\n\ntypedef  std::valarray&lt;int&gt; ArrayInt;\ntypedef  std::pair&lt;ArrayInt, ArrayInt&gt; PairArray;\n\nclass Wine : private std::string, private PairArray\n{\npublic:\n    // default constructor\n    Wine();\n    // initialize label to l, number of years to y,\n    // vintage years to yr[], bottles to bot[]\n    Wine(const char *l, int y, const int yr[], const int bot[]);\n    // initialize label to l, number of years to y,\n    // create array objects of length y\n    Wine(const char *l, int y);\n\n    ~Wine();\n\n    void GetBottles();\n    void Show();\n\n    const std::string &amp;Label() const;\n    int sum(); \n};\n\n#endif\n</code></pre> Code - classes methods <pre><code>#include \"ch14_2_wine.h\"\n\n/// Constructors ///\nWine::Wine() :  std::string(\"\")\n{\n}\n\nWine::Wine(const char *l, int y) : std::string(l), PairArray(ArrayInt(y),ArrayInt(y))\n{\n}\n\nWine::Wine(const char *l, int y, const int yr[], const int bot[]) : std::string(l), PairArray(ArrayInt(y),ArrayInt(y))\n{\n    for (int i{}; i &lt; y; i++)\n    {\n        PairArray::first[i] = yr[i];\n        PairArray::second[i] = bot[i];\n    }\n}\n\n/// Destructors ///\nWine::~Wine()\n{\n}\n\n/// Methods ///\nvoid Wine::GetBottles()\n{\n    std::cout &lt;&lt; \"Enter \" &lt;&lt; std::string(*this) &lt;&lt; \" data for \"\n              &lt;&lt; PairArray::first.size() &lt;&lt; \" year(s): \" &lt;&lt; std::endl;\n    for (int i = 0; i &lt; PairArray::first.size(); ++i)\n    {\n        std::cout &lt;&lt; \"Enter year: \";\n        std::cin &gt;&gt; PairArray::first[i];\n        std::cout &lt;&lt; \"Enter bootles for that year: \";\n        std::cin &gt;&gt; PairArray::second[i];\n    }\n}\n\nconst std::string &amp;Wine::Label() const\n{\n    return (const std::string &amp;)(*this);\n}\n\nvoid Wine::Show()\n{\n    std::cout &lt;&lt; \"Wine: \" &lt;&lt; std::string(*this) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Year  Bottles\" &lt;&lt; std::endl;\n    for (int i = 0; i &lt; PairArray::first.size(); ++i)\n    {\n        std::cout &lt;&lt; PairArray::first[i] &lt;&lt; \"  \";\n        std::cout &lt;&lt; PairArray::second[i] &lt;&lt; std::endl;\n    }\n}\n\nint Wine::sum()\n{\n    int _sum{};\n    for (int i = 0; i &lt; PairArray::first.size(); ++i)\n    {\n        _sum += PairArray::second[i];\n    }\n    return _sum;\n}\n</code></pre> Code - program <pre><code>// pe14-1.cpp -- using Wine class with containment\n#include &lt;iostream&gt;\n#include \"ch14_2_wine.h\"\n\nint main(void)\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n\n    cout &lt;&lt; \"Enter name of wine: \";\n    char lab[50];\n    cin.getline(lab, 50);\n\n    cout &lt;&lt; \"Enter number of years: \";\n    int yrs;\n    cin &gt;&gt; yrs;\n\n    Wine holding(lab, yrs); // store label, years, give arrays yrs elements\n    holding.GetBottles();   // solicit input for year, bottle count\n    holding.Show();         // display object contents\n\n    const int YRS = 3;\n    int y[YRS] = {1993, 1995, 1998};\n    int b[YRS] = {48, 60, 72};\n    // create new object, initialize using data in arrays y and b\n    Wine more(\"Gushing Grape Red\", YRS, y, b);\n    more.Show();\n    cout &lt;&lt; \"Total bottles for \" &lt;&lt; more.Label() // use Label() method\n         &lt;&lt; \": \" &lt;&lt; more.sum() &lt;&lt; endl;          // use sum() method\n    cout &lt;&lt; \"Bye\\n\";\n    return 0;\n}\n\n/*\nAnd here\u2019s some sample of expected output:\nEnter name of wine: Gully Wash\nEnter number of years: 4\nEnter Gully Wash data for 4 year(s):\nEnter year: 1988\nEnter bottles for that year: 42\nEnter year: 1994\nEnter bottles for that year: 58\nEnter year: 1998\nEnter bottles for that year: 122\nEnter year: 2001\nEnter bottles for that year: 144\nWine: Gully Wash\nYear Bottles\n1988 42\n1994 58\n1998 122\n2001 144\nWine: Gushing Grape Red\nYear Bottles\n1993 48\n1995 60\n1998 72\nTotal bottles for Gushing Grape Red: 180\nBye\n*/\n</code></pre> <p>3 - Define a <code>QueueTp</code> template. Test it by creating a queue of pointers-to-Worker (as defined in Listing 14.10 ) and using the queue in a program similar to that in Listing 14.12 . Code - classes prototypes of listing 14.10 <pre><code>#ifndef WORKERMI_H_\n#define WORKERMI_H_\n#include &lt;string&gt;\nclass Worker // an abstract base class\n{\nprivate:\n    std::string fullname;\n    long id;\n\nprotected:\n    virtual void Data() const;\n    virtual void Get();\n\npublic:\n    Worker() : fullname(\"no one\"), id(0L) {}\n    Worker(const std::string &amp;s, long n)\n        : fullname(s), id(n) {}\n    virtual ~Worker() = 0; // pure virtual function\n    virtual void Set() = 0;\n    virtual void Show() const = 0;\n};\n\nclass Waiter : virtual public Worker\n{\nprivate:\n    int panache;\n\nprotected:\n    void Data() const;\n    void Get();\n\npublic:\n    Waiter() : Worker(), panache(0) {}\n    Waiter(const std::string &amp;s, long n, int p = 0)\n        : Worker(s, n), panache(p) {}\n    Waiter(const Worker &amp;wk, int p = 0)\n        : Worker(wk), panache(p) {}\n    void Set();\n    void Show() const;\n};\n\nclass Singer : virtual public Worker\n{\nprotected:\n    enum\n    {\n        other,\n        alto,\n        contralto,\n        soprano,\n        bass,\n        baritone,\n        tenor\n    };\n    enum\n    {\n        Vtypes = 7\n    };\n    void Data() const;\n    void Get();\n\nprivate:\n    static const char *pv[Vtypes]; // string equivs of voice types\n    int voice;\n\npublic:\n    Singer() : Worker(), voice(other) {}\n    Singer(const std::string &amp;s, long n, int v = other)\n        : Worker(s, n), voice(v) {}\n    Singer(const Worker &amp;wk, int v = other)\n        : Worker(wk), voice(v) {}\n    void Set();\n    void Show() const;\n};\n// multiple inheritance\nclass SingingWaiter : public Singer, public Waiter\n{\nprotected:\n    void Data() const;\n    void Get();\n\npublic:\n    SingingWaiter() {}\n    SingingWaiter(const std::string &amp;s, long n, int p = 0,\n                  int v = other)\n        : Worker(s, n), Waiter(s, n, p), Singer(s, n, v) {}\n    SingingWaiter(const Worker &amp;wk, int p = 0, int v = other)\n        : Worker(wk), Waiter(wk, p), Singer(wk, v) {}\n    SingingWaiter(const Waiter &amp;wt, int v = other)\n        : Worker(wt), Waiter(wt), Singer(wt, v) {}\n    SingingWaiter(const Singer &amp;wt, int p = 0)\n        : Worker(wt), Waiter(wt, p), Singer(wt) {}\n    void Set();\n    void Show() const;\n};\n#endif\n</code></pre> Code - classes methods of listing 14.10 <pre><code>#include \"ch14_3_listing.h\"\n#include &lt;iostream&gt;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\n// Worker methods\nWorker::~Worker() {}\n\n// protected methods\nvoid Worker::Data() const\n{\n    cout &lt;&lt; \"Name: \" &lt;&lt; fullname &lt;&lt; endl;\n    cout &lt;&lt; \"Employee ID: \" &lt;&lt; id &lt;&lt; endl;\n}\nvoid Worker::Get()\n{\n    getline(cin, fullname);\n    cout &lt;&lt; \"Enter worker's ID: \";\n    cin &gt;&gt; id;\n    while (cin.get() != '\\n')\n        continue;\n}\n\n// Waiter methods\nvoid Waiter::Set()\n{\n    cout &lt;&lt; \"Enter waiter's name: \";\n    Worker::Get();\n    Get();\n}\n\nvoid Waiter::Show() const\n{\n    cout &lt;&lt; \"Category: waiter\\n\";\n    Worker::Data();\n    Data();\n}\n\n// protected methods\nvoid Waiter::Data() const\n{\n    cout &lt;&lt; \"Panache rating: \" &lt;&lt; panache &lt;&lt; endl;\n}\nvoid Waiter::Get()\n{\n    cout &lt;&lt; \"Enter waiter's panache rating: \";\n    cin &gt;&gt; panache;\n    while (cin.get() != '\\n')\n        continue;\n}\n\n// Singer methods\n// char *Singer::pv[Singer::Vtypes] = {\"other\", \"alto\", \"contralto\",\"soprano\", \"bass\", \"baritone\", \"tenor\"};\nconst char* Singer::pv[Singer::Vtypes] = {\"other\", \"alto\", \"contralto\",\"soprano\", \"bass\", \"baritone\", \"tenor\"};\n\nvoid Singer::Set()\n{\n    cout &lt;&lt; \"Enter singer's name: \";\n    Worker::Get();\n    Get();\n}\nvoid Singer::Show() const\n{\n    cout &lt;&lt; \"Category: singer\\n\";\n    Worker::Data();\n    Data();\n}\n\n// protected methods\nvoid Singer::Data() const\n{\n    cout &lt;&lt; \"Vocal range: \" &lt;&lt; pv[voice] &lt;&lt; endl;\n}\nvoid Singer::Get()\n{\n    cout &lt;&lt; \"Enter number for singer's vocal range:\\n\";\n    int i;\n    for (i = 0; i &lt; Vtypes; i++)\n    {\n        cout &lt;&lt; i &lt;&lt; \": \" &lt;&lt; pv[i] &lt;&lt; \" \";\n        if (i % 4 == 3)\n            cout &lt;&lt; endl;\n    }\n    if (i % 4 != 0)\n        cout &lt;&lt; '\\n';\n    cin &gt;&gt; voice;\n    while (cin.get() != '\\n')\n        continue;\n}\n\n// SingingWaiter methods\nvoid SingingWaiter::Data() const\n{\n    Singer::Data();\n    Waiter::Data();\n}\nvoid SingingWaiter::Get()\n{\n    Waiter::Get();\n    Singer::Get();\n}\nvoid SingingWaiter::Set()\n{\n    cout &lt;&lt; \"Enter singing waiter's name: \";\n    Worker::Get();\n    Get();\n}\nvoid SingingWaiter::Show() const\n{\n    cout &lt;&lt; \"Category: singing waiter\\n\";\n    Worker::Data();\n    Data();\n}\n</code></pre> <p>Methods like below will only work in the same place as prototypes</p> <pre><code>template &lt;typename T&gt;\nbool QueueTp&lt;T&gt;::method(){}\n</code></pre> <p>For template methods in files outside of a header, you need to use <code>template &lt;&gt;</code> with specified data recovered via <code>T</code>;</p> <pre><code>template &lt;&gt;\nQueueTp&lt;Worker*&gt;::Method(){}\n</code></pre> Code - classes prototypes and methods <pre><code>#ifndef QUEUE_TP_H_\n#define QUEUE_TP_H_\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;typeinfo&gt; // check for class type pointers https://en.cppreference.com/w/cpp/types/is_pointer\n#include \"ch14_3_listing.h\"\n\n// based on exercise 12_5 queue\ntemplate &lt;typename T&gt;\nclass QueueTp\n{\nprivate:\n    // Node is a nested structure definition local to this class\n    struct Node\n    {\n        T item;\n        struct Node *next;\n    };\n\n    // static int Q_SIZE {10};     // modifiable static value - will workj the same in this case\n    enum // constant value that won't change throughout the program,\n    {\n        Q_SIZE = 10\n    };\n\n    // private class members\n    Node *front;     // pointer to front of Queue\n    Node *rear;      // pointer to rear of Queue\n    int items;       // current number of items in Queue\n    const int qsize; // maximum number of items in Queue\n\n    // Preemptive definitions to prevent public copying\n    // (you can also make deep copy definitions instead)\n    QueueTp(const QueueTp &amp;q) : qsize(0) {}\n    QueueTp &amp;operator=(const QueueTp &amp;q) { return *this; }\n\npublic:\n    QueueTp(int qs = Q_SIZE); // default constructor for QueueTp queue with a qs limit\n    QueueTp(T);               // create queue with a T value\n    ~QueueTp();\n\n    bool isempty() const;\n    bool isfull() const;\n    int queuecount() const;\n    void show() const;\n\n    bool enqueue(const T &amp;item); // add item to end\n    bool dequeue(T &amp;item);       // remove item from front\n};\n#endif\n\n\n/// Constructors ///\ntemplate &lt;typename T&gt;\nQueueTp&lt;T&gt;::QueueTp(int qs) : qsize(qs)\n{\n    front = rear = NULL; // or nullptr\n    items = 0;\n}\n\ntemplate &lt;typename T&gt;\nQueueTp&lt;T&gt;::QueueTp(T)\n{\n    Node *temp;\n    while (front != NULL) // while queue is not yet empty\n    {\n        temp = front;        // save address of front item\n        enqueue(temp-&gt;item); // add item to the end\n        front = front-&gt;next; // reset pointer to next item\n        delete temp;         // delete former front\n    }\n}\n\ntemplate &lt;typename T&gt;\nQueueTp&lt;T&gt;::~QueueTp()\n{\n    Node *temp;\n    while (front != NULL) // while queue is not yet empty\n    {\n        temp = front;        // save address of front item\n        front = front-&gt;next; // reset pointer to next item\n        delete temp;         // delete former front\n    }\n}\n\n/// Methods ///\ntemplate &lt;typename T&gt;\nbool QueueTp&lt;T&gt;::isempty() const\n{\n    return items == 0;\n}\n\ntemplate &lt;typename T&gt;\nbool QueueTp&lt;T&gt;::isfull() const\n{\n    return items == qsize;\n}\n\ntemplate &lt;typename T&gt;\nint QueueTp&lt;T&gt;::queuecount() const\n{\n    return items;\n}\n\n// Add item to queue\ntemplate &lt;typename T&gt;\nbool QueueTp&lt;T&gt;::enqueue(const T &amp;item)\n{\n    if (isfull())\n        return false;\n    Node *add = new Node; // create node\n\n    // on failure, new throws std::bad_alloc exception\n    add-&gt;item = item; // set node pointers\n    add-&gt;next = NULL; // or nullptr;\n    items++;\n    if (front == NULL) // if queue is empty,\n        front = add;   // place item at front\n    else\n        rear-&gt;next = add; // else place at rear\n    rear = add;           // have rear point to new node\n    return true;\n}\n\n// Place front item into item variable and remove from queue\ntemplate &lt;typename T&gt;\nbool QueueTp&lt;T&gt;::dequeue(T &amp;item)\n{\n    if (front == NULL)\n        return false;\n    item = front-&gt;item; // set item to first item in queue\n    items--;\n    Node *temp = front;  // save location of first item\n    front = front-&gt;next; // reset front to next item\n    delete temp;         // delete former first item\n    if (items == 0)\n        rear = NULL;\n    return true;\n}\n\ntemplate &lt;typename T&gt;\nvoid QueueTp&lt;T&gt;::show() const\n{\n    std::cout &lt;&lt; \"Number of all items in QueueTp: \" &lt;&lt; items - 1 &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Current item on the end of QueueTp\\n\";\n\n    // due to MI, derived classes will be detected as ABC class\n    if (typeid(front-&gt;item) == typeid(Worker *))\n    {\n        front-&gt;item-&gt;Show();\n    }\n    else if (std::is_pointer_v&lt;T&gt;)\n    {\n        std::cout &lt;&lt; \"\\n\\tPointer to unknown class\";\n    }\n    else\n    {\n        std::cout &lt;&lt; \"\\n\\tPointer to unknown data\";\n    }\n}\n</code></pre> Code - program <pre><code>// workmi.cpp -- multiple inheritance\n// compile with workermi.cpp\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\n// #include \"ch14_3_listing.h\"\n#include \"ch14_3_wk.h\"\n\nconst int SIZE = 5;\n\nint main()\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n    using std::strchr;\n\n    Worker *lolas;                      // Worker *lolas[SIZE];\n    QueueTp&lt;Worker *&gt; lolasQueue;       //\n\n    int ct;\n\n    for (ct = 0; ct &lt; SIZE; ct++)\n    {\n        char choice;\n        cout &lt;&lt; \"Enter the employee category:\\n\"\n             &lt;&lt; \"w: waiter s: singer \"\n             &lt;&lt; \"t: singing waiter q: quit\\n\";\n        cin &gt;&gt; choice;\n        while (strchr(\"wstq\", choice) == NULL)\n        {\n            cout &lt;&lt; \"Please enter a w, s, t, or q: \";\n            cin &gt;&gt; choice;\n        }\n        if (choice == 'q')\n            break;\n        switch (choice)\n        {\n        case 'w':\n            lolas = new Waiter;         // lolas[ct] = new Waiter;\n            break;\n        case 's':\n            lolas = new Singer;         // lolas[ct] = new Singer;\n            break;\n        case 't':\n            lolas = new SingingWaiter;  // lolas[ct] = new SingingWaiter; \n            break;\n        }\n        cin.get();\n        lolas-&gt;Set();                   // lolas[ct]-&gt;Set();\n\n        lolasQueue.enqueue(lolas);\n    }\n\n    cout &lt;&lt; \"\\nHere is your staff:\\n\";\n    int i;\n\n    for (i = 0; i &lt; ct; i++)\n    {\n        cout &lt;&lt; endl;\n        lolasQueue.show();              // lolas-&gt;Show();\n        lolasQueue.dequeue(lolas);      // it will automatically handle delete\n        // delete lolas;\n    }\n\n    delete lolas; //  \n\n    // for (i = 0; i &lt; ct; i++)\n    //     delete lolas[i];\n\n    cout &lt;&lt; \"Bye.\\n\";\n    return 0;\n}\n\n/*\nHere is a sample run of the program in Listings 14.10, 14.11, and 14.12:\nEnter the employee category:\nw: waiter s: singer t: singing waiter q: quit\nw\nEnter waiter's name: Wally Slipshod\nEnter worker's ID: 1040\nEnter waiter's panache rating: 4\nEnter the employee category:\nw: waiter s: singer t: singing waiter q: quit\ns\nEnter singer's name: Sinclair Parma\nEnter worker's ID: 1044\nEnter number for singer's vocal range:\n0: other 1: alto 2: contralto 3: soprano\n4: bass 5: baritone 6: tenor\n5\nEnter the employee category:\nw: waiter s: singer t: singing waiter q: quit\nt\nEnter singing waiter's name: Natasha Gargalova\nEnter worker's ID: 1021\nEnter waiter's panache rating: 6\nEnter number for singer's vocal range:\n0: other 1: alto 2: contralto 3: soprano\n4: bass 5: baritone 6: tenor\n3\nEnter the employee category:\nw: waiter s: singer t: singing waiter q: quit\nq\nHere is your staff:\nCategory: waiter\nName: Wally Slipshod\n\nEmployee ID: 1040\nPanache rating: 4\nCategory: singer\nName: Sinclair Parma\nEmployee ID: 1044\nVocal range: baritone\nCategory: singing waiter\nName: Natasha Gargalova\nEmployee ID: 1021\nVocal range: soprano\nPanache rating: 6\nBye.\n*/\n</code></pre> <p>Compile using: <pre><code>g++ ch14_3.cpp ch14_3_listing.cpp \n</code></pre></p> <p>4 - A <code>Person</code> class holds the first name and the last name of a person. In addition to its constructors, it has a <code>Show()</code> method that displays both names. A <code>Gunslinger</code> class derives virtually from the Person class. It has a <code>Draw()</code> member that returns a type double value representing a gunslinger\u2019s draw time. The class also has an int member representing the number of notches on a gunslinger\u2019s gun. Finally, it has a <code>Show()</code> function that displays all this information.</p> <p>A <code>PokerPlayer</code> class derives virtually from the Person class. It has a <code>Draw()</code> member that returns a random number in the range 1 through 52, representing a card value. (Optionally, you could define a <code>Card</code> class with suit and face value members and use a Card return value for Draw().) The <code>PokerPlayer</code> class uses the Person <code>show()</code> function.The <code>BadDude</code> class derives publicly from the <code>Gunslinger</code> and PokerPlayer classes. It has a <code>Gdraw()</code> member that returns a bad dude\u2019s draw time and a <code>Cdraw()</code> member that returns the next card drawn. It has an appropriate <code>Show()</code> function. Define all these classes and methods, along with any other necessary methods (such as methods for setting object values) and test them in a simple program similar to that in Listing 14.12.</p> Code - classes prototypes <pre><code>#ifndef _PPL_H_\n#define _PPL_H_\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;random&gt; // for Gunslinger::Draw\n\n// ---------------------------------\nclass Person\n{\nprivate:\n    std::string sFirstName;\n    std::string sLastName;\n\npublic:\n    Person(std::string fn = \"\", std::string ln = \"\"); // Inefficient constructor but simple\n    // Person::Person(std::string&amp;&amp; fn = \"\", std::string&amp;&amp; ln = \"\");      // Efficient constructor (pass by ref)\n    ~Person();\n\n    virtual void Show() const;\n    virtual void Set();\n};\n\n// ---------------------------------\nclass Gunslinger : virtual public Person\n{\nprivate:\n    int iNotches;\n\npublic:\n    Gunslinger(int notc = 6, std::string fn = \"\", std::string ln = \"\");\n    ~Gunslinger(){};\n\n    double Draw();\n    virtual void Show() const;\n    virtual void Set();\n};\n\n// ---------------------------------\nclass PokerPlayer : virtual public Person\n{\npublic:\n    PokerPlayer(std::string fn = \"\", std::string ln = \"\") : Person(fn, ln){};\n    ~PokerPlayer();\n\n    int Draw();\n    virtual void Show() { Person::Show(); std::cout &lt;&lt; \"Type: Poker player\";  }; // PokerPlayer has to use Person::Show according to task;\n    virtual void Set(){ Person::Set(); };\n};\n\n// ---------------------------------\nclass BadDude : public Gunslinger, public PokerPlayer\n{\nprivate:\n    int iNextCard = 1;\n    double dDrawTime = (double)(rand() % 1000) / 1000; // Gunslinger is purely random, while BadDude have constant Draw Time\npublic:\n    BadDude(int notc = 6, std::string fn = \"\", std::string ln = \"\") : Person(), Gunslinger(), PokerPlayer(){};\n    ~BadDude();\n\n    double Gdraw(){ return dDrawTime; };\n    int Cdraw(){return iNextCard &gt; 51 ? iNextCard = 0 : ++iNextCard;};\n    virtual void Set();\n};\n\n#endif\n</code></pre> Code - classes methods <pre><code>#include \"ch14_4_ppl.h\"\n\n/// Person /// ---------------------------------\n\n//// Inefficient constructor - leverage copy constructor\nPerson::Person(std::string fn, std::string ln)\n{\n    sFirstName = fn;\n    sLastName = ln;\n}\n\n//// Efficient constructor -\n//  |lvalue - left operand modifiable value eg.: int asd, char asd |\n//  |rvalue - Pulls or fetches the value stored in a variable or constant to the right side |\n//  |int num = 39 | // to lvalue num, rvalue 39 is assigned\n//  | std::string&amp;&amp; - is known as an rvalue reference, which allows a function to accept arguments that are temporary objects or literal values.\n//  | std::string&amp;  - is a regular reference. It can only bind to existing objects, not literals or temporary objects.\n\n//// bind to temporary objects and rvalues. The std::move function is used to convert the lvalues to rvalues,\n//// enabling the move constructor of std::string to be invoked, which can be more efficient than the copy constructor\n\n// Person::Person(std::string&amp;&amp; fn, std::string&amp;&amp; ln) : firstName(std::move(fn)), lastName(std::move(ln))\n// {\n// }\n\nPerson::~Person()\n{\n}\n\nvoid Person::Show() const\n{\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"First name: \" &lt;&lt; sFirstName;\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Last name: \" &lt;&lt; sLastName;\n}\n\nvoid Person::Set()\n{\n    std::cin.clear(); // reset input\n    while (std::cin.get() != '\\n')\n        continue; // get rid of bad input\n\n    std::cout &lt;&lt; \"Enter first name: \";\n    std::getline(std::cin, sFirstName);\n    std::cout &lt;&lt; \"Enter last name: \";\n    std::getline(std::cin, sLastName);\n}\n\n/// Gunslinger /// ---------------------------------\nGunslinger::Gunslinger(int notc, std::string fn, std::string ln)\n    : Person(fn, ln)\n{\n    iNotches = notc;\n}\n// Gunslinger::Gunslinger(int notc, std::string fn, std::string ln) : Person(std::move(fn), std::move(ln)){}\n\n// return time of draw from 0 to 1 second\ndouble Gunslinger::Draw()\n{\n    // // Simpler my solution\n    return (double)(rand() % 1000) / 1000;\n\n    // // Simple solution\n    // double dMax = 1;\n    // double dMin = 0;\n    // double f = (double)rand() / RAND_MAX;\n    // return dMin + f * (dMax - dMin);\n\n    // //\n    // std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    // std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    // std::uniform_real_distribution&lt;&gt; dis(0.0, 1.0);\n    // return dis(gen);\n}\n\nvoid Gunslinger::Show() const\n{\n    Person::Show(); // can be used if Person::Show is also const cast\n\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Notches: \" &lt;&lt; iNotches;\n    std::cout &lt;&lt; \"Type: Gunslinger\";\n}\n\nvoid Gunslinger::Set()\n{\n    std::cout &lt;&lt; \"Enter number of notches on a gun: \";\n\n    while (!(std::cin &gt;&gt; iNotches || iNotches &lt;= 0))\n    {\n        std::cin.clear(); // reset input\n        while (std::cin.get() != '\\n')\n            continue; // get rid of bad input\n        std::cout &lt;&lt; \"Please enter a positive number: \";\n    }\n\n    Person::Set();\n}\n\n/// PokerPlayer /// ---------------------------------\n\n// return card value from 1 to 52\nint PokerPlayer::Draw()\n{\n    // simple solution\n    return rand() % 52 + 1;\n\n    // // Advanced solution\n    // std::random_device rd;\n    // std::mt19937 gen(rd());\n    // return std::uniform_int_distribution&lt;&gt;(1, 52)(gen);\n}\n\n/// BadDude /// ---------------------------------\n\nvoid BadDude::Set()\n{\n    std::cout &lt;&lt; \"Enter draw time to shoot: \";\n\n    while (!(std::cin &gt;&gt; dDrawTime || dDrawTime &lt;= 0))\n    {\n        std::cin.clear(); // reset input\n        while (std::cin.get() != '\\n')\n            continue; // get rid of bad input\n        std::cout &lt;&lt; \"Please enter a positive number: \";\n    }\n\n    Person::Set();\n}\n</code></pre> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include \"ch14_4_ppl.h\"\n\n// Listing 14.12 - changed only name of classes for obj creation and questions\nconst int SIZE = 5;\nint main()\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n    using std::strchr;\n    Person *lolas[SIZE];\n\n    int ct;\n    for (ct = 0; ct &lt; SIZE; ct++)\n    {\n        char choice;\n        cout &lt;&lt; \"Enter the player category:\\n\"\n             &lt;&lt; \"g: gunslinger p: poker player \"\n             &lt;&lt; \"b: bad dude  q: quit\\n\";\n        cin &gt;&gt; choice;\n        while (strchr(\"gpbq\", choice) == NULL)\n        {\n            cout &lt;&lt; \"Please enter a g, p, b, or q: \";\n            cin &gt;&gt; choice;\n        }\n        if (choice == 'q')\n            break;\n        switch (choice)\n        {\n        case 'g':\n            lolas[ct] = new Gunslinger;\n            break;\n        case 'p':\n            lolas[ct] = new PokerPlayer;\n            break;\n        case 'b':\n            lolas[ct] = new BadDude;\n            break;\n        }\n        cin.get();\n        lolas[ct]-&gt;Set();\n    }\n\n    cout &lt;&lt; \"\\nHere is your players:\\n\";\n\n    int i;\n    for (i = 0; i &lt; ct; i++)\n    {\n        cout &lt;&lt; endl;\n        lolas[i]-&gt;Show();\n    }\n\n    for (i = 0; i &lt; ct; i++)\n        delete lolas[i];\n\n    cout &lt;&lt; \"Bye.\\n\";\n    return 0;\n}\n</code></pre> <p>5 - Here are some class declarations:</p> <pre><code>// emp.h -- header file for abstr_emp class and children\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass abstr_emp\n{\nprivate:\n    std::string fname; // abstr_emp's first name\n    std::string lname; // abstr_emp's last name\n    std::string job;\n\npublic:\n    abstr_emp();\n    abstr_emp(const std::string &amp;fn, const std::string &amp;ln,\n              const std::string &amp;j);\n    virtual void ShowAll() const; // labels and shows all data\n    virtual void SetAll();        // prompts user for values\n    friend std::ostream &amp;\n    operator&lt;&lt;(std::ostream &amp;os, const abstr_emp &amp;e);\n    // just displays first and last name\n    virtual ~abstr_emp() = 0; // virtual base class\n};\nclass employee : public abstr_emp\n{\npublic:\n    employee();\n    employee(const std::string &amp;fn, const std::string &amp;ln,\n             const std::string &amp;j);\n    virtual void ShowAll() const;\n    virtual void SetAll();\n};\n\nclass manager : virtual public abstr_emp\n{\nprivate:\n    int inchargeof; // number of abstr_emps managed\nprotected:\n    int InChargeOf() const { return inchargeof; } // output\n    int &amp;InChargeOf() { return inchargeof; }      // input\npublic:\n    manager();\n    manager(const std::string &amp;fn, const std::string &amp;ln,\n            const std::string &amp;j, int ico = 0);\n    manager(const abstr_emp &amp;e, int ico);\n    manager(const manager &amp;m);\n    virtual void ShowAll() const;\n    virtual void SetAll();\n};\n\nclass fink : virtual public abstr_emp\n{\nprivate:\n    std::string reportsto; // to whom fink reports\nprotected:\n    const std::string ReportsTo() const { return reportsto; }\n    std::string &amp;ReportsTo() { return reportsto; }\n\npublic:\n    fink();\n    fink(const std::string &amp;fn, const std::string &amp;ln,\n         const std::string &amp;j, const std::string &amp;rpo);\n    fink(const abstr_emp &amp;e, const std::string &amp;rpo);\n    fink(const fink &amp;e);\n    virtual void ShowAll() const;\n    virtual void SetAll();\n};\nclass highfink : public manager, public fink // management fink\n{\npublic:\n    highfink();\n    highfink(const std::string &amp;fn, const std::string &amp;ln,\n             const std::string &amp;j, const std::string &amp;rpo,\n             int ico);\n    highfink(const abstr_emp &amp;e, const std::string &amp;rpo, int ico);\n    highfink(const fink &amp;f, int ico);\n    highfink(const manager &amp;m, const std::string &amp;rpo);\n    highfink(const highfink &amp;h);\n    virtual void ShowAll() const;\n    virtual void SetAll();\n};\n</code></pre> <p>Note that the class hierarchy uses MI with a virtual base class, so keep in mind the special rules for constructor initialization lists for that case.Also note the presence of some protected-access methods.This simplifies the code for some of the <code>highfink</code> methods. (Note, for example, that if <code>highfink::ShowAll()</code> simply calls <code>fink::ShowAll()</code> and <code>manager::ShowAll()</code>, it winds up calling <code>abstr_emp::ShowAll()</code> twice). Provide the class method implementations and test the classes in a program. Here is a minimal test program:</p> <pre><code>// pe14-5.cpp\n// useemp1.cpp -- using the abstr_emp classes\n#include &lt;iostream&gt;\nusing namespace std;\n#include \"emp.h\"\nint main(void)\n{\n    employee em(\"Trip\", \"Harris\", \"Thumper\");\n    cout &lt;&lt; em &lt;&lt; endl;\n    em.ShowAll();\n\n    manager ma(\"Amorphia\", \"Spindragon\", \"Nuancer\", 5);\n    cout &lt;&lt; ma &lt;&lt; endl;\n    ma.ShowAll();\n\n    fink fi(\"Matt\", \"Oggs\", \"Oiler\", \"Juno Barr\");\n    cout &lt;&lt; fi &lt;&lt; endl;\n    fi.ShowAll();\n    highfink hf(ma, \"Curly Kew\"); // recruitment?\n    hf.ShowAll();\n    cout &lt;&lt; \"Press a key for next phase:\\n\";\n    cin.get();\n    highfink hf2;\n    hf2.SetAll();\n\n    cout &lt;&lt; \"Using an abstr_emp * pointer:\\n\";\n    abstr_emp *tri[4] = {&amp;em, &amp;fi, &amp;hf, &amp;hf2};\n    for (int i = 0; i &lt; 4; i++)\n        tri[i]-&gt;ShowAll();\n\n    return 0;\n}\n</code></pre>   1. Why is no assignment operator defined? 2. Why are <code>ShowAll()</code> and <code>SetAll()</code> virtual? 3. Why is <code>abstr_emp</code> a virtual base class? 4. Why does the <code>highfink</code> class have no data section? 5. Why is only one version of <code>operator&lt;&lt;()</code> needed? 6. What would happen if the end of the program were replaced with this code?  <pre><code>abstr_emp tri[4] = {em, fi, hf, hf2};\nfor (int i = 0; i &lt; 4; i++)\n    tri[i].ShowAll();\n</code></pre>   1. There is no allocation of data directly in class, thus deep copy is not necessary  2. Method can be overridden in a derived class, enabling runtime polymorphism.  \"When you refer to a derived class object using a pointer or a reference to the base class, you can call a virtual function for that object and execute the derived class\u2019s version of the method.\" 3. Because one of the methods (in this case destructor) is a pure virtual function. 4. All necessary data is stored in objects of a 2 base classes, highfink only extend functional part of inherited classes and don't have new data 5. Because it is publicly inherited, thus can be used in any class that inherits it 6. You cannot declare ABC type of class directly.   <pre><code>abstr_emp tri[4] = {em, fi, hf, hf2};\nfor (int i = 0; i &lt; 4; i++)\n    tri[i].ShowAll();\n</code></pre> Code - classes prototypes <pre><code>// emp.h -- header file for abstr_emp class and children\n\n#ifndef _EMP_H_\n#define _EMP_H_\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass abstr_emp\n{\nprivate:\n    std::string fname; // abstr_emp's first name\n    std::string lname; // abstr_emp's last name\n    std::string job;\n\npublic:\n    abstr_emp();\n    abstr_emp(const std::string &amp;fn, const std::string &amp;ln, const std::string &amp;j);\n\n    virtual void ShowAll() const; // labels and shows all data\n    virtual void SetAll();        // prompts user for values\n\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const abstr_emp &amp;e);\n\n    // just displays first and last name\n    virtual ~abstr_emp() = 0; // virtual base class\n};\n\nclass employee : public abstr_emp\n{\npublic:\n    employee();\n    employee(const std::string &amp;fn, const std::string &amp;ln, const std::string &amp;j);\n    virtual void ShowAll() const;\n    virtual void SetAll();\n};\n\nclass manager : virtual public abstr_emp\n{\nprivate:\n    int inchargeof; // number of abstr_emps managed\n\nprotected:\n    int InChargeOf() const { return inchargeof; } // output\n    int &amp;InChargeOf() { return inchargeof; }      // input\n\npublic:\n    manager();\n    manager(const std::string &amp;fn, const std::string &amp;ln,\n            const std::string &amp;j, int ico = 0);\n    manager(const abstr_emp &amp;e, int ico);\n    manager(const manager &amp;m);\n    virtual void ShowAll() const;\n    virtual void SetAll();\n};\n\nclass fink : virtual public abstr_emp\n{\nprivate:\n    std::string reportsto; // to whom fink reports\n\nprotected:\n    const std::string ReportsTo() const { return reportsto; }\n    std::string &amp;ReportsTo() { return reportsto; }\n\npublic:\n    fink();\n    fink(const std::string &amp;fn, const std::string &amp;ln,\n         const std::string &amp;j, const std::string &amp;rpo);\n    fink(const abstr_emp &amp;e, const std::string &amp;rpo);\n    fink(const fink &amp;e);\n    virtual void ShowAll() const;\n    virtual void SetAll();\n};\n\nclass highfink : public manager, public fink // management fink\n{\npublic:\n    highfink();\n    highfink(const std::string &amp;fn, const std::string &amp;ln,\n             const std::string &amp;j, const std::string &amp;rpo,\n             int ico);\n    highfink(const abstr_emp &amp;e, const std::string &amp;rpo, int ico);\n    highfink(const fink &amp;f, int ico);\n    highfink(const manager &amp;m, const std::string &amp;rpo);\n    highfink(const highfink &amp;h);\n    virtual void ShowAll() const;\n    virtual void SetAll();\n};\n\n#endif\n</code></pre> Code - classes methods <pre><code>#include \"ch14_5_emp.h\"\n\n/// abstr_emp /// --------------------------------------\nabstr_emp::abstr_emp()\n{\n    fname = \"-\";\n    lname = \"-\";\n    job = \"-\";\n}\n\nabstr_emp::abstr_emp(const std::string &amp;fn, const std::string &amp;ln, const std::string &amp;j)\n{\n    fname = fn;\n    lname = ln;\n    job = j;\n}\n\nvoid abstr_emp::ShowAll() const\n{\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"First name: \" &lt;&lt; fname;\n\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Last name: \" &lt;&lt; lname;\n\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Profession: \" &lt;&lt; job;\n    std::cout &lt;&lt; std::endl;\n}\n\nvoid abstr_emp::SetAll()\n{\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Enter the first name: \";\n    std::getline(std::cin, fname);\n\n    std::cout &lt;&lt; \"Enter the last name: \";\n    std::getline(std::cin, lname);\n\n    std::cout &lt;&lt; \"Enter the profession: \";\n    std::getline(std::cin, job);\n}\n\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const abstr_emp &amp;e)\n{\n    os &lt;&lt; e.fname &lt;&lt; \" \" &lt;&lt; e.lname &lt;&lt; \", \" &lt;&lt; e.job;\n    return os;\n}\n\nabstr_emp::~abstr_emp()\n{\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"\\tEliminated: \" &lt;&lt; fname &lt;&lt; \" \" &lt;&lt; lname;\n}\n\n/// employee /// --------------------------------------\nemployee::employee() : abstr_emp()\n{\n}\n\nemployee::employee(const std::string &amp;fn, const std::string &amp;ln, const std::string &amp;j) : abstr_emp(fn, ln, j)\n{\n}\n\nvoid employee::ShowAll() const\n{\n    abstr_emp::ShowAll();\n}\n\nvoid employee::SetAll()\n{\n    abstr_emp::SetAll();\n}\n\n/// manager /// --------------------------------------\nmanager::manager() : abstr_emp()\n{\n    inchargeof = 0;\n}\n\nmanager::manager(const std::string &amp;fn, const std::string &amp;ln,\n                 const std::string &amp;j, int ico) : abstr_emp(fn, ln, j)\n{\n    inchargeof = ico;\n}\n\n// Base class constructor is automatically invoked unless another\n// constructor is explicitly called in the derived class for abstr_emp(e) - so called shallow copy\nmanager::manager(const abstr_emp &amp;e, int ico) : abstr_emp(e)\n{\n    inchargeof = ico;\n}\n\nmanager::manager(const manager &amp;m) : abstr_emp(m)\n{\n    inchargeof = m.InChargeOf();\n}\n\nvoid manager::ShowAll() const\n{\n    abstr_emp::ShowAll();\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Manager is in charge of: \" &lt;&lt; inchargeof &lt;&lt; \" people\";\n    std::cout &lt;&lt; std::endl;\n}\n\nvoid manager::SetAll()\n{\n    abstr_emp::SetAll();\n\n    std::cout &lt;&lt; \"Enter the amount of people manager will be in charge of: \";\n\n    while (!(std::cin &gt;&gt; inchargeof || inchargeof &lt;= 0))\n    {\n        std::cin.clear(); // reset input\n        while (std::cin.get() != '\\n')\n            continue; // get rid of bad input\n        std::cout &lt;&lt; \"Please enter a positive number: \";\n    }\n\n    std::cin.clear(); // reset input after putting in data\n    while (std::cin.get() != '\\n')\n        continue; // get rid of bad input\n}\n\n/// fink /// --------------------------------------\nfink::fink() : abstr_emp()\n{\n    reportsto = \"-\";\n}\n\nfink::fink(const std::string &amp;fn, const std::string &amp;ln,\n           const std::string &amp;j, const std::string &amp;rpo) : abstr_emp(fn, ln, j)\n{\n    reportsto = rpo;\n}\n\nfink::fink(const abstr_emp &amp;e, const std::string &amp;rpo) : abstr_emp(e)\n{\n    reportsto = rpo;\n}\n\nfink::fink(const fink &amp;e) : abstr_emp(e)\n{\n    reportsto = e.reportsto;\n    // reportsto = e.ReportsTo();\n    // reportsto = this-&gt;ReportsTo(); // ??\n}\n\nvoid fink::ShowAll() const\n{\n    abstr_emp::ShowAll();\n    std::cout &lt;&lt; \"Fink reports to: \" &lt;&lt; reportsto;\n    std::cout &lt;&lt; std::endl;\n}\n\nvoid fink::SetAll()\n{\n    abstr_emp::SetAll();\n    std::cout &lt;&lt; \"Enter superior to reports to: \";\n    std::getline(std::cin, reportsto);\n}\n\n/// high fink /// --------------------------------------\n\nhighfink::highfink() : abstr_emp(), manager(), fink()\n{\n}\n\nhighfink::highfink(const std::string &amp;fn, const std::string &amp;ln,\n                   const std::string &amp;j, const std::string &amp;rpo,\n                   int ico) : abstr_emp(fn, ln, j), manager(fn, ln, j, ico), fink(fn, ln, j, rpo)\n{\n}\n\nhighfink::highfink(const abstr_emp &amp;e, const std::string &amp;rpo, int ico) : abstr_emp(e), manager(e, ico), fink(e, rpo)\n{\n}\n\nhighfink::highfink(const fink &amp;f, int ico) : abstr_emp(f), manager(f, ico), fink(f)\n{\n}\n\nhighfink::highfink(const manager &amp;m, const std::string &amp;rpo) : abstr_emp(m), manager(m), fink(m, rpo)\n{\n}\n\nhighfink::highfink(const highfink &amp;h) : abstr_emp(h), manager(h), fink(h)\n{\n}\n\nvoid highfink::ShowAll() const\n{\n    manager::ShowAll();\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"High fink reports to: \" &lt;&lt; fink::ReportsTo();\n    std::cout &lt;&lt; std::endl;\n}\n\nvoid highfink::SetAll()\n{\n    manager::SetAll();\n    fink::SetAll(); // need protected setReportsto to be shorter\n}\n</code></pre> Code - program <pre><code>// pe14-5.cpp\n#include &lt;iostream&gt;\n#include \"ch14_5_emp.h\"\n\nusing namespace std;\n\nint main(void)\n{\n    employee em(\"Trip\", \"Harris\", \"Thumper\");\n    cout &lt;&lt; em &lt;&lt; endl;\n    em.ShowAll();\n\n    manager ma(\"Amorphia\", \"Spindragon\", \"Nuancer\", 5);\n    cout &lt;&lt; ma &lt;&lt; endl;\n    ma.ShowAll();\n\n    fink fi(\"Matt\", \"Oggs\", \"Oiler\", \"Juno Barr\");\n    cout &lt;&lt; fi &lt;&lt; endl;\n    fi.ShowAll();\n\n    highfink hf(ma, \"Curly Kew\"); // recruitment?\n    hf.ShowAll();\n\n    cout &lt;&lt; \"Press a key for next phase:\\n\";\n    cin.get();\n    highfink hf2;\n    hf2.SetAll();\n\n    // cout &lt;&lt; \"Using an abstr_emp * pointer:\\n\";\n    // abstr_emp *tri[4] = {&amp;em, &amp;fi, &amp;hf, &amp;hf2};\n    // for (int i = 0; i &lt; 4; i++)\n    //     tri[i]-&gt;ShowAll();\n\n\n    // Question tests\n    /* array of abstract class \"abstr_emp\" is not allowed:C/C++(604)\n    ch14_5.cpp(35, 15): function \"abstr_emp::~abstr_emp\" is a pure virtual function */\n\n    // abstr_emp tri[4] = {em, fi, hf, hf2};\n    // for (int i = 0; i &lt; 4; i++)\n    //     tri[i].ShowAll();\n\n    return 0;\n}\n</code></pre>"},{"location":"exercises/#chapter-15","title":"Chapter 15","text":"<p>1 - Modify the <code>Tv</code> and <code>Remote</code> classes as follows:     a. Make them mutual friends.     b. Add a state variable member to the <code>Remote</code> class that describes whether the     remote control is in normal or interactive mode.     c. Add a <code>Remote</code> method that displays the mode.     d. Provide the <code>Tv</code> class with a method for toggling the new <code>Remote</code> member.     This method should work only if the TV is in the on state.</p> <p>Write a short program that tests these new features.</p> Code - classes prototypes <pre><code>// tv.h -- Tv and Remote classes\n#ifndef TV_H_\n#define TV_H_\n\nclass Remote; // a. Make them mutual friends. -----------------\nclass Tv\n{\npublic:\n    friend class Remote; // Remote can access Tv private parts\n    enum\n    {\n        Off,\n        On\n    };\n    enum\n    {\n        MinVal,\n        MaxVal = 20\n    };\n    enum\n    {\n        Antenna,\n        Cable\n    };\n    enum\n    {\n        TV,\n        DVD\n    };\n    Tv(int s = Off, int mc = 125) : state(s), volume(5),\n                                    maxchannel(mc), channel(2), mode(Cable), input(TV) {}\n    void onoff() { state = (state == On) ? Off : On; }\n    bool ison() const { return state == On; }\n    bool volup();\n    bool voldown();\n    void chanup();\n    void chandown();\n    void set_mode() { mode = (mode == Antenna) ? Cable : Antenna; }\n    void set_input() { input = (input == TV) ? DVD : TV; }\n    void settings() const;              // display all settings\n    void all_settings(Remote &amp;r) const; // display all settings, including remote // b.\n\n    // d. Provide the Tv class with a method for toggling the new Remote member.\n    // This method should work only if the TV is in the on state.\n\n    void change_mode(Remote &amp;r);\n\nprivate:\n    int state;      // on or off\n    int volume;     // assumed to be digitized\n    int maxchannel; // maximum number of channels\n    int channel;    // current channel setting\n    int mode;       // broadcast or cable\n    int input;      // TV or DVD\n};\n\nclass Remote\n{\n    friend class Tv; // a. Make them mutual friends. -----------------\nprivate:\n    int mode; // controls TV or DVD\n    bool state_mode;\n\n    enum\n    {\n        NORMAL_MODE,\n        INTERACTIVE_MODE\n    };\n\npublic:\n    Remote(int m = Tv::TV, bool s = NORMAL_MODE) : mode(m), state_mode(s) {}\n    bool volup(Tv &amp;t) { return t.volup(); }\n    bool voldown(Tv &amp;t) { return t.voldown(); }\n    void onoff(Tv &amp;t) { t.onoff(); }\n    void chanup(Tv &amp;t) { t.chanup(); }\n    void chandown(Tv &amp;t) { t.chandown(); }\n    void set_chan(Tv &amp;t, int c) { t.channel = c; }\n    void set_mode(Tv &amp;t) { t.set_mode(); }\n    void set_input(Tv &amp;t) { t.set_input(); }\n\n    // b. Add a state variable member to the Remote class that describes whether the\n    // remote control is in normal or interactive mode\n    // void change_mode() { state_mode = (state_mode == NORMAL_MODE) ? INTERACTIVE_MODE : NORMAL_MODE; }\n    void change_mode() { state_mode ^= 1; } // the same but XOR\n\n    // c. Add a Remote method that displays the mode.\n    void display_mode()\n    {\n        std::cout &lt;&lt; \"\\n\"\n                  &lt;&lt; (state_mode == NORMAL_MODE ? \"Normal mode\" : \"Interactive mode\");\n    }\n};\n#endif\n</code></pre> Code - classes methods <pre><code>// tv.cpp -- methods for the Tv class (Remote methods are inline)\n#include &lt;iostream&gt;\n#include \"ch15_1_tv.h\"\nbool Tv::volup()\n{\n    if (volume &lt; MaxVal)\n    {\n        volume++;\n        return true;\n    }\n    else\n        return false;\n}\nbool Tv::voldown()\n{\n    if (volume &gt; MinVal)\n    {\n        volume--;\n        return true;\n    }\n    else\n        return false;\n}\nvoid Tv::chanup()\n{\n    if (channel &lt; maxchannel)\n        channel++;\n    else\n        channel = 1;\n}\nvoid Tv::chandown()\n{\n    if (channel &gt; 1)\n        channel--;\n    else\n        channel = maxchannel;\n}\n\nvoid Tv::settings() const\n{\n    using std::cout;\n    using std::endl;\n    cout &lt;&lt; \"TV is \" &lt;&lt; (state == Off ? \"Off\" : \"On\") &lt;&lt; endl;\n    if (state == On)\n    {\n        cout &lt;&lt; \"Volume setting = \" &lt;&lt; volume &lt;&lt; endl;\n        cout &lt;&lt; \"Channel setting = \" &lt;&lt; channel &lt;&lt; endl;\n        cout &lt;&lt; \"Mode = \"\n             &lt;&lt; (mode == Antenna ? \"antenna\" : \"cable\") &lt;&lt; endl;\n        cout &lt;&lt; \"Input = \"\n             &lt;&lt; (input == TV ? \"TV\" : \"DVD\") &lt;&lt; endl;\n    }\n}\n\n// b.\nvoid Tv::all_settings(Remote &amp;r) const\n{\n    using std::cout;\n    using std::endl;\n    cout &lt;&lt; \"TV is \" &lt;&lt; (state == Off ? \"Off\" : \"On\") &lt;&lt; endl;\n    if (state == On)\n    {\n        cout &lt;&lt; \"Volume setting = \" &lt;&lt; volume &lt;&lt; endl;\n        cout &lt;&lt; \"Channel setting = \" &lt;&lt; channel &lt;&lt; endl;\n        cout &lt;&lt; \"Mode = \"\n             &lt;&lt; (mode == Antenna ? \"antenna\" : \"cable\") &lt;&lt; endl;\n        cout &lt;&lt; \"Interactive mode = \"\n             &lt;&lt; (r.state_mode == r.INTERACTIVE_MODE ? \"No\" : \"Yes\") &lt;&lt; endl;\n        cout &lt;&lt; \"Input = \"\n             &lt;&lt; (input == TV ? \"TV\" : \"DVD\") &lt;&lt; endl;\n    }\n}\n\nvoid Tv::change_mode(Remote &amp;r)\n{\n    r.change_mode();\n}\n</code></pre> Code - program <pre><code>// use_tv.cpp -- using the Tv and Remote classes\n#include &lt;iostream&gt;\n#include \"ch15_1_tv.h\"\n\nint main()\n{\n    using std::cout;\n    Tv s42;\n    cout &lt;&lt; \"Initial settings for 42\\\" TV:\\n\";\n    s42.settings();\n    s42.onoff();\n    s42.chanup();\n    cout &lt;&lt; \"\\nAdjusted settings for 42\\\" TV:\\n\";\n    s42.settings();\n\n    Remote grey;\n\n    grey.set_chan(s42, 10);\n    grey.volup(s42);\n    grey.volup(s42);\n\n    // - display changes\n    cout &lt;&lt; \"\\n42\\\" Change display mode:\\n\";\n    grey.display_mode();\n    grey.change_mode();\n    grey.display_mode();\n    cout &lt;&lt; \"\\n42\\\" settings after using remote:\\n\";\n\n    s42.settings();\n\n    Tv s58(Tv::On);\n    s58.set_mode();\n    grey.set_chan(s58, 28);\n    cout &lt;&lt; \"\\n58\\\" settings:\\n\";\n    s58.settings();\n\n    // - display changes\n    cout &lt;&lt; \"\\n42\\\" Change display mode via Tv:\\n\";\n    s58.all_settings(grey);\n    s58.change_mode(grey);\n    cout &lt;&lt; \"\\n\";\n    s58.all_settings(grey);\n\n    return 0;\n}\n</code></pre> <p>2 - Modify Listing 15.11 (error4.cpp) so that the two exception types are classes derived from the <code>logic_error</code> class provided by the <code> header file. Have each <code>what()</code> method report the function name and the nature of the problem.The exception objects need not hold the bad values; they should just support the <code>what()</code> method. Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt; // or math.h, unix users may need -lm flag\n#include &lt;stdexcept&gt;\n\n// function prototypes\ndouble hmean(double a, double b);\ndouble gmean(double a, double b);\n\nint main()\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n    double x, y, z;\n    cout &lt;&lt; \"Enter two numbers: \";\n    while (cin &gt;&gt; x &gt;&gt; y)\n    {\n        try\n        { // start of try block\n            z = hmean(x, y);\n            cout &lt;&lt; \"Harmonic mean of \" &lt;&lt; x &lt;&lt; \" and \" &lt;&lt; y\n                 &lt;&lt; \" is \" &lt;&lt; z &lt;&lt; endl;\n            cout &lt;&lt; \"Geometric mean of \" &lt;&lt; x &lt;&lt; \" and \" &lt;&lt; y\n                 &lt;&lt; \" is \" &lt;&lt; gmean(x, y) &lt;&lt; endl;\n            cout &lt;&lt; \"Enter next set of numbers &lt;q to quit&gt;: \";\n        }                     // end of try block\n        catch (const std::invalid_argument &amp;ia) // start of catch block\n        {\n            std::cout &lt;&lt; \"Caught: \" &lt;&lt; ia.what() &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"Type: \" &lt;&lt; typeid(ia).name() &lt;&lt; std::endl;\n\n            continue;\n        }\n        catch (const std::exception &amp;e) // other errors\n        {\n            std::cout &lt;&lt; \"Caught: \" &lt;&lt; e.what();\n            std::cout &lt;&lt; \"Type: \" &lt;&lt; typeid(e).name();\n\n            break;\n        }\n\n    }\n    cout &lt;&lt; \"\\nBye!\\n\";\n    return 0;\n}\n\ndouble hmean(double a, double b)\n{\n    if (a == -b)\n        throw std::invalid_argument(\"hmean() invalid arguments: a == -b\\n\");\n    return 2.0 * a * b / (a + b);\n}\n\ndouble gmean(double a, double b)\n{\n    if (a &lt; 0 || b &lt; 0)\n        throw std::runtime_error(\"gmean() arguments should be &gt;= 0\\n\");\n    return std::sqrt(a * b);\n}\n\n/*\n// Listing 15.10\n// exc_mean.h -- exception classes for hmean(), gmean()\n#include &lt;iostream&gt;\n\nclass bad_hmean\n{\nprivate:\n    double v1;\n    double v2;\n\npublic:\n    bad_hmean(double a = 0, double b = 0) : v1(a), v2(b) {}\n    void mesg();\n};\n\ninline void bad_hmean::mesg()\n{\n    std::cout &lt;&lt; \"hmean(\" &lt;&lt; v1 &lt;&lt; \", \" &lt;&lt; v2 &lt;&lt; \"): \"\n              &lt;&lt; \"invalid arguments: a = -b\\n\";\n}\n\n\nclass bad_gmean\n{\npublic:\n    double v1;\n    double v2;\n    bad_gmean(double a = 0, double b = 0) : v1(a), v2(b) {}\n    const char *mesg();\n};\n\ninline const char *bad_gmean::mesg()\n{\n    return \"gmean() arguments should be &gt;= 0\\n\";\n}\n\n// (Listing 15.11) error4.cpp \u2013 using exception classes\n#include &lt;iostream&gt;\n#include &lt;cmath&gt; // or math.h, unix users may need -lm flag\n#include \"exc_mean.h\"\n\n// function prototypes\ndouble hmean(double a, double b);\ndouble gmean(double a, double b);\n\nint main()\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n    double x, y, z;\n    cout &lt;&lt; \"Enter two numbers: \";\n    while (cin &gt;&gt; x &gt;&gt; y)\n    {\n        try\n        { // start of try block\n            z = hmean(x, y);\n            cout &lt;&lt; \"Harmonic mean of \" &lt;&lt; x &lt;&lt; \" and \" &lt;&lt; y\n                 &lt;&lt; \" is \" &lt;&lt; z &lt;&lt; endl;\n            cout &lt;&lt; \"Geometric mean of \" &lt;&lt; x &lt;&lt; \" and \" &lt;&lt; y\n                 &lt;&lt; \" is \" &lt;&lt; gmean(x, y) &lt;&lt; endl;\n            cout &lt;&lt; \"Enter next set of numbers &lt;q to quit&gt;: \";\n        }                     // end of try block\n        catch (bad_hmean &amp;bg) // start of catch block\n        {\n            bg.mesg();\n            cout &lt;&lt; \"Try again.\\n\";\n\n            continue;\n        }\n        catch (bad_gmean &amp;hg)\n        {\n            cout &lt;&lt; hg.mesg();\n            cout &lt;&lt; \"Values used: \" &lt;&lt; hg.v1 &lt;&lt; \", \"\n                 &lt;&lt; hg.v2 &lt;&lt; endl;\n            cout &lt;&lt; \"Sorry, you don't get to play any more.\\n\";\n            break;\n        } // end of catch block\n    }\n    cout &lt;&lt; \"Bye!\\n\";\n    return 0;\n}\n\ndouble hmean(double a, double b)\n{\n    if (a == -b)\n        throw bad_hmean(a, b);\n    return 2.0 * a * b / (a + b);\n}\n\ndouble gmean(double a, double b)\n{\n    if (a &lt; 0 || b &lt; 0)\n        throw bad_gmean(a, b);\n    return std::sqrt(a * b);\n}\n*/\n\n/*\nHere\u2019s a sample run of the program, one that gets terminated by bad input for the\ngmean() function:\nEnter two numbers: 4 12\nHarmonic mean of 4 and 12 is 6\nGeometric mean of 4 and 12 is 6.9282\nEnter next set of numbers &lt;q to quit&gt;: 5 -5\nhmean(5, -5): invalid arguments: a = -b\nTry again.\n5 -2\nHarmonic mean of 5 and -2 is -6.66667\ngmean() arguments should be &gt;= 0\nValues used: 5, -2\nSorry, you don't get to play any more.\nBye!\nOne\n*/\n</code></pre> <p>3 - This exercise is the same as Programming Exercise 2, except that the exceptions should be derived from a base class (itself derived from <code>logic_error</code>) that stores the two argument values, the exceptions should have a method that reports these values as well as the function name, and a single <code>catch</code> block that catches the base-class exemption should be used for both exceptions, with either exception causing the loop to terminate.</p> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt; // or math.h, unix users may need -lm flag\n#include &lt;stdexcept&gt;\n\n// function prototypes\ndouble hmean(double a, double b);\ndouble gmean(double a, double b);\n\nint main()\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n    double x, y, z;\n    cout &lt;&lt; \"Enter two numbers: \";\n    while (cin &gt;&gt; x &gt;&gt; y)\n    {\n        try\n        { // start of try block\n            z = hmean(x, y);\n            cout &lt;&lt; \"Harmonic mean of \" &lt;&lt; x &lt;&lt; \" and \" &lt;&lt; y\n                 &lt;&lt; \" is \" &lt;&lt; z &lt;&lt; endl;\n            cout &lt;&lt; \"Geometric mean of \" &lt;&lt; x &lt;&lt; \" and \" &lt;&lt; y\n                 &lt;&lt; \" is \" &lt;&lt; gmean(x, y) &lt;&lt; endl;\n            cout &lt;&lt; \"Enter next set of numbers &lt;q to quit&gt;: \";\n        }                     // end of try block\n        catch (const std::exception &amp;e) // other errors\n        {\n            std::cout &lt;&lt; \"Caught: \" &lt;&lt; e.what();\n            std::cout &lt;&lt; \"Type: \" &lt;&lt; typeid(e).name();\n\n            break;\n        }\n\n    }\n    cout &lt;&lt; \"\\nBye!\\n\";\n    return 0;\n}\n\ndouble hmean(double a, double b)\n{\n    if (a == -b)\n        throw std::logic_error(\"hmean() invalid arguments: a == -b\\n\");\n    return 2.0 * a * b / (a + b);\n}\n\ndouble gmean(double a, double b)\n{\n    if (a &lt; 0 || b &lt; 0)\n        throw std::logic_error(\"gmean() arguments should be &gt;= 0\\n\");\n    return std::sqrt(a * b);\n}\n</code></pre> <p>4 - Listing 15.16 (use_sales.cpp) uses two <code>catch</code> blocks after each <code>try</code> block so that the <code>nbad_index</code> exception leads to the <code>label_val()</code> method being invoked. Modify the program so that it uses a single <code>catch</code> block after each <code>try</code> block and uses RTTI to handle invoking <code>label_val()</code> only when appropriate.</p> Code - classes prototypes <pre><code>// sales.h -- exceptions and inheritance\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n\nclass Sales\n{\npublic:\n    enum\n    {\n        MONTHS = 12\n    }; // could be a static const\n    class bad_index : public std::logic_error\n    {\n    private:\n        int bi; // bad index value\n    public:\n        explicit bad_index(int ix,\n                           const std::string &amp;s = \"Index error in Sales object\\n\");\n        int bi_val() const { return bi; }\n        virtual ~bad_index() throw() {}\n    };\n    explicit Sales(int yy = 0);\n    Sales(int yy, const double *gr, int n);\n    virtual ~Sales() {}\n    int Year() const { return year; }\n    virtual double operator[](int i) const;\n    virtual double &amp;operator[](int i);\n\nprivate:\n    double gross[MONTHS];\n    int year;\n};\n\nclass LabeledSales : public Sales\n{\npublic:\n    class nbad_index : public Sales::bad_index\n    {\n    private:\n        std::string lbl;\n\n    public:\n        nbad_index(const std::string &amp;lb, int ix,\n                   const std::string &amp;s = \"Index error in LabeledSales object\\n\");\n        const std::string &amp;label_val() const { return lbl; }\n        virtual ~nbad_index() throw() {}\n    };\n    explicit LabeledSales(const std::string &amp;lb = \"none\", int yy = 0);\n    LabeledSales(const std::string &amp;lb, int yy, const double *gr, int n);\n    virtual ~LabeledSales() {}\n    const std::string &amp;Label() const { return label; }\n    virtual double operator[](int i) const;\n    virtual double &amp;operator[](int i);\n\nprivate:\n    std::string label;\n};\n</code></pre> Code - classes methods <pre><code>// sales.cpp -- Sales implementation\n#include \"ch15_4_sales.h\"\n\nusing std::string;\nSales::bad_index::bad_index(int ix, const string &amp;s)\n    : std::logic_error(s), bi(ix)\n{\n}\nSales::Sales(int yy)\n{\n    year = yy;\n    for (int i = 0; i &lt; MONTHS; ++i)\n        gross[i] = 0;\n}\nSales::Sales(int yy, const double *gr, int n)\n{\n    year = yy;\n    int lim = (n &lt; MONTHS) ? n : MONTHS;\n    int i;\n    for (i = 0; i &lt; lim; ++i)\n        gross[i] = gr[i];\n    // for i &gt; n and i &lt; MONTHS\n    for (; i &lt; MONTHS; ++i)\n        gross[i] = 0;\n}\ndouble Sales::operator[](int i) const\n{\n    if (i &lt; 0 || i &gt;= MONTHS)\n        throw bad_index(i);\n    return gross[i];\n}\ndouble &amp;Sales::operator[](int i)\n{\n    if (i &lt; 0 || i &gt;= MONTHS)\n        throw bad_index(i);\n    return gross[i];\n}\nLabeledSales::nbad_index::nbad_index(const string &amp;lb, int ix,\n                                     const string &amp;s) : Sales::bad_index(ix, s)\n{\n    lbl = lb;\n}\nLabeledSales::LabeledSales(const string &amp;lb, int yy)\n    : Sales(yy)\n{\n    label = lb;\n}\nLabeledSales::LabeledSales(const string &amp;lb, int yy,\n                           const double *gr, int n)\n    : Sales(yy, gr, n)\n{\n    label = lb;\n}\ndouble LabeledSales::operator[](int i) const\n{\n    if (i &lt; 0 || i &gt;= MONTHS)\n        throw nbad_index(Label(), i);\n    return Sales::operator[](i);\n}\ndouble &amp;LabeledSales::operator[](int i)\n{\n    if (i &lt; 0 || i &gt;= MONTHS)\n        throw nbad_index(Label(), i);\n    return Sales::operator[](i);\n}\n</code></pre> Code - program <pre><code>// use_sales.cpp -- nested exceptions\n#include &lt;iostream&gt;\n#include \"ch15_4_sales.h\"\n\nint main()\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n    double vals1[12] =\n        {\n            1220, 1100, 1122, 2212, 1232, 2334,\n            2884, 2393, 3302, 2922, 3002, 3544};\n\n    double vals2[12] =\n        {\n            12, 11, 22, 21, 32, 34,\n            28, 29, 33, 29, 32, 35};\n\n    Sales sales1(2011, vals1, 12);\n    LabeledSales sales2(\"Blogstar\", 2012, vals2, 12);\n\n    cout &lt;&lt; \"First try block:\\n\";\n\n    try\n    {\n        int i;\n        cout &lt;&lt; \"Year = \" &lt;&lt; sales1.Year() &lt;&lt; endl;\n        for (i = 0; i &lt; 12; ++i)\n        {\n            cout &lt;&lt; sales1[i] &lt;&lt; ' ';\n            if (i % 6 == 5)\n                cout &lt;&lt; endl;\n        }\n        cout &lt;&lt; \"Year = \" &lt;&lt; sales2.Year() &lt;&lt; endl;\n        cout &lt;&lt; \"Label = \" &lt;&lt; sales2.Label() &lt;&lt; endl;\n        for (i = 0; i &lt;= 12; ++i)\n        {\n            cout &lt;&lt; sales2[i] &lt;&lt; ' ';\n            if (i % 6 == 5)\n                cout &lt;&lt; endl;\n        }\n        cout &lt;&lt; \"End of try block 1.\\n\";\n    }\n    catch (std::exception &amp;err)\n    {\n        cout &lt;&lt; err.what();\n\n        LabeledSales::nbad_index *LS;\n        Sales::bad_index *SB;\n        if (LS = dynamic_cast&lt;LabeledSales::nbad_index *&gt;(&amp;err))\n        {\n            cout &lt;&lt; \"Company: \" &lt;&lt; LS-&gt;label_val() &lt;&lt; endl;\n            cout &lt;&lt; \"bad index: \" &lt;&lt; LS-&gt;bi_val() &lt;&lt; endl;\n        }\n        else if(SB = dynamic_cast&lt;Sales::bad_index* &gt;(&amp;err) )\n        {\n            cout &lt;&lt; \"bad index: \" &lt;&lt; SB-&gt;bi_val() &lt;&lt; endl;\n        }\n    }\n\n    cout &lt;&lt; \"\\nNext try block:\\n\";\n\n    try\n    {\n        sales2[2] = 37.5;\n        sales1[20] = 23345;\n        cout &lt;&lt; \"End of try block 2.\\n\";\n    }\n    catch (std::exception &amp;err)\n    {\n        cout &lt;&lt; err.what();\n\n        LabeledSales::nbad_index *LS;\n        Sales::bad_index *SB;\n        if (LS = dynamic_cast&lt;LabeledSales::nbad_index *&gt;(&amp;err))\n        {\n            cout &lt;&lt; \"Company: \" &lt;&lt; LS-&gt;label_val() &lt;&lt; endl;\n            cout &lt;&lt; \"bad index: \" &lt;&lt; LS-&gt;bi_val() &lt;&lt; endl;\n        }\n        else if(SB = dynamic_cast&lt;Sales::bad_index* &gt;(&amp;err) )\n        {\n            cout &lt;&lt; \"bad index: \" &lt;&lt; SB-&gt;bi_val() &lt;&lt; endl;\n        }\n    }\n\n    cout &lt;&lt; \"done\\n\";\n    return 0;\n}\n\n/*\n// sales.cpp -- Sales implementation\n// use_sales.cpp -- nested exceptions\n#include &lt;iostream&gt;\n#include \"sales.h\"\nint main()\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n\n    double vals1[12] =\n        {\n            1220, 1100, 1122, 2212, 1232, 2334,\n            2884, 2393, 3302, 2922, 3002, 3544};\n    double vals2[12] =\n        {\n            12, 11, 22, 21, 32, 34,\n            28, 29, 33, 29, 32, 35};\n    Sales sales1(2011, vals1, 12);\n    LabeledSales sales2(\"Blogstar\", 2012, vals2, 12);\n\n    cout &lt;&lt; \"First try block:\\n\";\n    try\n    {\n        int i;\n        cout &lt;&lt; \"Year = \" &lt;&lt; sales1.Year() &lt;&lt; endl;\n        for (i = 0; i &lt; 12; ++i)\n        {\n            cout &lt;&lt; sales1[i] &lt;&lt; ' ';\n            if (i % 6 == 5)\n                cout &lt;&lt; endl;\n        }\n        cout &lt;&lt; \"Year = \" &lt;&lt; sales2.Year() &lt;&lt; endl;\n        cout &lt;&lt; \"Label = \" &lt;&lt; sales2.Label() &lt;&lt; endl;\n        for (i = 0; i &lt;= 12; ++i)\n        {\n            cout &lt;&lt; sales2[i] &lt;&lt; ' ';\n            if (i % 6 == 5)\n                cout &lt;&lt; endl;\n        }\n        cout &lt;&lt; \"End of try block 1.\\n\";\n    }\n    catch (LabeledSales::nbad_index &amp;bad)\n    {\n        cout &lt;&lt; bad.what();\n        cout &lt;&lt; \"Company: \" &lt;&lt; bad.label_val() &lt;&lt; endl;\n        cout &lt;&lt; \"bad index: \" &lt;&lt; bad.bi_val() &lt;&lt; endl;\n    }\n    catch (Sales::bad_index &amp;bad)\n    {\n        cout &lt;&lt; bad.what();\n        cout &lt;&lt; \"bad index: \" &lt;&lt; bad.bi_val() &lt;&lt; endl;\n    }\n\n    cout &lt;&lt; \"\\nNext try block:\\n\";\n    try\n    {\n        sales2[2] = 37.5;\n        sales1[20] = 23345;\n        cout &lt;&lt; \"End of try block 2.\\n\";\n    }\n    catch (LabeledSales::nbad_index &amp;bad)\n    {\n        cout &lt;&lt; bad.what();\n        cout &lt;&lt; \"Company: \" &lt;&lt; bad.label_val() &lt;&lt; endl;\n        cout &lt;&lt; \"bad index: \" &lt;&lt; bad.bi_val() &lt;&lt; endl;\n    }\n    catch (Sales::bad_index &amp;bad)\n    {\n        cout &lt;&lt; bad.what();\n        cout &lt;&lt; \"bad index: \" &lt;&lt; bad.bi_val() &lt;&lt; endl;\n    }\n\n    cout &lt;&lt; \"done\\n\";\n    return 0;\n}\n*/\n\n/*\nFirst try block:\nYear = 2011\n1220 1100 1122 2212 1232 2334\n2884 2393 3302 2922 3002 3544\nYear = 2012\nLabel = Blogstar\n12 11 22 21 32 34\n28 29 33 29 32 35\nIndex error in LabeledSales object\nCompany: Blogstar\nbad index: 12\nNext try block:\nIndex error in Sales object\nbad index: 20\ndone\n*/\n</code></pre>"},{"location":"exercises/#chapter-16","title":"Chapter 16","text":"<p>1 - A palindrome is a string that is the same backward as it is forward. For example,\u201ctot\u201d and \u201cotto\u201d are rather short palindromes.Write a program that lets a user enter a string and that passes to a <code>bool</code> function a reference to the string. The function should return <code>true</code> if the string is a palindrome and <code>false</code> otherwise. At this point, don\u2019t worry about complications such as capitalization, spaces, and punctuation. That is, this simple version should reject \u201cOtto\u201d and \u201cMadam, I\u2019m Adam.\u201d Feel free to scan the list of string methods in Appendix F for methods to simplify the task.</p> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n/// @brief Palindrome checker via simple loop (C - like)\nbool fnPalindrome(const std::string &amp;str)\n{\n    for (int i = 0, j = str.length() - 1; i &lt; str.length() / 2; i++, j--)\n    {\n        if (str[i] != str[j])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\n/// @brief Palindrome checker via reverse iterator\nbool fnPalindromeRI(const std::string &amp;str)\n{\n    std::string strRev(str.rbegin(), str.rend()); // copy str in reverse via reverse iterator\n    return (str == strRev);\n}\n\n/// @brief Palindrome checker functor\nstruct stPalindromeFUN\n{\n    // Overload the function call operator to check for palindromes\n    bool operator()(const std::string &amp;str) const\n    {\n        std::string strRev(str.rbegin(), str.rend()); // Reverse the string\n        return (str == strRev);                       // Check if the original string is equal to its reversed version\n    }\n};\n// std::vector&lt;std::string&gt; words = {\"racecar\", \"hello\", \"madam\"};\n// auto it = std::find_if(words.begin(), words.end(), palindromeChecker);\n// if (it != words.end()) { std::cout &lt;&lt; *it &lt;&lt; \" is a palindrome.\\n\"; }\n\nint main()\n{\n    std::cout &lt;&lt; \"\\nWrite a word (q to quit):\\t\";\n\n    std::string sDataIN;\n    while (std::getline(std::cin, sDataIN) &amp;&amp; sDataIN != \"q\")\n    {\n        std::cout &lt;&lt; \"Word \" &lt;&lt; sDataIN &lt;&lt; \" is a \"\n                  &lt;&lt; (fnPalindrome(sDataIN) ? \"palindrome\" : \"not a palindrome\") &lt;&lt; \"\\n\";\n\n        std::cout &lt;&lt; \"Word \" &lt;&lt; sDataIN &lt;&lt; \" is a \"\n                  &lt;&lt; (fnPalindromeRI(sDataIN) ? \"palindrome\" : \"not a palindrome\") &lt;&lt; \"\\n\";\n\n        stPalindromeFUN stChk;\n        std::cout &lt;&lt; \"Word \" &lt;&lt; sDataIN &lt;&lt; \" is a \"\n                  &lt;&lt; (stChk(sDataIN) ? \"palindrome\" : \"not a palindrome\") &lt;&lt; \"\\n\";\n\n        std::cout &lt;&lt; \"\\nWrite another word: \";\n    }\n    std::cout &lt;&lt; \"\\nBye!\";\n}\n</code></pre> <p>2 - Do the same problem as given in Programming Exercise 1 but do worry about complications such as capitalization, spaces, and punctuation. That is,\u201cMadam, I\u2019m Adam\u201d should test as a palindrome. For example, the testing function could reduce the string to \u201cmadamimadam\u201d and then test whether the reverse is the same. Don\u2019t forget the useful <code>cctype</code> library. You might find an STL function or two useful although not necessary.</p> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;cctype&gt;\n\n/// @brief Palindrome checker functor\nstruct stPalindromeFUN\n{\n    // Overload the function call operator to check for palindromes\n    bool operator()(std::string &amp;str) const\n    {\n        // Remove non alpha characters simple loop\n        int i = 0;\n        while (i &lt; str.length())\n        {\n            if (!isalpha(str[i]))\n            {\n                str.erase(i, 1); // remove  1 found non alphabetic data from `i` index\n                // the next iteration will skip one character since the index `i` has been incremented\n            }\n            else if (!islower(str[i]))\n            {\n                str[i] = tolower(str[i]);\n                i++; // Only increment i if we didn't erase a character\n            }\n            else\n            {\n                i++; // Only increment i if we didn't erase a character\n            }\n        }\n\n        std::cout &lt;&lt; \" reduced to word `\" &lt;&lt; str &lt;&lt; \"`\";\n        std::string strRev(str.rbegin(), str.rend()); // Reverse the string\n        return (str == strRev);                       // Check if the original string is equal to its reversed version\n    }\n};\n// std::vector&lt;std::string&gt; words = {\"racecar\", \"hello\", \"madam\"};\n// auto it = std::find_if(words.begin(), words.end(), palindromeChecker);\n// if (it != words.end()) { std::cout &lt;&lt; *it &lt;&lt; \" is a palindrome.\\n\"; }\n\n/// @brief Palindrome checker functor\nstruct stPalindromeITR\n{\n    // Overload the function call operator to check for palindromes\n    bool operator()(const std::string &amp;org) const\n    {\n        std::string str;\n        // Remove non alpha characters loop with ierators\n        for (auto iter = org.begin(); iter != org.end(); iter++)\n        {\n            if (isalpha(*iter))\n            {\n                if (isupper(*iter))\n                {\n                    str.push_back(tolower(*iter));\n                }\n                else\n                {\n                    str.push_back(*iter);\n                }\n            }\n        }\n\n        std::cout &lt;&lt; \" reduced to word `\" &lt;&lt; str &lt;&lt; \"`\";\n        std::string strRev(str.rbegin(), str.rend()); // Reverse the string\n        return (str == strRev);                       // Check if the original string is equal to its reversed version\n    }\n};\n\nint main()\n{\n    std::cout &lt;&lt; \"\\nWrite a word (q to quit):\\t\";\n\n    std::string sDataIN;\n    while (std::getline(std::cin, sDataIN) &amp;&amp; sDataIN != \"q\")\n    {\n        stPalindromeITR stChi; //Constant string - invoke first\n        stPalindromeFUN stChk; //Changes string\n\n        std::cout &lt;&lt; \"Word \" &lt;&lt; sDataIN &lt;&lt; \" is\"\n                  &lt;&lt; (stChi(sDataIN) ? \" is a palindrome\" : \" is not a palindrome\") &lt;&lt; \"\\n\";\n\n        std::cout &lt;&lt; \"Word \" &lt;&lt; sDataIN &lt;&lt; \" is\"\n                  &lt;&lt; (stChk(sDataIN) ? \" is a palindrome\" : \" is not a palindrome\") &lt;&lt; \"\\n\";\n\n        std::cout &lt;&lt; \"\\nWrite another word: \";\n    }\n    std::cout &lt;&lt; \"\\nBye!\";\n}\n</code></pre> <p>3 - Redo Listing 16.3 (hangman.cpp) so that it gets it words from a file. One approach is to use a <code>vector object instead of an array of string. Then you can use push_back() to copy how ever many words are in your data file into the <code>vector object and use the <code>size()</code> member to determine the length of the word list. Because the program should read one word at a time from the file, you should use the <code>&gt;&gt;</code> operator rather than <code>getline()</code>. The file itself should contain words separated by spaces, tabs, or new lines Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n#include &lt;ctime&gt;\n#include &lt;cctype&gt;\n\n#include &lt;vector&gt;    // std::vector\n#include &lt;fstream&gt;   // std::ifstream / std::ofstream\n#include &lt;exception&gt; // s\n#include &lt;algorithm&gt; // std::remove\n#include &lt;sstream&gt;   // std::istringstream\n\nusing std::string;\n\n// Method 2\n// Loop to extract words using find and substr\nvoid fnReadFileIS(std::vector&lt;std::string&gt; &amp;wordList, string &amp;strTemp)\n{\n    int pos{};\n    int prev_pos{};\n    while ((pos = strTemp.find(',', pos)) != std::string::npos)\n    {\n        // Extract word from previous position up to current position\n        std::string word = strTemp.substr(prev_pos, pos - prev_pos);\n        // Skip empty words due to leading comma\n        if (!word.empty())\n        {\n            wordList.push_back(word);\n        }\n        // Update position to skip comma\n        prev_pos = ++pos;\n    }\n}\n\n// Method 1\n// Use istringstream -&gt; #include &lt;sstream&gt;\nvoid fnReadFileSB(std::vector&lt;std::string&gt; &amp;wordList, string &amp;strTemp)\n{\n    std::string word;\n    std::istringstream iss(strTemp);\n\n    // Extract words using getline with ',' as delimiter\n    while (std::getline(iss, word, ','))\n    {\n        // Skip empty words due to trailing comma\n        if (!word.empty())\n        {\n            wordList.push_back(word);\n        }\n    }\n}\n\nint main()\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n    using std::tolower;\n\n    std::srand(std::time(0));\n    std::vector&lt;std::string&gt; wordList;\n    int iNumOfWords{};\n    std::ifstream inFile;\n\n    inFile.open(\"./ch16_3_words.txt\"); // OR ./ch6_3_words.txt\n\n    if (!inFile.is_open())\n    {\n        std::cerr &lt;&lt; \"Could not open the file\\n\"\n                  &lt;&lt; \"Program terminating.\\n\";\n        std::exit(EXIT_FAILURE);\n    }\n\n    // Read wordList from a file\n    int iCommas{};\n    int iPrvIdx{};\n    while (inFile.good())\n    {\n        std::string strTemp;\n        std::getline(inFile, strTemp); // getline\n\n        // Remove spaces if occurs\n        // Check ',' as divisions of words\n        strTemp.erase(std::remove(strTemp.begin(), strTemp.end(), ' '), strTemp.end());\n        if (strTemp.find(',') != std::string::npos)\n        {\n            fnReadFileSB(wordList, strTemp);\n            // fnReadFileIS(wordList, strTemp);\n        }\n        else\n        {\n            wordList.push_back(strTemp);\n        }\n\n        iPrvIdx = 0;\n        iCommas = 0;\n        ++iNumOfWords;\n    }\n\n    char play;\n    cout &lt;&lt; \"Will you play a word game? &lt;y/n&gt; \";\n    cin &gt;&gt; play;\n    play = tolower(play);\n\n    cout &lt;&lt; \"\\nAll possible words in game: \\n\";\n    {\n        int i{};\n        cout &lt;&lt; \"\\n\";\n        for (auto wrd : wordList)\n        {\n            if (i &gt; 9) // print 10 words per line\n            {\n                cout &lt;&lt; \"\\n\";\n                i = 0;\n            }\n            cout &lt;&lt; wrd &lt;&lt; \", \";\n            i++;\n        }\n    }\n    cout &lt;&lt; \"\\n\\n\";\n\n    while (play == 'y')\n    {\n        string target = wordList[std::rand() % iNumOfWords];\n        int length = target.length();\n        string attempt(length, '-');\n        string badchars;\n        int guesses = 6;\n        cout &lt;&lt; \"Guess my secret word. It has \" &lt;&lt; length\n             &lt;&lt; \" letters, and you guess\\n\"\n             &lt;&lt; \"one letter at a time. You get \" &lt;&lt; guesses\n             &lt;&lt; \" wrong guesses.\\n\";\n        cout &lt;&lt; \"Your word: \" &lt;&lt; attempt &lt;&lt; endl;\n\n        while (guesses &gt; 0 &amp;&amp; attempt != target)\n        {\n            char letter;\n            cout &lt;&lt; \"Guess a letter: \";\n            cin &gt;&gt; letter;\n            if (badchars.find(letter) != string::npos || attempt.find(letter) != string::npos)\n            {\n                cout &lt;&lt; \"You already guessed that. Try again.\\n\";\n                continue;\n            }\n            int loc = target.find(letter);\n            if (loc == string::npos)\n            {\n                cout &lt;&lt; \"Oh, bad guess!\\n\";\n                --guesses;\n                badchars += letter; // add to string\n            }\n            else\n            {\n                cout &lt;&lt; \"Good guess!\\n\";\n                attempt[loc] = letter;\n                // check if letter appears again\n                loc = target.find(letter, loc + 1);\n                while (loc != string::npos)\n                {\n                    attempt[loc] = letter;\n                    loc = target.find(letter, loc + 1);\n                }\n            }\n            cout &lt;&lt; \"Your word: \" &lt;&lt; attempt &lt;&lt; endl;\n            if (attempt != target)\n            {\n                if (badchars.length() &gt; 0)\n                    cout &lt;&lt; \"Bad choices: \" &lt;&lt; badchars &lt;&lt; endl;\n                cout &lt;&lt; guesses &lt;&lt; \" bad guesses left\\n\";\n            }\n        }\n        if (guesses &gt; 0)\n            cout &lt;&lt; \"That's right!\\n\";\n        else\n            cout &lt;&lt; \"Sorry, the word is \" &lt;&lt; target &lt;&lt; \".\\n\";\n        cout &lt;&lt; \"Will you play another? &lt;y/n&gt; \";\n        cin &gt;&gt; play;\n        play = tolower(play);\n    }\n\n    cout &lt;&lt; \"Bye\\n\";\n\n    return 0;\n}\n\n/*\n// hangman.cpp -- some string methods\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n#include &lt;ctime&gt;\n#include &lt;cctype&gt;\n\nusing std::string;\nconst int NUM = 26;\nconst string wordList[NUM] = {\"apiary\", \"beetle\", \"cereal\",\n                              \"danger\", \"ensign\", \"florid\", \"garage\", \"health\", \"insult\",\n                              \"jackal\", \"keeper\", \"loaner\", \"manage\", \"nonce\", \"onset\",\n                              \"plaid\", \"quilt\", \"remote\", \"stolid\", \"train\", \"useful\",\n                              \"valid\", \"whence\", \"xenon\", \"yearn\", \"zippy\"};\n\nint main()\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n    using std::tolower;\n    std::srand(std::time(0));\n    char play;\n    cout &lt;&lt; \"Will you play a word game? &lt;y/n&gt; \";\n    cin &gt;&gt; play;\n    play = tolower(play);\n    while (play == 'y')\n    {\n        string target = wordList[std::rand() % NUM];\n        int length = target.length();\n        string attempt(length, '-');\n        string badchars;\n        int guesses = 6;\n        cout &lt;&lt; \"Guess my secret word. It has \" &lt;&lt; length\n             &lt;&lt; \" letters, and you guess\\n\"\n             &lt;&lt; \"one letter at a time. You get \" &lt;&lt; guesses\n             &lt;&lt; \" wrong guesses.\\n\";\n        cout &lt;&lt; \"Your word: \" &lt;&lt; attempt &lt;&lt; endl;\n\n        while (guesses &gt; 0 &amp;&amp; attempt != target)\n        {\n            char letter;\n            cout &lt;&lt; \"Guess a letter: \";\n            cin &gt;&gt; letter;\n            if (badchars.find(letter) != string::npos || attempt.find(letter) != string::npos)\n            {\n                cout &lt;&lt; \"You already guessed that. Try again.\\n\";\n                continue;\n            }\n            int loc = target.find(letter);\n            if (loc == string::npos)\n            {\n                cout &lt;&lt; \"Oh, bad guess!\\n\";\n                --guesses;\n                badchars += letter; // add to string\n            }\n            else\n            {\n                cout &lt;&lt; \"Good guess!\\n\";\n                attempt[loc] = letter;\n                // check if letter appears again\n                loc = target.find(letter, loc + 1);\n                while (loc != string::npos)\n                {\n                    attempt[loc] = letter;\n                    loc = target.find(letter, loc + 1);\n                }\n            }\n            cout &lt;&lt; \"Your word: \" &lt;&lt; attempt &lt;&lt; endl;\n            if (attempt != target)\n            {\n                if (badchars.length() &gt; 0)\n                    cout &lt;&lt; \"Bad choices: \" &lt;&lt; badchars &lt;&lt; endl;\n                cout &lt;&lt; guesses &lt;&lt; \" bad guesses left\\n\";\n            }\n        }\n        if (guesses &gt; 0)\n            cout &lt;&lt; \"That's right!\\n\";\n        else\n            cout &lt;&lt; \"Sorry, the word is \" &lt;&lt; target &lt;&lt; \".\\n\";\n        cout &lt;&lt; \"Will you play another? &lt;y/n&gt; \";\n        cin &gt;&gt; play;\n        play = tolower(play);\n    }\n\n    cout &lt;&lt; \"Bye\\n\";\n\n    return 0;\n}\n*/\n\n/*\nHere\u2019s a sample run of the program in Listing 16.3:\nWill you play a word game? &lt;y/n&gt; y\nGuess my secret word. It has 6 letters, and you guess\none letter at a time. You get 6 wrong guesses.\nYour word: ------\nGuess a letter: e\nOh, bad guess!\nYour word: ------\nBad choices: e\n5 bad guesses left\nGuess a letter: a\nGood guess!\nYour word: a--a--\nBad choices: e\n5 bad guesses left\nGuess a letter: t\nOh, bad guess!\nYour word: a--a--\nBad choices: et\n4 bad guesses left\nGuess a letter: r\nGood guess!\nYour word: a--ar-\nBad choices: et\n4 bad guesses left\nGuess a letter: y\nGood guess!\nYour word: a--ary\nBad choices: et\n4 bad guesses left\nGuess a letter: i\nGood guess!\nYour word: a-iary\nBad choices: et\n4 bad guesses left\nGuess a letter: p\nGood guess!\nYour word: apiary\nThat's right!\nWill you play another? &lt;y/n&gt; n\nBye\n*/\n</code></pre> File <pre><code>apiary, beetle, cereal,\ndanger, ensign, florid, garage, health, insult,\njackal, keeper, loaner, manage, nonce, onset,\nplaid, quilt, remote, stolid, train, useful,\nvalid, whence, xenon, yearn, zippy,\nscrape, swarm, bee, lock, \nresink\ntransversomedial\npharyngopathy\npostmineral\nmyelosyphilis\nsilverer\nevincement\nphrygium\npunnigram\nimminution\nenvironmental\nsleepify\nnope\nwauken\nindignance\nknotwort\napocodeine\nescortee\ndogwatch\neaglewood\nunbrotherliness\nmulse\ndermobranchiata\ntyphic\npoststertorous\nindevout\nanatomicopathologic\nunimpenetrable\nhoggy\nurrhodin\nDioecia\nunchapter\nnonumbilicate\nzwitterionic\napportionable\nferulic\nstatefulness\npharyngotonsillitis\nMimulus\nrecce\nmutinously\nreboant\nmarshwort\nlupoid\nchromatophilic\nlauder\nnirles\nesthesiometer\nsemisocial\nunbeing\nkangaroo\ntakosis\ninconvertibility\nanesthetist\nrumorproof\nthoracoscopy\neuphorbium\nbizet\nsong\ndolichocephali\nplatemaker\nvesicupapular\nelectroforming\ndilatingly\nmeethelp\nloincloth\navowably\ncounterindicate\ntreacliness\nEpigonus\nairmark\npolarography\nprecomposition\nlemography\nApinage\nTaal\nlogology\nprobeer\nrandomization\npoditic\nindividualize\ncastigate\nBiloculina\noverscrub\nkoolah\nweetless\nerased\nlayery\ndiscontinuee\nanaphylatoxin\nunwounded\npersonalism\nhowitzer\nhexahydroxy\nkoku\nreamer\ntonguiness\nmicrogametocyte\nbaba\nludefisk\n</code></pre> <p>4 - Write a function with an old-style interface that has this prototype:</p> <pre><code>int reduce(long ar[], int n);\n</code></pre> <p>The actual arguments should be the name of an array and the number of elements in the array. The function should sort an array, remove duplicate values, and return a value equal to the number of elements in the reduced array. Write the function using STL functions. (If you decide to use the general <code>unique()</code> function, note that it returns the end of the resulting range.) Test the function in a short program.</p> <pre><code>// Write a function with an old-style interface that has this prototype:\n\n// ```cpp\n// int reduce(long ar[], int n);\n// ```\n\n// The actual arguments should be the name of an array and the number of elements\n// in the array.\n\n// The function should sort an array, remove duplicate values, and return a\n// value equal to the number of elements in the reduced array.\n\n// Write the function using STL functions.\n\n// (If you decide to use the general &lt;code&gt;unique()&lt;/code&gt; function, note that\n// it returns the end of the resulting range.)\n\n// Test the function in a short program.\n\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;random&gt; // for random_device, mt19937, uniform_int_distribution\n\nint reduce(long ar[], int n); // Prototype\nvoid printArr(long ar[], int n);\n\nint main()\n{\n    const int ARR_LEN = 50;\n    long lArr[ARR_LEN]{};\n\n    for (int i = 0; i &lt; ARR_LEN; i++)\n    {\n        // Simple RNG - repeatable\n        // lArr[i] = (long)(std::rand() % 20);\n\n        // Advanced RNG\n        std::random_device rd;\n        std::mt19937 gen(rd());\n        lArr[i] = (long) std::uniform_int_distribution&lt;&gt;(0, 50)(gen);\n    }\n\n    std::cout &lt;&lt; \"\\nOriginal: \";\n    printArr(lArr, ARR_LEN);\n\n    int iNewLen = reduce(lArr, ARR_LEN);\n\n    std::cout &lt;&lt; \"\\nReduced, old length: \";\n    printArr(lArr, ARR_LEN);\n    std::cout &lt;&lt; \"\\nReduced, new length: \";\n    printArr(lArr, iNewLen);\n\n    std::cout &lt;&lt; \"\\n\\nBye!\";\n    return 0;\n}\n\n/// @brief Sort and remove duplicates in array of longs\n/// @return Size of new array\nint reduce(long ar[], int n)\n{\n    std::sort(ar, ar + n);\n    auto itEnd = std::unique(ar, ar + n);\n\n    //distance between two pointers itEnd and ar\n    return itEnd - ar;\n}\n\n/// @brief Sort and remove duplicates in array of longs\n/// @return Size of new array\nint reduceRot(long ar[], int n) // Definition\n{\n    // Sort\n    std::sort(ar, ar + n);\n    // printArr(ar, n);\n\n    // Remove duplicate vals\n    for (int i = 0, j = 0; i &lt; n - 1; i++)\n    {\n        if (ar[i] == ar[i + 1])\n        {\n            // rotates [ar + i, ar + n) left by distance(ar + i, ar + i + 1) positions, returns the iterator pointing at *(ar + i) new home\n            std::rotate(ar + i, ar + i + 1, ar + n); // shift data from i, by one, set to the end\n            i--;                                     // prevent going to next idx, when next val can also be the same\n            // Examplanary result: 0 1 2 4 5 7 9 11 12 13 14 15 16 18 1 2 4 5 7 11 15 16 18 1 2 4 7 18 1 2\n\n            // Anti-infinite-loop in case of inf repeats (can't rotate?),\n            // Rotate the cause to not repeat\n            j = (j &lt; (n * 2)) ? j++ : 0;\n            !j ? i++ : 0; // if(!j){ i++; };\n            !j ? std::rotate(ar + i + 1, ar + i + 2, ar + n) : 0;\n            // if(!j){std::cout &lt;&lt; i &lt;&lt; \",\";} // print causes\n        }\n    }\n\n    // Calculate length of new arr\n    for (int i = 0; i &lt; n - 1; i++)\n    {\n        if (ar[i] &gt; ar[i + 1])\n        {\n            return (i + 1); // return length of new arr\n            // i + 1, because idx start from 0\n        }\n    }\n\n    return n;\n}\n\nvoid printArr(long ar[], int n)\n{\n    std::cout &lt;&lt; \"\\n\";\n    for (int i = 0; i &lt; n; i++)\n    {\n        std::cout &lt;&lt; ar[i] &lt;&lt; \" \";\n    }\n}\n</code></pre> <p>5 - Do the same problem as described in Programming Exercise 4, except make it a template function:</p> <pre><code>template &lt;class T&gt;\nint reduce(T ar[], int n);\n</code></pre> <p>Test the function in a short program, using both a <code>long</code> instantiation and a string instantiation.</p> <pre><code>// Do the same problem as described in Programming Exercise 4, except make it a\n// template function:\n\n// ```cpp\n// template &lt;class T&gt;\n// int reduce(T ar[], int n);\n// ```\n\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;random&gt; // for random_device, mt19937, uniform_int_distribution\n\ntemplate &lt;class T&gt;\nint reduce(T ar, int n); // Prototype\n\ntemplate &lt;class T&gt;\nvoid printArr(T ar, int n);\n\nint main()\n{\n    const int ARR_LEN = 100;\n    long lArr[ARR_LEN]{};\n\n    for (int i = 0; i &lt; ARR_LEN; i++)\n    {\n        // Simple RNG - repeatable\n        // lArr[i] = (long)(std::rand() % 20);\n\n        // Advanced RNG\n        std::random_device rd;\n        std::mt19937 gen(rd());\n        lArr[i] = (long)std::uniform_int_distribution&lt;&gt;(0, 50)(gen);\n    }\n\n    std::cout &lt;&lt; \"\\nOriginal: \";\n    printArr(lArr, ARR_LEN);\n\n    int iNewLen = reduce(lArr, ARR_LEN);\n\n    std::cout &lt;&lt; \"\\nReduced, old length: \";\n    printArr(lArr, ARR_LEN);\n    std::cout &lt;&lt; \"\\nReduced, new length: \";\n    printArr(lArr, iNewLen);\n\n    std::cout &lt;&lt; \"\\n\\nBye!\";\n    return 0;\n}\n\n/// @brief Sort and remove duplicates in array of longs\n/// @return Size of new array\ntemplate &lt;class T&gt;\nint reduce(T ar, int n)\n{\n    std::sort(ar, ar + n);\n    auto itEnd = std::unique(ar, ar + n);\n\n    //distance between two pointers itEnd and ar\n    return itEnd - ar;\n}\n\n/// @brief Sort and remove duplicates in array of longs\n/// @return Size of new array\ntemplate &lt;class T&gt;\nint reduceRot(T ar, int n) // Definition\n{\n    // Sort\n    std::sort(ar, ar + n);\n    // printArr(ar, n);\n\n    // Remove duplicate vals via rotate\n    for (int i = 0, j = 0; i &lt; n - 1; i++)\n    {\n        if (ar[i] == ar[i + 1])\n        {\n            std::rotate(ar + i, ar + i + 1, ar + n); // shift data from i, by one, set to the end\n            i--;                                     // prevent going to next idx, when next val can also be the same\n\n            // Anti-infinite-loop in case of inf repeats (can't rotate?),\n            // Rotate the cause to not repeat\n            j = (j &lt; (n * 2)) ? j++ : 0;\n            !j ? i++ : 0; // if(!j){ i++; };\n            !j ? std::rotate(ar + i + 1, ar + i + 2, ar + n) : 0;\n            // if(!j){std::cout &lt;&lt; i &lt;&lt; \",\";} // print causes\n\n            // Examplanary result: 0 1 2 4 5 7 9 11 12 13 14 15 16 18 1 2 4 5 7 11 15 16 18 1 2 4 7 18 1 2\n        }\n    }\n\n    // Calculate length of new arr\n    for (int i = 0; i &lt; n - 1; i++)\n    {\n        if (ar[i] &gt; ar[i + 1])\n        {\n            return (i + 1); // return length of new arr\n            // i + 1, because idx start from 0\n        }\n    }\n\n    return n;\n}\n\ntemplate &lt;class T&gt;\nvoid printArr(T ar, int n)\n{\n    std::cout &lt;&lt; \"\\n\";\n\n    for (auto i = 0; i &lt; n; i++)\n    {\n        std::cout &lt;&lt; ar[i] &lt;&lt; \" \";\n    }\n}\n</code></pre> <p>6 - Redo the example shown in Listing 12.12 (bank.cpp), using the STL <code>queue</code> template class instead of the <code>Queue</code> class described in Chapter 12.</p> Code - program <pre><code>// bank.cpp -- using the Queue interface\n// compile with queue.cpp\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt; // for rand() and srand()\n#include &lt;ctime&gt;   // for time()\n\n#include &lt;queue&gt;\n#include \"ch16_6_q.h\"\n\nconst int MIN_PER_HR = 60;\n\nbool newcustomer(double x); // is there a new customer?\n\nint main()\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n    using std::ios_base;\n    // setting things up\n    std::srand(std::time(0)); // random initializing of rand()\n\n    cout &lt;&lt; \"Case Study: Bank of Heather Automatic Teller\\n\";\n    cout &lt;&lt; \"Enter maximum size of queue: \";\n    int iQueueMAX;\n    cin &gt;&gt; iQueueMAX;\n\n    std::queue&lt;Item&gt; line;\n    // Queue line(qs); // line queue holds up to qs people\n\n    cout &lt;&lt; \"Enter the number of simulation hours: \";\n    int hours; // hours of simulation\n    cin &gt;&gt; hours;\n    // simulation will run 1 cycle per minute\n    long cyclelimit = MIN_PER_HR * hours; // # of cycles\n\n    cout &lt;&lt; \"Enter the average number of customers per hour: \";\n    double perhour; // average # of arrival per hour\n    cin &gt;&gt; perhour;\n    double min_per_cust; // average time between arrivals\n    min_per_cust = MIN_PER_HR / perhour;\n\n    Item temp;          // new customer data\n    long turnaways = 0; // turned away by full queue\n    long customers = 0; // joined the queue\n    long served = 0;    // served during the simulation\n    long sum_line = 0;  // cumulative line length\n    int wait_time = 0;  // time until autoteller is free\n    long line_wait = 0; // cumulative time in line\n\n    // running the simulation\n    for (int cycle = 0; cycle &lt; cyclelimit; cycle++)\n    {\n        if (newcustomer(min_per_cust)) // have newcomer\n        {\n            if (line.size() &gt;= iQueueMAX)\n            {\n                turnaways++;\n            }\n            else\n            {\n                customers++;\n                temp.set(cycle);    // cycle = time of arrival\n                line.push(temp);    // line.enqueue(temp); // add newcomer to line\n            }\n        }\n        if (wait_time &lt;= 0 &amp;&amp; line.size() &gt; 0) //!line.isempty())\n        {\n            line.pop(); // line.dequeue(temp);       // attend next customer\n            wait_time = temp.ptime(); // for wait_time minutes\n            line_wait += cycle - temp.when();\n            served++;\n        }\n        if (wait_time &gt; 0)\n            wait_time--;\n        sum_line += line.size(); //line.queuecount();\n    }\n\n    // reporting results\n    if (customers &gt; 0)\n    {\n        cout &lt;&lt; \"customers accepted: \" &lt;&lt; customers &lt;&lt; endl;\n        cout &lt;&lt; \" customers served: \" &lt;&lt; served &lt;&lt; endl;\n        cout &lt;&lt; \" turnaways: \" &lt;&lt; turnaways &lt;&lt; endl;\n        cout &lt;&lt; \"average queue size: \";\n        cout.precision(2);\n        cout.setf(ios_base::fixed, ios_base::floatfield);\n        cout &lt;&lt; (double)sum_line / cyclelimit &lt;&lt; endl;\n        cout &lt;&lt; \" average wait time: \"\n             &lt;&lt; (double)line_wait / served &lt;&lt; \" minutes\\n\";\n    }\n    else\n        cout &lt;&lt; \"No customers!\\n\";\n\n    cout &lt;&lt; \"Done!\\n\";\n\n    return 0;\n}\n\n// x = average time, in minutes, between customers\n// return value is true if customer shows up this minute\nbool newcustomer(double x)\n{\n    return (std::rand() * x / RAND_MAX &lt; 1);\n}\n\n/*\n// bank.cpp -- using the Queue interface\n// compile with queue.cpp\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt; // for rand() and srand()\n#include &lt;ctime&gt;   // for time()\n#include \"ch16_6_q.h\"\nconst int MIN_PER_HR = 60;\n\nbool newcustomer(double x); // is there a new customer?\n\nint main()\n{\n    using std::cin;\n    using std::cout;\n    using std::endl;\n    using std::ios_base;\n    // setting things up\n    std::srand(std::time(0)); // random initializing of rand()\n\n    cout &lt;&lt; \"Case Study: Bank of Heather Automatic Teller\\n\";\n    cout &lt;&lt; \"Enter maximum size of queue: \";\n    int qs;\n    cin &gt;&gt; qs;\n    Queue line(qs); // line queue holds up to qs people\n\n    cout &lt;&lt; \"Enter the number of simulation hours: \";\n    int hours; // hours of simulation\n    cin &gt;&gt; hours;\n    // simulation will run 1 cycle per minute\n    long cyclelimit = MIN_PER_HR * hours; // # of cycles\n\n    cout &lt;&lt; \"Enter the average number of customers per hour: \";\n    double perhour; // average # of arrival per hour\n    cin &gt;&gt; perhour;\n    double min_per_cust; // average time between arrivals\n    min_per_cust = MIN_PER_HR / perhour;\n\n    Item temp;          // new customer data\n    long turnaways = 0; // turned away by full queue\n    long customers = 0; // joined the queue\n    long served = 0;    // served during the simulation\n    long sum_line = 0;  // cumulative line length\n    int wait_time = 0;  // time until autoteller is free\n    long line_wait = 0; // cumulative time in line\n\n    // running the simulation\n    for (int cycle = 0; cycle &lt; cyclelimit; cycle++)\n    {\n        if (newcustomer(min_per_cust)) // have newcomer\n        {\n            if (line.isfull())\n                turnaways++;\n            else\n            {\n                customers++;\n                temp.set(cycle);    // cycle = time of arrival\n                line.enqueue(temp); // add newcomer to line\n            }\n        }\n        if (wait_time &lt;= 0 &amp;&amp; !line.isempty())\n        {\n            line.dequeue(temp);       // attend next customer\n            wait_time = temp.ptime(); // for wait_time minutes\n            line_wait += cycle - temp.when();\n            served++;\n        }\n        if (wait_time &gt; 0)\n            wait_time--;\n        sum_line += line.queuecount();\n    }\n\n    // reporting results\n    if (customers &gt; 0)\n    {\n        cout &lt;&lt; \"customers accepted: \" &lt;&lt; customers &lt;&lt; endl;\n        cout &lt;&lt; \" customers served: \" &lt;&lt; served &lt;&lt; endl;\n        cout &lt;&lt; \" turnaways: \" &lt;&lt; turnaways &lt;&lt; endl;\n        cout &lt;&lt; \"average queue size: \";\n        cout.precision(2);\n        cout.setf(ios_base::fixed, ios_base::floatfield);\n        cout &lt;&lt; (double)sum_line / cyclelimit &lt;&lt; endl;\n        cout &lt;&lt; \" average wait time: \"\n             &lt;&lt; (double)line_wait / served &lt;&lt; \" minutes\\n\";\n    }\n    else\n        cout &lt;&lt; \"No customers!\\n\";\n\n    cout &lt;&lt; \"Done!\\n\";\n\n    return 0;\n}\n\n// x = average time, in minutes, between customers\n// return value is true if customer shows up this minute\nbool newcustomer(double x)\n{\n    return (std::rand() * x / RAND_MAX &lt; 1);\n}\n*/\n\n/*\nCase Study: Bank of Heather Automatic Teller\nEnter maximum size of queue: 10\nEnter the number of simulation hours: 100\nEnter the average number of customers per hour: 15\ncustomers accepted: 1485\ncustomers served: 1485\nturnaways: 0\naverage queue size: 0.15\naverage wait time: 0.63 minutes\nDone!\n\nCase Study: Bank of Heather Automatic Teller\nEnter maximum size of queue: 10\nEnter the number of simulation hours: 100\nEnter the average number of customers per hour: 30\ncustomers accepted: 2896\ncustomers served: 2888\nturnaways: 101\naverage queue size: 4.64\naverage wait time: 9.63 minutes\nDone!\n\nCase Study: Bank of Heather Automatic Teller\nEnter maximum size of queue: 20\nEnter the number of simulation hours: 100\nEnter the average number of customers per hour: 30\ncustomers accepted: 2943\ncustomers served: 2943\nturnaways: 93\naverage queue size: 13.06\naverage wait time: 26.63 minutes\nDone!\n*/\n</code></pre> <p>7 - A common game is the lottery card. The card has numbered spots of which a certain number are selected at random. Write a <code>Lotto()</code> function that takes two arguments. The first should be the number of spots on a lottery card, and the second should be the number of spots selected at random. The function should return a <code>vector&lt; int &gt;</code> object that contains, in sorted order, the numbers selected at random. For example, you could use the function as follows:</p> <pre><code>vector&lt;int&gt; winners;\nwinners = Lotto(51,6);\n</code></pre> <p>This would assign to <code>winners</code> a vector that contains six numbers selected randomly from the range 1 through 51. Note that simply using <code>rand()</code> doesn\u2019t quite do the job because it may produce duplicate values. Suggestion: Have the function create a vector that contains all the possible values, use <code>random_shuffle()</code>, and then use the beginning of the shuffled vector to obtain the values. Also write a short program that lets you test the function.</p> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;random&gt;\n#include &lt;algorithm&gt; // For std::count\n\nstd::vector&lt;int&gt; Lotto(int num_spots, int num_sel);\n\n// Define a functor to print the winners\nstruct PrintWinner\n{\n    void operator()(int winner) const\n    {\n        std::cout &lt;&lt; winner &lt;&lt; \" \";\n    }\n};\n\nint main()\n{\n    std::vector&lt;int&gt; winners;\n    winners = Lotto(51, 6);\n\n    std::cout &lt;&lt; \"\\nAnd the winners of the lottery are!\\n\";\n    std::for_each(winners.begin(), winners.end(), PrintWinner());\n\n    // // Use of std::for_each to print each winner\n    // std::for_each(winners.begin(), winners.end(), [](const auto&amp; winner) {\n    //     std::cout &lt;&lt; winner &lt;&lt; \" \";\n    // });\n\n    return 0;\n}\n\n/// @brief Lotto game function\n/// @param num_spots number of spots on a lottery card\n/// @param num_sel number of spots selected at random\n/// @return vector that contains `num_sel` amount of numbers selected randomly from `1` to `num_spots`\nstd::vector&lt;int&gt; Lotto(int num_spots, int num_sel)\n{\n    std::vector&lt;int&gt; _win;\n\n    { // _rd and _gen should be only for loop\n        bool _uniq_val{false};\n        std::random_device _rd;\n        std::mt19937 _gen(_rd());\n        for (int i = 0; i &lt; num_sel; i++)\n        {\n            _win.push_back(std::uniform_int_distribution&lt;&gt;(1, num_spots)(_gen));\n\n            if (!_uniq_val &amp;&amp; _win[i] &gt; 1) // prevents infinite loop if the same value is assigned\n            {\n                _win[i]--;\n            }\n\n            // Count the occurrences of the value in the vector\n            auto count = std::count(_win.begin(), _win.end(), _win[i]);\n\n            _uniq_val = true;\n            // Check if the value is unique\n            if (count &gt; 1)\n            {\n                std::cout &lt;&lt; \"Not unique value occur: \" &lt;&lt; _win[i] &lt;&lt; std::endl;\n                i--;\n                _uniq_val = false;\n            }\n        }\n    }\n\n    return _win;\n}\n</code></pre> <p>8 - Mat and Pat want to invite their friends to a party. They ask you to write a program that does the following:</p> <ul> <li>Allows Mat to enter a list of his friends\u2019 names. The names are stored in a container and then displayed in sorted order.</li> <li>Allows Pat to enter a list of her friends\u2019 names. The names are stored in a second container and then displayed in sorted order.</li> <li>Creates a third container that merges the two lists, eliminates duplicates, and displays the contents of this container.</li> </ul> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;string&gt;    // getline\n#include &lt;algorithm&gt; // sort\n\nvoid enter_num(int &amp;num)\n{\n    while (!(std::cin &gt;&gt; num))\n    {\n        std::cin.clear(); // reset input\n        while (std::cin.get() != '\\n')\n            continue; // get rid of bad input\n        std::cout &lt;&lt; \"Please enter a number: \";\n    }\n}\n\nstd::string enter_friend(std::string who, int inum)\n{\n    std::cout &lt;&lt; \"Enter \" &lt;&lt; who &lt;&lt; \" \" &lt;&lt; inum + 1 &lt;&lt; \" friend: \";\n    std::string _sfriend;\n\n    // Clear any remaining newline character from the input buffer\n    if (std::cin.peek() == '\\n')\n    {\n        std::cin.ignore(1, '\\n');\n    }\n\n    // // broken - newline (enter) not always detected\n    // std::cin.clear(); // reset input\n    // while (std::cin.get() != '\\n')\n    //     continue; // get rid of bad input\n\n    std::getline(std::cin, _sfriend);\n    return _sfriend;\n}\n\nint main()\n{\n    std::list&lt;std::string&gt; mat_friend_names;\n    std::list&lt;std::string&gt; pat_friend_names;\n    std::list&lt;std::string&gt; common_friend_names;\n\n    int i_mat{};\n    int i_pat{};\n\n    // Allows Mat to enter a list of his friends\u2019 names. The names are stored in a container and then displayed in sorted order.\n    std::cout &lt;&lt; \"\\n Enter number of Mat friends: \";\n    enter_num(i_mat);\n\n    for (int i = 0; i &lt; i_mat; i++)\n    {\n        mat_friend_names.push_back(enter_friend(\"Mat\", i));\n    }\n\n    mat_friend_names.sort();\n\n    std::cout &lt;&lt; \"\\nMat friends: \\n\";\n    for (auto a : mat_friend_names)\n    {\n        std::cout &lt;&lt; a &lt;&lt; std::endl;\n    }\n\n    // Allows Pat to enter a list of her friends\u2019 names. The names are stored in a second container and then displayed in sorted order.\n    std::cout &lt;&lt; \"\\n Enter number of Pat friends: \";\n    enter_num(i_pat);\n\n    for (int i = 0; i &lt; i_pat; i++)\n    {\n        pat_friend_names.push_back(enter_friend(\"Pat\", i));\n    }\n\n    pat_friend_names.sort();\n\n    std::cout &lt;&lt; \"\\nPat friends: \\n\";\n    for (auto a : pat_friend_names)\n    {\n        std::cout &lt;&lt; a &lt;&lt; std::endl;\n    }\n\n    // Third container merges the two lists, eliminates duplicates, and displays the contents of this container.\n    common_friend_names.merge(mat_friend_names);\n    common_friend_names.merge(pat_friend_names);\n\n    common_friend_names.unique();\n\n    std::cout &lt;&lt; \"\\nMutual friends: \\n\";\n    for (auto a : common_friend_names)\n    {\n        std::cout &lt;&lt; a &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre> <p>9 - Compared to an array, a linked list features easier addition and removal of elements but is slower to sort. This raises a possibility: Perhaps it might be faster to copy a list to an array, sort the array, and copy the sorted result back to the list than to simply use the list algorithm for sorting. (But it also could use more memory.) Test the speed hypothesis with the following approach:</p> <p>a. Create a large <code>vector object vi0, using <code>rand()</code> to provide initial values. b. Create a second <code>vector&lt; int &gt;</code> object <code>vi</code> and a <code>list&lt; int &gt;</code> object li of the same size as the original and initialize them to values in the original vector. c. Time how long the program takes to sort <code>vi</code> using the STL <code>sort()</code> algorithm, then time how long it takes to sort <code>li</code> using the list <code>sort()</code> method. d. Reset <code>li</code> to the unsorted contents of <code>vi0</code>. Time the combined operation of copying <code>li</code> to <code>vi</code>, sorting <code>vi</code>, and copying the result back to <code>li</code>. <p>To time these operations, you can use <code>clock()</code> from the <code>ctime</code> library. As in Listing 5.14 (waiting.cpp), you can use this statement to start the first timing:</p> <pre><code>clock_t start = clock();\n</code></pre> <p>Then use the following at the end of the operation to get the elapsed time:</p> <pre><code>clock_t end = clock();\ncout &lt;&lt; (double)(end - start)/CLOCKS_PER_SEC;\n</code></pre> <p>This is by no means a definitive test because the results will depend on a variety of factors, including available memory, whether multiprocessing is going on, and the size of the array or list. (One would expect the relative efficiency advantage of the array over the list to increase with the number of elements being sorted.) Also if you have a choice between a default build and a release build, use the release build for the measurement.With today\u2019s speedy computers, you probably will need to use as large an array as possible to get meaningful readings.You might try, for example, 100,000 elements, 1,000,000 elements, and 10,000,000 elements.</p> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;vector&gt;\n#include &lt;fstream&gt;\n\n#include &lt;chrono&gt;\n#include &lt;ctime&gt;\n\n#include &lt;typeinfo&gt;\n#include &lt;algorithm&gt;\n\n#define TTHOUSAND 10000\n#define HTHOUSAND 100000\n#define MILLION 1000000\n#define BILLION 1000000000\n#define TRYLLION 1000000000000\n\n\n/// @brief Print data into console\n/// @tparam T \n/// @param data STL container ot array\n/// @param what_data ID of data that will print \n/// @param num_el Size of data\n/// @param duration_micros Time duration that will be printed\ntemplate &lt;typename T&gt; // slow\nvoid mass_print(T &amp;data, const char *what_data, size_t num_el, size_t duration_micros = 0)\n{\n    std::cout &lt;&lt; what_data &lt;&lt; \" data:\\n\";\n    for (size_t i = 0; i &lt; num_el; i++)\n    {\n        std::cout &lt;&lt; data[i] &lt;&lt; \" \";\n        if (!(i % 100))\n        {\n            std::cout &lt;&lt; \"\\n\";\n        }\n    }\n}\n\ntemplate &lt;typename T&gt;\nvoid mass_fwrite(T &amp;data, const char *what_data, const char *fn, size_t num_el, double duration_micros = 0)\n{\n\n    std::ofstream outFile;\n    {\n        std::string merge_fn;\n        merge_fn = \"./\";\n        merge_fn += fn;\n        merge_fn += \".txt\";\n        outFile.open(merge_fn);\n    }\n\n    if (!outFile.is_open())\n    {\n        std::cout &lt;&lt; \"Could not open file\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Terminate program\" &lt;&lt; std::endl;\n        exit(EXIT_FAILURE);\n    }\n\n    if (outFile.good())\n    {\n        outFile &lt;&lt; what_data &lt;&lt; \" data asigned in: \" &lt;&lt; duration_micros &lt;&lt; \" microseconds\\n\";\n        outFile &lt;&lt; what_data &lt;&lt; \" data asigned in: \" &lt;&lt; duration_micros / 1000.00 &lt;&lt; \" milliseconds\\n\";\n        outFile &lt;&lt; what_data &lt;&lt; \" data asigned in: \" &lt;&lt; (long long)duration_micros / 1000.00 / 1000.00 &lt;&lt; \" seconds\\n\";\n        outFile &lt;&lt; what_data &lt;&lt; \" data asigned in: \" &lt;&lt; ((long long)duration_micros / 1000.00 / 1000.00) / 60.00 &lt;&lt; \" minutes\\n\";\n        outFile &lt;&lt; what_data &lt;&lt; \" data asigned in: \" &lt;&lt; (((long long)duration_micros / 1000.00 / 1000.00) / 60.00) / 60.00 &lt;&lt; \" hours\\n\";\n\n        outFile &lt;&lt; \"\\n\"\n                &lt;&lt; what_data &lt;&lt; \" data:\\n\";\n    }\n\n    // // Not adequate for List\n    // for (size_t i = 0; i &lt; num_el; i++)\n    // {\n    //     if (outFile.good())\n    //     {\n    //         outFile &lt;&lt; data[i] &lt;&lt; \",\";\n    //         if (!(i % 100) &amp;&amp; i != 0)\n    //         {\n    //             outFile &lt;&lt; \"\\n\";\n    //         }\n    //     }\n    // }\n\n    // size_t i = 0;\n    // Iterate through the list using iterators\n    // for (auto it = data.begin(); it != data.end(); ++it, ++i)\n    // {\n    //     if (outFile.good())\n    //     {\n    //         outFile &lt;&lt; *it &lt;&lt; \",\";\n    //         if (!(i % 100) &amp;&amp; i != 0)\n    //         {\n    //             outFile &lt;&lt; \"\\n\";\n    //         }\n    //     }\n    // }\n\n    size_t i = 0;\n    for (auto a : data)\n    {\n        if (outFile.good())\n        {\n            outFile &lt;&lt; a &lt;&lt; \",\";\n            if (!(i % 100) &amp;&amp; i != 0)\n            {\n                outFile &lt;&lt; \"\\n\";\n            }\n            i++;\n        }\n    }\n}\n\nint main()\n{\n    size_t num_data = MILLION;\n    std::vector&lt;int&gt; vi0; // a\n    std::vector&lt;int&gt; vi;  // b\n    std::list&lt;int&gt; li;    // b\n\n    // a)   ------------------\n\n    // clock_t start = clock(); // ctime - calc time\n    auto start = std::chrono::high_resolution_clock::now(); // chrono - more precise (object) timer\n\n    for (size_t i = 0; i &lt; num_data; i++)\n    {\n        vi0.push_back(rand() % 1000);\n    }\n\n    auto stop = std::chrono::high_resolution_clock::now();                                      // Stop the timer\n    auto chrono_duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(stop - start); // Calculate the duration\n    double duration = chrono_duration.count();\n\n    // clock_t end = clock();\n    // double duration = (double)(end - start) / CLOCKS_PER_SEC;\n\n    std::cout &lt;&lt; \"\\nVector assignment of \" &lt;&lt; num_data\n              &lt;&lt; \" points of data into \" &lt;&lt; typeid(vi0).name() &lt;&lt; \": \"\n              &lt;&lt; duration / 1000.00 &lt;&lt; \" ms\";\n\n    // mass_print(vi0, vi0.size(), \"Vector\");   // slow\n    // mass_fwrite(vi0, \"Vector\", \"ch16_9_vector\", vi0.size(), duration);\n\n    // b)   ------------------\n\n    vi.assign(vi0.begin(), vi0.end());\n\n    start = std::chrono::high_resolution_clock::now();\n\n    li.assign(vi0.begin(), vi0.end());\n\n    stop = std::chrono::high_resolution_clock::now();\n    chrono_duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(stop - start);\n    duration = chrono_duration.count();\n\n    std::cout &lt;&lt; \"\\nTime to assign \" &lt;&lt; num_data\n              &lt;&lt; \" points of data from \" &lt;&lt; typeid(vi0).name()\n              &lt;&lt; \" into \" &lt;&lt; typeid(li).name() &lt;&lt; \": \"\n              &lt;&lt; duration / 1000.00 &lt;&lt; \" ms\";\n\n    // c)   ------------------ VECTOR\n    start = std::chrono::high_resolution_clock::now();\n\n    std::sort(vi.begin(), vi.end());\n\n    stop = std::chrono::high_resolution_clock::now();\n    chrono_duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(stop - start);\n    duration = chrono_duration.count();\n\n    std::cout &lt;&lt; \"\\nVector sort of \" &lt;&lt; num_data\n              &lt;&lt; \" points of data in \" &lt;&lt; typeid(vi).name() &lt;&lt; \": \"\n              &lt;&lt; duration / 1000.00 &lt;&lt; \" ms\";\n    // mass_fwrite(vi, \"Vector\", \"ch16_9_vector_sorted\", vi.size(), duration);\n\n    // c)   ------------------ LIST\n    start = std::chrono::high_resolution_clock::now();\n\n    li.sort();\n\n    stop = std::chrono::high_resolution_clock::now();\n    chrono_duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(stop - start);\n    duration = chrono_duration.count();\n\n    std::cout &lt;&lt; \"\\nList sort of \" &lt;&lt; num_data\n              &lt;&lt; \" points of data in \" &lt;&lt; typeid(li).name() &lt;&lt; \": \"\n              &lt;&lt; duration / 1000.00 &lt;&lt; \" ms\";\n    // mass_fwrite(li, \"List\", \"ch16_9_list_sorted\", li.size(), duration);\n\n    // d)   ------------------\n    li.assign(vi0.begin(), vi0.end());\n\n    start = std::chrono::high_resolution_clock::now();\n\n    vi.assign(li.begin(), li.end()); // copy list to vector\n    std::sort(vi.begin(), vi.end()); // sort vector\n    li.assign(vi.begin(), vi.end()); // copy back\n\n    stop = std::chrono::high_resolution_clock::now();\n    chrono_duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(stop - start);\n    duration = chrono_duration.count();\n\n    std::cout &lt;&lt; \"\\nList of \" &lt;&lt; num_data\n              &lt;&lt; \" points of data, copied to Vector, sorted and copied back to List took: \"\n              &lt;&lt; duration / 1000.00 &lt;&lt; \" ms\";\n    // mass_fwrite(li, \"List\", \"ch16_9_task\", li.size(), duration);\n\n    return 0;\n}\n\n/*\n// Listing 5.14 waiting.cpp\n// waiting.cpp -- using clock() in a time-delay loop\n#include &lt;iostream&gt;\n#include &lt;ctime&gt; // describes clock() function, clock_t type\nint main()\n{\n    using namespace std;\n    cout &lt;&lt; \"Enter the delay time, in seconds: \";\n    float secs;\n    cin &gt;&gt; secs;\n    clock_t delay = secs * CLOCKS_PER_SEC; // convert to clock ticks\n    cout &lt;&lt; \"starting\\a\\n\";\n    clock_t start = clock();\n    while (clock() - start &lt; delay) // wait until time elapses\n        ;                           // note the semicolon\n    cout &lt;&lt; \"done \\a\\n\";\n    return 0;\n}\n*/\n</code></pre> <p>10 - Modify Listing 16.9 (vect3.cpp) as follows:</p> <p>a. Add a <code>price</code> member to the <code>Review</code> structure. b. Instead of using a vector of Review objects to hold the input, use a <code>vector</code> of <code>shared_ptr&lt; Review &gt;</code> objects. Remember that a <code>shared_ptr</code> has to be initialized with a pointer returned by <code>new</code>. c. Follow the input stage with a loop that allows the user the following options for displaying books: in original order, in alphabetical order, in order of increasing ratings, in order of decreasing ratings, in order of increasing price, in order of decreasing price, and quitting. Here\u2019s one possible approach. After getting the initial input, create another vector of <code>shared_ptrs</code> initialized to the original array. Define an <code>operator&lt;()</code> function that compares pointed-to structures and use it to sort the second vector so that the <code>shared_ptrs</code> are in the order of the book names stored in the pointed-to objects. Repeat the process to get vectors of <code>shared_ptrs</code> sorted by <code>rating</code> and by price. Note that <code>rbegin()</code> and <code>rend()</code> save you the trouble of also creating vectors of reversed order.</p> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\n#include &lt;memory&gt; // std::shared_ptr\n#include &lt;random&gt; //  std::random_device; std::mt19937\n\nstruct Review\n{\n    std::string title;\n    double price;\n    int rating;\n};\n\nbool operator&lt;(const std::shared_ptr&lt;Review&gt; &amp;r1, const std::shared_ptr&lt;Review&gt; &amp;r2);\nbool worseThan(const std::shared_ptr&lt;Review&gt; &amp;r1, const std::shared_ptr&lt;Review&gt; &amp;r2);\nbool costmThan(const std::shared_ptr&lt;Review&gt; &amp;r1, const std::shared_ptr&lt;Review&gt; &amp;r2);\n\nbool FillReview(std::shared_ptr&lt;Review&gt; &amp;rr);\nvoid ShowReview(const std::shared_ptr&lt;Review&gt; &amp;rr);\nvoid fnPrintMenu();\n\nint main()\n{\n    std::vector&lt;std::shared_ptr&lt;Review&gt;&gt; books;\n    while (true)\n    {\n        std::shared_ptr&lt;Review&gt; temp(new Review());\n        //  std::shared_ptr&lt;Review&gt; sp = std::make_shared&lt;Review&gt;(); // also valid, good practice C++ 11\n        if (!FillReview(temp))\n        {\n            break;\n        }\n        books.push_back(temp);\n    }\n\n    if (!(books.size() &gt; 0))\n    {\n        std::cout &lt;&lt; \"No entries. \";\n        std::cout &lt;&lt; \"Bye.\\n\";\n        return 0;\n    }\n\n    std::cout &lt;&lt; \"Thank you. You entered the following \"\n              &lt;&lt; books.size() &lt;&lt; \" books:\\n\"\n              &lt;&lt; \"Rating\\tPrice\\tBook\\n\";\n    for_each(books.begin(), books.end(), ShowReview);\n\n    // copy vector to not modify original by sorting\n    std::vector&lt;std::shared_ptr&lt;Review&gt;&gt; books_cpy = books;\n\n    fnPrintMenu();\n    char option;\n    bool invoption = false;\n    while (std::cin &gt;&gt; option &amp;&amp; option != 'q')\n    {\n        invoption = false;\n        switch (option)\n        {\n        case 'w':\n            std::cout &lt;&lt; \"In original order:\\nRating\\tPrice\\tBook\\n\";\n            for_each(books.begin(), books.end(), ShowReview);\n            break;\n        case 'e':\n            sort(books_cpy.begin(), books_cpy.end());\n            std::cout &lt;&lt; \"Sorted in alphabetical order:\\nRating\\tPrice\\tBook\\n\";\n            break;\n        case 'r':\n            sort(books_cpy.begin(), books_cpy.end(), worseThan);\n            std::cout &lt;&lt; \"Sorted in order of increasing ratings:\\nRating\\tPrice\\tBook\\n\";\n            break;\n        case 't':\n            sort(books_cpy.rbegin(), books_cpy.rend(), worseThan);\n            std::cout &lt;&lt; \"Sorted in order of decreasing ratings:\\nRating\\tPrice\\tBook\\n\";\n            break;\n        case 'y':\n            sort(books_cpy.begin(), books_cpy.end(), costmThan);\n            std::cout &lt;&lt; \"Sorted in order of increasing price:\\nRating\\tPrice\\tBook\\n\";\n            break;\n        case 'u':\n            sort(books_cpy.rbegin(), books_cpy.rend(), costmThan);\n            std::cout &lt;&lt; \"Sorted in order of decreasing price:\\nRating\\tPrice\\tBook\\n\";\n            break;\n        default:\n            invoption = true;\n            std::cout &lt;&lt; \"\\nInvalid option\\n\";\n            break;\n        }\n\n        if (option != 'w' &amp;&amp; !invoption)\n        {\n            for_each(books_cpy.begin(), books_cpy.end(), ShowReview);\n        }\n\n        fnPrintMenu();\n    }\n\n    std::cout &lt;&lt; \"Bye.\\n\";\n    return 0;\n}\n\nvoid fnPrintMenu()\n{\n    std::cout\n        &lt;&lt; \"\\nPlease select:\\n\"\n        &lt;&lt; \"\\tw) display books in original order\\n\"\n        &lt;&lt; \"\\te) display in alphabetical order\\n\"\n        &lt;&lt; \"\\tr) display in order of increasing ratings\\n\"\n        &lt;&lt; \"\\tt) display in order of decreasing ratings\\n\"\n        &lt;&lt; \"\\ty) display in order of increasing price\\n\"\n        &lt;&lt; \"\\tu) display in order of decreasing price\\n\"\n        &lt;&lt; \"\\tq) quit\" &lt;&lt; std::endl;\n}\n\nbool operator&lt;(const std::shared_ptr&lt;Review&gt; &amp;r1, const std::shared_ptr&lt;Review&gt; &amp;r2)\n{\n    if (r1-&gt;title &lt; r2-&gt;title)\n        return true;\n    else if (r1-&gt;title == r2-&gt;title &amp;&amp; r1-&gt;rating &lt; r2-&gt;rating)\n        return true;\n    else\n        return false;\n}\n\nbool worseThan(const std::shared_ptr&lt;Review&gt; &amp;r1, const std::shared_ptr&lt;Review&gt; &amp;r2)\n{\n    if (r1-&gt;rating &lt; r2-&gt;rating)\n        return true;\n    else\n        return false;\n}\n\nbool costmThan(const std::shared_ptr&lt;Review&gt; &amp;r1, const std::shared_ptr&lt;Review&gt; &amp;r2)\n{\n    if (r1-&gt;price &lt; r2-&gt;price)\n        return true;\n    else\n        return false;\n}\n\n\nbool FillReview(std::shared_ptr&lt;Review&gt; &amp;rr)\n{\n    std::cout &lt;&lt; \"Enter book title (q to stop): \";\n    std::getline(std::cin, rr-&gt;title);\n    if (rr-&gt;title == \"q\")\n        return false;\n    std::cout &lt;&lt; \"Enter book rating: \";\n    std::cin &gt;&gt; rr-&gt;rating;\n    if (!std::cin)\n        return false;\n    // get rid of rest of input line\n    while (std::cin.get() != '\\n')\n        continue;\n    std::cout &lt;&lt; \"Enter book price: \";\n    std::cin &gt;&gt; rr-&gt;price;\n    if (!std::cin)\n        return false;\n    // get rid of rest of input line\n    while (std::cin.get() != '\\n')\n        continue;\n    return true;\n}\n\nvoid ShowReview(const std::shared_ptr&lt;Review&gt; &amp;rr)\n{\n    std::cout &lt;&lt; rr-&gt;rating &lt;&lt; \"\\t\" &lt;&lt; rr-&gt;price &lt;&lt; \"\\t\" &lt;&lt; rr-&gt;title &lt;&lt; std::endl;\n}\n\n/*\n    random_shuffle(books.begin(), books.end()); // random_shuffle function is deprecated in C++14 and removed in C++17. Replaced with std::shuffle\n\n    // std::shuffle function is expecting a Uniform Random Number Generator (URBG) as its third argument (rand() wont work)\n    // Create a random device and a generator // needs #include &lt;random&gt;\n    std::random_device rd;\n    std::mt19937 gen(rd()); // Mersenne Twister engine\n    shuffle(books.begin(), books.end(), gen);\n\nstd::random_shuffle deprecation and removal:\n- Global State Dependency: std::random_shuffle might rely on the global state, using functions like rand() which is not thread-safe and can lead to less randomness in multi-threaded programs.\n- Unspecified Random Number Generator (RNG): The RNG used by std::random_shuffle was not specified by the standard, which meant that its behavior could vary across different implementations, potentially leading to inconsistent results.\n- Replacement by Better Alternatives: The introduction of the &lt;random&gt; header in C++11 provided better mechanisms for generating random numbers, including Uniform Random Number Generators (URBGs) that do not depend on global state. The std::shuffle function, introduced in C++11, takes advantage of these improvements, offering better randomness and thread safety.\n- Removal in C++17: As a result of these issues, std::random_shuffle was removed entirely in C++17, and programmers were encouraged to use std::shuffle instead, which requires explicitly providing a URBG, thus ensuring consistent behavior across different implementations and environments.\n*/\n\n/*\nEnter book title (quit to quit): The Cat Who Can Teach You Weight Loss\nEnter book rating: 8\nEnter book title (quit to quit): The Dogs of Dharma\nEnter book rating: 6\nEnter book title (quit to quit): The Wimps of Wonk\nEnter book rating: 3\nEnter book title (quit to quit): Farewell and Delete\nEnter book rating: 7\nEnter book title (quit to quit): quit\nThank you. You entered the following 4 ratings:\nRating Book\n8 The Cat Who Can Teach You Weight Loss\n6 The Dogs of Dharma\n3 The Wimps of Wonk\n7 Farewell and Delete\nSorted by title:\nRating Book\n7 Farewell and Delete\n8 The Cat Who Can Teach You Weight Loss\n6 The Dogs of Dharma\n3 The Wimps of Wonk\nSorted by rating:\nRating Book\n3 The Wimps of Wonk\n6 The Dogs of Dharma\n7 Farewell and Delete\n8 The Cat Who Can Teach You Weight Loss\nAfter shuffling:\nRating Book\n7 Farewell and Delete\n3 The Wimps of Wonk\n6 The Dogs of Dharma\n8 The Cat Who Can Teach You Weight Loss\nBye.\n*/\n\n/*\n// Listing 16.9 vect3.cpp\n// vect3.cpp -- using STL functions\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nstruct Review\n{\n    std::string title;\n    int rating;\n};\n\nbool operator&lt;(const std::shared_ptr&lt;Review&gt; &amp;r1, const std::shared_ptr&lt;Review&gt; &amp;r2);\nbool worseThan(const std::shared_ptr&lt;Review&gt; &amp;r1, const std::shared_ptr&lt;Review&gt; &amp;r2);\nbool FillReview(std::shared_ptr&lt;Review&gt; &amp;rr);\nvoid ShowReview(const std::shared_ptr&lt;Review&gt; &amp;rr);\n\nint main()\n{\n    using namespace std;\n    vector&lt;Review&gt; books;\n    Review temp;\n    while (FillReview(temp))\n        books.push_back(temp);\n    if (books.size() &gt; 0)\n    {\n        std::cout &lt;&lt; \"Thank you. You entered the following \"\n             &lt;&lt; books.size() &lt;&lt; \" ratings:\\n\"\n             &lt;&lt; \"Rating\\tBook\\n\";\n        for_each(books.begin(), books.end(), ShowReview);\n        sort(books.begin(), books.end());\n        std::cout &lt;&lt; \"Sorted by title:\\nRating\\tPrice\\tBook\\n\";\n        for_each(books.begin(), books.end(), ShowReview);\n        sort(books.begin(), books.end(), worseThan);\n        std::cout &lt;&lt; \"Sorted by rating:\\nRating\\tPrice\\tBook\\n\";\n        for_each(books.begin(), books.end(), ShowReview);\n        random_shuffle(books.begin(), books.end());\n        std::cout &lt;&lt; \"After shuffling:\\nRating\\tPrice\\tBook\\n\";\n        for_each(books.begin(), books.end(), ShowReview);\n    }\n    else\n        std::cout &lt;&lt; \"No entries. \";\n    std::cout &lt;&lt; \"Bye.\\n\";\n    return 0;\n}\n\nbool operator&lt;(const std::shared_ptr&lt;Review&gt; &amp;r1, const std::shared_ptr&lt;Review&gt; &amp;r2)\n{\n    if (r1-&gt;title &lt; r2-&gt;title)\n        return true;\n    else if (r1-&gt;title == r2-&gt;title &amp;&amp; r1-&gt;rating &lt; r2-&gt;rating)\n        return true;\n    else\n        return false;\n}\n\nbool worseThan(const std::shared_ptr&lt;Review&gt; &amp;r1, const std::shared_ptr&lt;Review&gt; &amp;r2)\n{\n    if (r1-&gt;rating &lt; r2-&gt;rating)\n        return true;\n    else\n        return false;\n}\n\nbool FillReview(std::shared_ptr&lt;Review&gt; &amp;rr)\n{\n    std::cout &lt;&lt; \"Enter book title (quit to quit): \";\n    std::getline(std::cin, rr-&gt;title);\n    if (rr-&gt;title == \"quit\")\n        return false;\n    std::cout &lt;&lt; \"Enter book rating: \";\n    std::cin &gt;&gt; rr-&gt;rating;\n    if (!std::cin)\n        return false;\n    // get rid of rest of input line\n    while (std::cin.get() != '\\n')\n        continue;\n    return true;\n}\n\nvoid ShowReview(const std::shared_ptr&lt;Review&gt; &amp;rr)\n{\n    std::cout &lt;&lt; rr-&gt;rating &lt;&lt; \"\\t\" &lt;&lt; rr-&gt;title &lt;&lt; std::endl;\n}\n*/\n\n/*\nEnter book title (quit to quit): The Cat Who Can Teach You Weight Loss\nEnter book rating: 8\nEnter book title (quit to quit): The Dogs of Dharma\nEnter book rating: 6\nEnter book title (quit to quit): The Wimps of Wonk\nEnter book rating: 3\nEnter book title (quit to quit): Farewell and Delete\nEnter book rating: 7\nEnter book title (quit to quit): quit\nThank you. You entered the following 4 ratings:\nRating Book\n8 The Cat Who Can Teach You Weight Loss\n6 The Dogs of Dharma\n3 The Wimps of Wonk\n7 Farewell and Delete\nSorted by title:\nRating Book\n7 Farewell and Delete\n8 The Cat Who Can Teach You Weight Loss\n6 The Dogs of Dharma\n3 The Wimps of Wonk\nSorted by rating:\nRating Book\n3 The Wimps of Wonk\n6 The Dogs of Dharma\n7 Farewell and Delete\n8 The Cat Who Can Teach You Weight Loss\nAfter shuffling:\nRating Book\n7 Farewell and Delete\n3 The Wimps of Wonk\n6 The Dogs of Dharma\n8 The Cat Who Can Teach You Weight Loss\nBye.\n*/\n</code></pre>"},{"location":"exercises/#chapter-17","title":"Chapter 17","text":"<p>1 - Write a program that counts the number of characters up to the first <code>$</code> in input and that leaves the <code>$</code> in the input stream.</p> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\nint main()\n{\n    int counter{};\n    char ctmp;\n    clock_t start = clock();\n\n    std::cout &lt;&lt; \"\\nYou can write anything till the `$` character... try it!\" &lt;&lt; std::endl;\n\n    // while ((ctmp = std::cin.get()) != '$') // it wont work if the first character will be $ directly after newline, because std::cin.get() does not skip newline character,\n\n    std::cin.get(ctmp);\n    while (ctmp != '$')\n    {\n        counter++;\n        // std::cin.get(ctmp);  // Reads a single character from the input stream and stores it in ctmp. It wont skip any character (including whitespaces)\n        std::cin &gt;&gt; ctmp; // It skips any leading whitespace (spaces, newlines, tabs) - int this case for counting\n    }\n\n    std::cout &lt;&lt; \"\\nYou have killed this program with \" &lt;&lt; ctmp &lt;&lt; std::endl\n              &lt;&lt; \"It counted \" &lt;&lt; counter &lt;&lt; \" characters before \" &lt;&lt; ctmp &lt;&lt; \" and the next character would be \" &lt;&lt; (char) std::cin.get() &lt;&lt; std::endl \n              &lt;&lt; \"It lived only for \" &lt;&lt; (double)(clock() - start) / CLOCKS_PER_SEC &lt;&lt; \" seconds!\";\n\n    std::cout &lt;&lt; \"\\n\\nBye!\";\n\n    return 0;\n}\n</code></pre> <p>2 - Write a program that copies your keyboard input (up to the simulated end-of-file) to a file named on the command line.</p> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt; // ofstream\n#include &lt;string&gt;\n#include &lt;sstream&gt; // ostringstream\n#include &lt;cstring&gt;\n\nint main(int argc, char **argv)\n{\n    if (argc == 1)\n    {\n        std::cerr &lt;&lt; \"\\nNo file argument!\" &lt;&lt; std::endl;\n        std::cerr &lt;&lt; \"Exit program!\" &lt;&lt; std::endl;\n        return 1; // Exit failure - no file\n    }\n    else if (argc &gt; 2)\n    {\n        std::cerr &lt;&lt; \"\\nToo many arguments!\" &lt;&lt; std::endl;\n        std::cerr &lt;&lt; \"Enter only filename as 1'st argument to write data into.\" &lt;&lt; std::endl;\n        return 2;\n    }\n\n    std::ostringstream oss_buff; // more efficient than string, because it does not create temporary objects\n    std::string line;\n\n    std::ofstream outFile;\n    outFile.open(argv[1]);\n\n    if (!outFile.is_open())\n    {\n        std::cerr &lt;&lt; \"Error: file could not be opened\" &lt;&lt; std::endl;\n        return 3;\n    }\n\n    std::cout &lt;&lt; \"\\nData from keyboard will be written to the file!\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Write 'exit' in new line to stop the program.\" &lt;&lt; std::endl;\n\n    while (true)\n    {\n        std::getline(std::cin, line);\n        if (line == \"exit\")\n        {\n            break; // Exit the loop when \"exit\" is entered\n        }\n        oss_buff &lt;&lt; line &lt;&lt; '\\n'; // Append the line and a newline character to the ostringstream\n        outFile &lt;&lt; line &lt;&lt; '\\n';  // Append the line in opened file\n    }\n\n    outFile.close();\n\n    std::cout &lt;&lt; \"\\nYou have written:\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; oss_buff.str(); // Display the accumulated data\n    std::cout &lt;&lt; \"\\nInto file:\" &lt;&lt; (std::string)argv[1] &lt;&lt; std::endl; // convert to string and display whole argument \n\n    // C - like simpler implementation of line above\n    /*\n    int len = strlen(argv[1]);\n    for (size_t i = 0; i &lt; len; i++)\n    {\n        std::cout &lt;&lt; argv[1][i];\n    }\n    std::cout &lt;&lt; std::endl;\n    */\n\n    return 0;\n}\n</code></pre> <p>3 - Write a program that copies one file to another. Have the program take the filenames from the command line. Have the program report if it cannot open a file.</p> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nint main(int argc, char **argv)\n{\n    if (argc == 1)\n    {\n        std::cerr &lt;&lt; \"\\nNo file arguments!\" &lt;&lt; std::endl;\n        std::cerr &lt;&lt; \"Exit program!\" &lt;&lt; std::endl;\n        return 1; // Exit failure - no file\n    }\n    else if (argc != 3)\n    {\n        std::cerr &lt;&lt; \"\\nIncorrect number of arguments!\" &lt;&lt; std::endl;\n        std::cerr &lt;&lt; \"Enter filename to copy data from as 1'st argument\" &lt;&lt; std::endl;\n        std::cerr &lt;&lt; \"and 2'nd argument the filename to write data into.\" &lt;&lt; std::endl;\n        return 2;\n    }\n\n    // std::ostringstream oss_linebuff; // more efficient than string, because it does not create temporary objects\n\n    std::ifstream inFile;\n    inFile.open(argv[1]);\n\n    if (!inFile.is_open())\n    {\n        std::cerr &lt;&lt; \"Error: 1'st file could not be opened\" &lt;&lt; std::endl;\n        return 3;\n    }\n\n    std::ofstream outFile;\n    outFile.open(argv[2]);\n\n    if (!outFile.is_open())\n    {\n        std::cerr &lt;&lt; \"Error: 2'nd file could not be opened\" &lt;&lt; std::endl;\n        return 3;\n    }\n\n    std::cout &lt;&lt; \"\\nCopying \"\n              &lt;&lt; (std::string)argv[1] &lt;&lt; \" file contents into \"\n              &lt;&lt; (std::string)argv[2] &lt;&lt; std::endl;\n\n    // copy character by character - least efficient method &lt;==============\n    /*\n    char tmp;\n    while (inFile.get(tmp))\n    {\n        outFile.put(tmp);\n    }\n    */\n\n    // More efficient - https://www.geeksforgeeks.org/cpp-program-to-copy-one-file-into-another-file/ &lt;==============\n    /*\n    std::string tmpLine;\n    while (getline(inFile, tmpLine)) {\n        outFile &lt;&lt; tmpLine &lt;&lt; \"\\n\";\n    }\n    */\n\n    // Approach below is more efficient than copying one character/line at a time, &lt;============== \n    // especially when dealing with larger files.\n    /*\n    const size_t bufferSize =  1024 * 1024; //  1 MB buffer\n    std::vector&lt;char&gt; buffer(bufferSize);\n\n    while (inFile.read(buffer.data(), bufferSize)) {\n        outFile.write(buffer.data(), inFile.gcount());\n    }\n\n    // Write any remaining data\n    outFile.write(buffer.data(), inFile.gcount());\n    */\n\n    // Simple fast BINARY copy &lt;==============\n    /*\n    std::ifstream inFile(argv[1], std::ios::binary);\n    std::ofstream outFile(argv[2], std::ios::binary);\n    outFile &lt;&lt; inFile.rdbuf();\n    */\n\n    // simplest and (one of the) fastest way using stream buffer in ios library &lt;==============\n    // https://cplusplus.com/reference/ios/ios/rdbuf/ \n    // https://stackoverflow.com/questions/10195343/copy-a-file-in-a-sane-safe-and-efficient-way \n    outFile &lt;&lt; inFile.rdbuf(); \n\n    std::cout &lt;&lt; \"\\nDone!\\nExit program!\";\n\n    return 0;\n}\n</code></pre> <p>4 - Write a program that opens two text files for input and one for output.The program should concatenate the corresponding lines of the input files, use a space as a separator, and write the results to the output file. If one file is shorter than the other, the remaining lines in the longer file should also be copied to the output file. For example, suppose the first input file has these contents:</p> <pre><code>eggs kites donuts\nballoons hammers\nstones\n</code></pre> <p>And suppose the second input file has these contents:</p> <pre><code>zero lassitude\nfinance drama\n</code></pre> <p>The resulting file would have these contents:</p> <pre><code>eggs kites donuts zero lassitude\nballoons hammers finance drama\nstones\n</code></pre> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nint main(int argc, char **argv)\n{\n    if (argc == 1)\n    {\n        std::cerr &lt;&lt; \"\\nNo file arguments!\" &lt;&lt; std::endl;\n        std::cerr &lt;&lt; \"Exit program!\" &lt;&lt; std::endl;\n        return 1; // Exit failure - no file\n    }\n    else if (argc != 4)\n    {\n        std::cerr &lt;&lt; \"\\nIncorrect number of arguments!\" &lt;&lt; std::endl;\n        std::cerr &lt;&lt; \"Enter filename to copy data from as 1'st and 2'nd argument\" &lt;&lt; std::endl;\n        std::cerr &lt;&lt; \"3'rd argument should be the filename to write data into.\" &lt;&lt; std::endl;\n        return 2;\n    }\n\n    std::vector&lt;std::string&gt; dataVect;\n    std::ifstream inFile[2];\n\n    for (int i = 0; i &lt; 2; i++)\n    {\n        inFile[i].open(argv[i + 1]);\n\n        if (!inFile[i].is_open())\n        {\n            std::cerr &lt;&lt; \"Error: \" &lt;&lt; i &lt;&lt; \" input file could not be opened\" &lt;&lt; std::endl;\n            return 3;\n        }\n    }\n\n    std::ofstream outFile;\n    outFile.open(argv[3], std::ios_base::out | std::ios_base::app);\n\n    if (!outFile.is_open())\n    {\n        std::cerr &lt;&lt; \"Error: output file could not be opened\" &lt;&lt; std::endl;\n        return 3;\n    }\n\n    std::cout &lt;&lt; \"\\nCopying \"\n              &lt;&lt; (std::string)argv[1] &lt;&lt; \" and \" &lt;&lt; (std::string)argv[2] &lt;&lt; \" file contents into \"\n              &lt;&lt; (std::string)argv[3] &lt;&lt; std::endl;\n\n    std::string tmpLine;\n    int cntData[2]{};\n\n    // Assign data t ovector from 1'st file\n    while (std::getline(inFile[0], tmpLine))\n    {\n        dataVect.push_back(tmpLine);\n        cntData[0]++;\n    }\n\n    // Append data to vector from 2'nd file\n    while (std::getline(inFile[1], tmpLine))\n    {\n        if (cntData[1] &gt; cntData[0])\n        {\n            dataVect.push_back(tmpLine);\n        }\n        else\n        {\n            dataVect[cntData[1]] += \" \";\n            dataVect[cntData[1]] += tmpLine;\n            cntData[1]++;\n        }\n    }\n\n    // Write data into file\n    for (auto &amp;&amp;i : dataVect)\n    {\n        outFile &lt;&lt; i &lt;&lt; \"\\n\";\n    }\n\n    for (int i = 0; i &lt; 2; i++)\n    {\n        inFile[i].close();\n    }\n    outFile.close();\n\n    std::cout &lt;&lt; \"\\nDone!\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> txt 1'st file <pre><code>eggs kites donuts\nballoons hammers\nstones\n</code></pre> txt 2'nd file <pre><code>zero lassitude\nfinance drama\n</code></pre> <p>5 - Mat and Pat want to invite their friends to a party, much as they did in Programming Exercise 8 in Chapter 16, except now they want a program that uses files. They have asked you to write a program that does the following:</p> <ul> <li>Reads a list of Mat\u2019s friends\u2019 names from a text file called <code>mat.dat</code>, which lists one friend per line. The names are stored in a container and then displayed in sorted order.</li> <li>Reads a list of Pat\u2019s friends\u2019 names from a text file called <code>pat.dat</code>, which lists one friend per line. The names are stored in a container and then displayed in sorted order.</li> <li>Merges the two lists, eliminating duplicates and stores the result in the file matnpat.dat, one friend per line.</li> </ul> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;    // getline\n#include &lt;algorithm&gt; // sort\n#include &lt;fstream&gt;\n\nint read_friends(std::list&lt;std::string&gt; &amp;rd, std::string const &amp;fn)\n{\n    std::ifstream ifile(fn);\n    std::string tmpLine;\n\n    if (!ifile.is_open())\n    {\n        std::cerr &lt;&lt; \"\\nError opening file\";\n        return 1;\n    }\n\n    while (std::getline(ifile, tmpLine))\n    {\n        rd.push_back(tmpLine);\n    }\n\n    ifile.close();\n\n    return 0;\n}\n\nint write_friends(std::list&lt;std::string&gt; &amp;rd, std::string const &amp;fn)\n{\n    std::ofstream ofile(fn);\n\n    if (!ofile.is_open())\n    {\n        std::cerr &lt;&lt; \"\\nError opening file\";\n        return 1;\n    }\n\n    for (auto &amp;&amp;i : rd)\n    {\n        ofile &lt;&lt; i &lt;&lt; \"\\n\";\n    }\n\n    ofile.close();\n\n    return 0;\n}\n\nint main()\n{\n    std::list&lt;std::string&gt; matFriendNames;\n    std::list&lt;std::string&gt; patFriendNames;\n    std::list&lt;std::string&gt; commonFriendNames;\n\n    std::vector&lt;std::string&gt; fileNames{\n        \"ch17_5_mat.dat\", \"ch17_5_pat.dat\", \"ch17_5_mrg.dat\"};\n\n    // Read, sort and display Mat friends\n    read_friends(matFriendNames, fileNames[0]);\n    matFriendNames.sort();\n\n    std::cout &lt;&lt; \"\\nMat friends: \\n\";\n    for (auto a : matFriendNames)\n    {\n        std::cout &lt;&lt; a &lt;&lt; std::endl;\n    }\n\n    // Read, sort and display Pat friends\n    read_friends(patFriendNames, fileNames[1]);\n    patFriendNames.sort();\n\n    std::cout &lt;&lt; \"\\nPat friends: \\n\";\n    for (auto a : patFriendNames)\n    {\n        std::cout &lt;&lt; a &lt;&lt; std::endl;\n    }\n\n    // Merge, remove duplicates, display and write to file\n    commonFriendNames.merge(matFriendNames);\n    commonFriendNames.merge(patFriendNames);\n\n    commonFriendNames.unique();\n\n    std::cout &lt;&lt; \"\\nMutual friends: \\n\";\n    for (auto a : commonFriendNames)\n    {\n        std::cout &lt;&lt; a &lt;&lt; std::endl;\n    }\n\n    write_friends(commonFriendNames, fileNames[2]);\n\n    std::cout &lt;&lt; \"\\nDone!\";\n\n    return 0;\n}\n</code></pre> Pat dat <pre><code>zero lassitude\nfinance drama\n</code></pre> Mat dat <pre><code>eggs kites donuts\nballoons hammers\nstones\n</code></pre> <p>6 - Consider the class definitions of Programming Exercise 5 in Chapter 14,\u201cReusing Code in C++\u201d. If you haven\u2019t yet done that exercise, do so now. Then do the following:</p> <p>Write a program that uses standard C++ I/O and file I/O in conjunction with data of types employee, manager, fink, and highfink, as defined in Programming Exercise 5 in Chapter 14. The program should be along the general lines of Listing 17.17 in that it should let you add new data to a file. The first time through, the program should solicit data from the user, show all the entries, and save the information in a file. On subsequent uses, the program should first read and display the file data, let the user add data, and show all the data. One difference is that data should be handled by an array of pointers to type employee.That way, a pointer can point to an employee object or to objects of any of the three derived types. Keep the array small to facilitate checking the program; for example, you might limit the array to 10 elements:</p> <pre><code>const int MAX = 10; // no more than 10 objects\n...\nemployee * pc[MAX];\n</code></pre> <p>For keyboard entry, the program should use a menu to offer the user the choice of which type of object to create.The menu should use a switch to use <code>new</code> to create an object of the desired type and to assign the object\u2019s address to a pointer in the pc array.Then that object can use the virtual <code>setall()</code> function to elicit the appropriate data from the user:</p> <pre><code>pc[i]-&gt;setall(); // invokes function corresponding to type of object\n</code></pre> <p>To save the data to a file, devise a virtual writeall() function for that purpose:</p> <pre><code>for (i = 0; i &lt; index; i++)\n    pc[i]-&gt;writeall(fout);// fout ofstream connected to output file\n</code></pre>       Note       Use text I/O, not binary I/O, for Programming Exercise 6. (Unfortunately, virtual objects include pointers to tables of pointers to virtual functions, and <code>write()</code> copies this information to a file. An object filled by using <code>read()</code> from the file gets weird values for the function pointers, which really messes up the behavior of virtual functions.) Use a newline character to separate each data field from the next; this makes it easier to identify fields on input. Or you could still use binary I/O, but not write objects as a whole. Instead, you could provide class methods that apply the <code>write()</code> and <code>read()</code> functions to each class member individually rather than to the object as a whole. That way, the program could save just the intended data to a file.   <p>The tricky part is recovering the data from the file. The problem is, how can the program know whether the next item to be recovered is an <code>employee</code> object, a <code>manager</code> object, a <code>fink</code> type, or a <code>highfink</code> type? One approach is, when writing the data for an object to a file, precede the data with an integer that indicates the type of object to follow.Then, on file input, the program can read the integer and then use <code>switch</code> to create the appropriate object to receive the data:</p> <pre><code>enum classkind\n{\n    Employee,\n    Manager,\n    Fink,\n    Highfink\n}; // in class header\n... int classtype;\nwhile ((fin &gt;&gt; classtype).get(ch)) // newline separates int from data\n{ \n    switch (classtype)\n    {\n        case Employee:\n            pc[i] = new employee;\n                    : break;\n</code></pre> <p>Then you can use the pointer to invoke a virtual <code>getall()</code> function to read the information:</p> <pre><code>pc[i++]-&gt;getall();\n</code></pre> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include \"ch17_6_emp.h\"\n\nusing namespace std;\n\nvoid printMenu();\nint countData(ifstream &amp;fin, string fn);\nconst int MAX = 10; // no more than 10 objects\n\nint main(void)\n{\n    int classtype{};\n    abstr_emp *pc[MAX];\n    ifstream fin;\n    ofstream fout;\n    string fname{\"ch17_6_emp.dat\"};\n\n    fin.open(fname);\n    if (fin.good() &amp;&amp; fin.is_open())\n    {\n        char ch;\n        int i{};\n\n        cout &lt;&lt; \"File found, loading data.\" &lt;&lt; '\\n';\n\n        while ((fin &gt;&gt; classtype).get(ch))\n        {\n\n            switch (classtype)\n            {\n            case Employee:\n                pc[i] = new employee();\n                break;\n            case Manager:\n                pc[i] = new manager();\n                break;\n            case Fink:\n                pc[i] = new fink();\n                break;\n            case Highfink:\n                pc[i] = new highfink();\n                break;\n            default:\n                cout &lt;&lt; \"\\nErroneous input in file..\\n\";\n                break;\n            }\n\n            pc[i]-&gt;ReadAll(fin);\n            pc[i]-&gt;ShowAll();\n            i++;\n\n            if (i &gt;= MAX)\n            {\n                cout &lt;&lt; \"\\nMaximum number of data reached!\\n\";\n                break;\n            }\n        }\n\n        fin.close();\n    }\n    else if (!fin.good())\n    {\n        cout &lt;&lt; \"File don't exist!\" &lt;&lt; endl;\n    }\n    else\n    {\n        cerr &lt;&lt; \"Couldn't open file\" &lt;&lt; '\\n';\n        exit(EXIT_FAILURE);\n    }\n\n    fout.open(fname, ios::out | ios::app);\n    if (fout.is_open())\n    {\n        char ch;\n        int i{};\n        bool wi{false};\n        bool qm{false};\n        bool fst_app{false}; // first time appending\n\n        printMenu();\n\n        while ((cin &gt;&gt; classtype).get(ch))\n        {\n            wi = false;\n\n            if (!fst_app &amp;&amp; classtype &lt; 4)\n            {\n                fst_app = true;\n                fout &lt;&lt; '\\n';\n            }\n\n            switch (classtype)\n            {\n            case Employee:\n                fout &lt;&lt; Employee &lt;&lt; endl;\n                pc[i] = new employee();\n                break;\n            case Manager:\n                fout &lt;&lt; Manager &lt;&lt; endl;\n                pc[i] = new manager();\n                break;\n            case Fink:\n                fout &lt;&lt; Fink &lt;&lt; endl;\n                pc[i] = new fink();\n                break;\n            case Highfink:\n                fout &lt;&lt; Highfink &lt;&lt; endl;\n                pc[i] = new highfink();\n                break;\n            case 9:\n                cout &lt;&lt; \"\\nBye!\\n\";\n                qm = true;\n                break;\n            default:\n                wi = true;\n                cout &lt;&lt; \"\\nWrong input.\\n\";\n                while (cin.get() != '\\n')\n                {\n                    continue;\n                }\n                break;\n            }\n\n            if (qm)\n            {\n                break;\n            }\n\n            if (!wi)\n            {\n\n                pc[i]-&gt;SetAll();\n                pc[i]-&gt;WriteAll(fout);\n                pc[i]-&gt;ShowAll();\n                i++;\n\n                if (i &gt;= MAX)\n                {\n                    cout &lt;&lt; \"\\nMaximum number of data reached!\\n\";\n                    break;\n                }\n            }\n            printMenu();\n        }\n\n        fout.close();\n    }\n    else\n    {\n        cerr &lt;&lt; \"Couldn't open/make file\" &lt;&lt; '\\n';\n        exit(EXIT_FAILURE);\n    }\n\n    countData(fin, fname);\n\n    fin.clear();\n    fin.open(fname);\n    if (fin.good() &amp;&amp; fin.is_open())\n    {\n        char ch;\n        int i{};\n\n        cout &lt;&lt; \"Current data in file:\" &lt;&lt; endl;\n\n        while ((fin &gt;&gt; classtype).get(ch))\n        {\n\n            switch (classtype)\n            {\n            case Employee:\n                pc[i] = new employee();\n                break;\n            case Manager:\n                pc[i] = new manager();\n                break;\n            case Fink:\n                pc[i] = new fink();\n                break;\n            case Highfink:\n                pc[i] = new highfink();\n                break;\n            default:\n                cout &lt;&lt; \"\\nErroneous input in file..\\n\";\n                break;\n            }\n\n            pc[i]-&gt;ReadAll(fin);\n            pc[i]-&gt;ShowAll();\n            i++;\n        }\n\n        fin.close();\n    }\n    else if (!fin.good())\n    {\n        cerr &lt;&lt; \"File don't exist!\" &lt;&lt; endl;\n        exit(EXIT_FAILURE);\n    }\n    else\n    {\n        cerr &lt;&lt; \"Couldn't open file\" &lt;&lt; '\\n';\n        exit(EXIT_FAILURE);\n    }\n\n    cout &lt;&lt; \"\\nDone!\" &lt;&lt; endl;\n    return 0;\n}\n\nvoid printMenu()\n{\n    cout &lt;&lt; \"\\nSelect type of data to write and save:\\n\"\n         &lt;&lt; Employee &lt;&lt; \") Employee\\t\" &lt;&lt; Manager &lt;&lt; \") Manager\\n\"\n         &lt;&lt; Fink &lt;&lt; \") Fink\\t\\t\" &lt;&lt; Highfink &lt;&lt; \") High Fink\\n\"\n         &lt;&lt; \"9) Quit Write-Menu\\n\";\n}\n\n// Listing 17.17 count.cpp // without arg\nint countData(ifstream &amp;fin, string fn)\n{\n\n    long count;\n    long total = 0;\n    char ch;\n    fin.open(fn);\n    if (!fin.is_open())\n    {\n        cerr &lt;&lt; \"Could not open \" &lt;&lt; fn &lt;&lt; endl;\n        fin.clear();\n        return 1;\n    }\n    count = 0;\n    while (fin.get(ch))\n        count++;\n    cout &lt;&lt; count &lt;&lt; \" characters in \" &lt;&lt; fn &lt;&lt; endl;\n    total += count;\n    fin.clear(); // needed for some implementations\n    fin.close(); // disconnect file\n\n    return 0;\n}\n</code></pre> Code - classes prototypes <pre><code>// emp.h -- header file for abstr_emp class and children\n\n#ifndef _EMP_H_\n#define _EMP_H_\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n\nenum classkind\n{\n    Employee,\n    Manager,\n    Fink,\n    Highfink\n}; // in class header\n\nclass abstr_emp\n{\nprivate:\n    std::string fname; // abstr_emp's first name\n    std::string lname; // abstr_emp's last name\n    std::string job;\n\npublic:\n    abstr_emp();\n    abstr_emp(const std::string &amp;fn, const std::string &amp;ln, const std::string &amp;j);\n\n    virtual void ShowAll() const; // labels and shows all data\n    virtual void SetAll();        // prompts user for values\n    virtual void ReadAll(std::ifstream &amp;fi);\n    virtual void WriteAll(std::ofstream &amp;fo);\n\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const abstr_emp &amp;e);\n\n    // just displays first and last name\n    virtual ~abstr_emp() = 0; // virtual base class\n};\n\nclass employee : public abstr_emp\n{\npublic:\n    employee();\n    employee(const std::string &amp;fn, const std::string &amp;ln, const std::string &amp;j);\n    virtual void ShowAll() const;\n    virtual void SetAll();\n    virtual void ReadAll(std::ifstream &amp;fi);\n    virtual void WriteAll(std::ofstream &amp;fo);\n};\n\nclass manager : virtual public abstr_emp\n{\nprivate:\n    int inchargeof; // number of abstr_emps managed\n\nprotected:\n    int InChargeOf() const { return inchargeof; } // output\n    int &amp;InChargeOf() { return inchargeof; }      // input\n\npublic:\n    manager();\n    manager(const std::string &amp;fn, const std::string &amp;ln,\n            const std::string &amp;j, int ico = 0);\n    manager(const abstr_emp &amp;e, int ico);\n    manager(const manager &amp;m);\n    virtual void ShowAll() const;\n    virtual void SetAll();\n    virtual void ReadAll(std::ifstream &amp;fi);\n    virtual void WriteAll(std::ofstream &amp;fo);\n};\n\nclass fink : virtual public abstr_emp\n{\nprivate:\n    std::string reportsto; // to whom fink reports\n\nprotected:\n    const std::string ReportsTo() const { return reportsto; }\n    std::string &amp;ReportsTo() { return reportsto; }\n    void setReportsTo(std::string rt) { reportsto = rt; }\n\npublic:\n    fink();\n    fink(const std::string &amp;fn, const std::string &amp;ln,\n         const std::string &amp;j, const std::string &amp;rpo);\n    fink(const abstr_emp &amp;e, const std::string &amp;rpo);\n    fink(const fink &amp;e);\n    virtual void ShowAll() const;\n    virtual void SetAll();\n    virtual void ReadAll(std::ifstream &amp;fi);\n    virtual void WriteAll(std::ofstream &amp;fo);\n};\n\nclass highfink : public manager, public fink // management fink\n{\npublic:\n    highfink();\n    highfink(const std::string &amp;fn, const std::string &amp;ln,\n             const std::string &amp;j, const std::string &amp;rpo,\n             int ico);\n    highfink(const abstr_emp &amp;e, const std::string &amp;rpo, int ico);\n    highfink(const fink &amp;f, int ico);\n    highfink(const manager &amp;m, const std::string &amp;rpo);\n    highfink(const highfink &amp;h);\n    virtual void ShowAll() const;\n    virtual void SetAll();\n    virtual void ReadAll(std::ifstream &amp;fi);\n    virtual void WriteAll(std::ofstream &amp;fo);\n};\n\n#endif\n</code></pre> Code - classes methods <pre><code>#include \"ch17_6_emp.h\"\n\n/// abstr_emp /// --------------------------------------\nabstr_emp::abstr_emp()\n{\n    fname = \"-\";\n    lname = \"-\";\n    job = \"-\";\n}\n\nabstr_emp::abstr_emp(const std::string &amp;fn, const std::string &amp;ln, const std::string &amp;j)\n{\n    fname = fn;\n    lname = ln;\n    job = j;\n}\n\nvoid abstr_emp::ShowAll() const\n{\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"First name: \" &lt;&lt; fname;\n\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Last name: \" &lt;&lt; lname;\n\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Profession: \" &lt;&lt; job;\n    std::cout &lt;&lt; std::endl;\n}\n\nvoid abstr_emp::SetAll()\n{\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Enter the first name: \";\n    std::getline(std::cin, fname);\n\n    std::cout &lt;&lt; \"Enter the last name: \";\n    std::getline(std::cin, lname);\n\n    std::cout &lt;&lt; \"Enter the profession: \";\n    std::getline(std::cin, job);\n}\n\nvoid abstr_emp::ReadAll(std::ifstream &amp;fi)\n{\n    std::getline(fi, fname);\n    std::getline(fi, lname);\n    std::getline(fi, job);\n}\n\nvoid abstr_emp::WriteAll(std::ofstream &amp;fo)\n{\n    fo &lt;&lt; fname &lt;&lt; std::endl;\n    fo &lt;&lt; lname &lt;&lt; std::endl;\n    fo &lt;&lt; job &lt;&lt; std::endl;\n}\n\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const abstr_emp &amp;e)\n{\n    os &lt;&lt; e.fname &lt;&lt; \" \" &lt;&lt; e.lname &lt;&lt; \", \" &lt;&lt; e.job;\n    return os;\n}\n\nabstr_emp::~abstr_emp()\n{\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"\\tEliminated: \" &lt;&lt; fname &lt;&lt; \" \" &lt;&lt; lname;\n}\n\n/// employee /// --------------------------------------\nemployee::employee() : abstr_emp()\n{\n}\n\nemployee::employee(const std::string &amp;fn, const std::string &amp;ln, const std::string &amp;j) : abstr_emp(fn, ln, j)\n{\n}\n\nvoid employee::ShowAll() const\n{\n    abstr_emp::ShowAll();\n}\n\nvoid employee::SetAll()\n{\n    abstr_emp::SetAll();\n}\n\nvoid employee::ReadAll(std::ifstream &amp;fi)\n{\n    abstr_emp::ReadAll(fi);\n}\n\nvoid employee::WriteAll(std::ofstream &amp;fo)\n{\n    abstr_emp::WriteAll(fo);\n}\n\n/// manager /// --------------------------------------\nmanager::manager() : abstr_emp()\n{\n    inchargeof = 0;\n}\n\nmanager::manager(const std::string &amp;fn, const std::string &amp;ln,\n                 const std::string &amp;j, int ico) : abstr_emp(fn, ln, j)\n{\n    inchargeof = ico;\n}\n\n// Base class constructor is automatically invoked unless another\n// constructor is explicitly called in the derived class for abstr_emp(e) - so called shallow copy\nmanager::manager(const abstr_emp &amp;e, int ico) : abstr_emp(e)\n{\n    inchargeof = ico;\n}\n\nmanager::manager(const manager &amp;m) : abstr_emp(m)\n{\n    inchargeof = m.InChargeOf();\n}\n\nvoid manager::ShowAll() const\n{\n    abstr_emp::ShowAll();\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Manager is in charge of: \" &lt;&lt; inchargeof &lt;&lt; \" people\";\n    std::cout &lt;&lt; std::endl;\n}\n\nvoid manager::SetAll()\n{\n    abstr_emp::SetAll();\n\n    std::cout &lt;&lt; \"Enter the amount of people manager will be in charge of: \";\n\n    while (!(std::cin &gt;&gt; inchargeof || inchargeof &lt;= 0))\n    {\n        std::cin.clear(); // reset input\n        while (std::cin.get() != '\\n')\n            continue; // get rid of bad input\n        std::cout &lt;&lt; \"Please enter a positive number: \";\n    }\n\n    std::cin.clear(); // reset input after putting in data\n    while (std::cin.get() != '\\n')\n        continue; // get rid of bad input\n}\n\nvoid manager::ReadAll(std::ifstream &amp;fi)\n{\n    abstr_emp::ReadAll(fi);\n    fi &gt;&gt; inchargeof;\n}\n\nvoid manager::WriteAll(std::ofstream &amp;fo)\n{\n    abstr_emp::WriteAll(fo);\n    fo &lt;&lt; inchargeof &lt;&lt; std::endl;\n}\n\n/// fink /// --------------------------------------\nfink::fink() : abstr_emp()\n{\n    reportsto = \"-\";\n}\n\nfink::fink(const std::string &amp;fn, const std::string &amp;ln,\n           const std::string &amp;j, const std::string &amp;rpo) : abstr_emp(fn, ln, j)\n{\n    reportsto = rpo;\n}\n\nfink::fink(const abstr_emp &amp;e, const std::string &amp;rpo) : abstr_emp(e)\n{\n    reportsto = rpo;\n}\n\nfink::fink(const fink &amp;e) : abstr_emp(e)\n{\n    reportsto = e.reportsto;\n    // reportsto = e.ReportsTo();\n    // reportsto = this-&gt;ReportsTo(); // ??\n}\n\nvoid fink::ShowAll() const\n{\n    abstr_emp::ShowAll();\n    std::cout &lt;&lt; \"Fink reports to: \" &lt;&lt; reportsto;\n    std::cout &lt;&lt; std::endl;\n}\n\nvoid fink::SetAll()\n{\n    abstr_emp::SetAll();\n    std::cout &lt;&lt; \"Enter superior to reports to: \";\n    std::getline(std::cin, reportsto);\n}\n\nvoid fink::ReadAll(std::ifstream &amp;fi)\n{\n    abstr_emp::ReadAll(fi);\n    std::getline(fi, reportsto);\n}\n\nvoid fink::WriteAll(std::ofstream &amp;fo)\n{\n    abstr_emp::WriteAll(fo);\n    fo &lt;&lt; reportsto &lt;&lt; std::endl;\n}\n\n/// high fink /// --------------------------------------\n\nhighfink::highfink() : abstr_emp(), manager(), fink()\n{\n}\n\nhighfink::highfink(const std::string &amp;fn, const std::string &amp;ln,\n                   const std::string &amp;j, const std::string &amp;rpo,\n                   int ico) : abstr_emp(fn, ln, j), manager(fn, ln, j, ico), fink(fn, ln, j, rpo)\n{\n}\n\nhighfink::highfink(const abstr_emp &amp;e, const std::string &amp;rpo, int ico) : abstr_emp(e), manager(e, ico), fink(e, rpo)\n{\n}\n\nhighfink::highfink(const fink &amp;f, int ico) : abstr_emp(f), manager(f, ico), fink(f)\n{\n}\n\nhighfink::highfink(const manager &amp;m, const std::string &amp;rpo) : abstr_emp(m), manager(m), fink(m, rpo)\n{\n}\n\nhighfink::highfink(const highfink &amp;h) : abstr_emp(h), manager(h), fink(h)\n{\n}\n\nvoid highfink::ShowAll() const\n{\n    manager::ShowAll();\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"High fink reports to: \" &lt;&lt; fink::ReportsTo();\n    std::cout &lt;&lt; std::endl;\n}\n\nvoid highfink::SetAll()\n{\n    abstr_emp::SetAll();\n    std::cout &lt;&lt; \"In charge of: \";\n    std::cin &gt;&gt; manager::InChargeOf();\n    std::cin.ignore();\n    std::cout &lt;&lt; \"Reports to: \";\n    getline(std::cin, fink::ReportsTo());\n}\n\nvoid highfink::ReadAll(std::ifstream &amp;fi)\n{\n    abstr_emp::ReadAll(fi);\n    fi &gt;&gt; manager::InChargeOf();\n    fi.ignore(); // necessary for correct work of getline !!!\n    getline(fi, fink::ReportsTo());\n}\n\nvoid highfink::WriteAll(std::ofstream &amp;fo)\n{\n    abstr_emp::WriteAll(fo);\n    fo &lt;&lt; manager::InChargeOf() &lt;&lt; std::endl;\n    fo &lt;&lt; fink::ReportsTo() &lt;&lt; std::endl;\n}\n</code></pre> <p>7 - Here is part of a program that reads keyboard input into a vector of <code>string</code> objects, stores the string contents (not the objects) in a file, and then copies the file contents back into a vector of <code>string</code> objects:</p> <pre><code>int main()\n{\n    using namespace std;\n    vector&lt;string&gt; vostr;\n    string temp;\n\n    // acquire strings\n    cout &lt;&lt; \"Enter strings (empty line to quit):\\n\";\n    while (getline(cin, temp) &amp;&amp; temp[0] != '\\0')\n        vostr.push_back(temp);\n    cout &lt;&lt; \"Here is your input.\\n\";\n    for_each(vostr.begin(), vostr.end(), ShowStr);\n\n    // store in a file\n    ofstream fout(\"strings.dat\", ios_base::out | ios_base::binary);\n    for_each(vostr.begin(), vostr.end(), Store(fout));\n    fout.close();\n\n    // recover file contents\n    vector&lt;string&gt; vistr;\n    ifstream fin(\"strings.dat\", ios_base::in | ios_base::binary);\n    if (!fin.is_open())\n    {\n        cerr &lt;&lt; \"Could not open file for input.\\n\";\n        exit(EXIT_FAILURE);\n    }\n    GetStrs(fin, vistr);\n    cout &lt;&lt; \"\\nHere are the strings read from the file:\\n\";\n    for_each(vistr.begin(), vistr.end(), ShowStr);\n    return 0;\n}\n</code></pre> <p>Note that the file is opened in binary format and that the intention is that I/O be accomplished with <code>read()</code> and <code>write()</code>. Quite a bit remains to be done:</p> <ul> <li> <p>Write a <code>void ShowStr(const string &amp;)</code> function that displays a string object followed by a newline character.</p> </li> <li> <p>Write a <code>Store</code> functor that writes string information to a file.The Store     constructor should specify an <code>ifstream</code> object, and the overloaded     <code>operator()(const string &amp;)</code> should indicate the string to write. A workable     plan is to first write the string\u2019s size to the file and then write the string     contents. For example, if len holds the string size, you could use this:</p> <pre><code>os.write((char *)&amp;len, sizeof(std::size_t)); // store length\nos.write(s.data(), len); // store characters\n</code></pre> <p>The <code>data()</code> member returns a pointer to an array that holds the characters in the string. It\u2019s similar to the <code>c_str()</code> member except that the latter appends a null character.</p> </li> <li> <p>Write a <code>GetStrs()</code> function that recovers information from the file. It can use <code>read()</code> to obtain the size of a string and then use a loop to read that many characters from the file, appending them to an initially empty temporary string. Because a string\u2019s data is private, you have to use a class method to get data into the string rather than read directly into it.</p> </li> </ul> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt; // for_each\n#include &lt;fstream&gt;\n\nusing namespace std;\n\n// Store functor // functor that writes string information to a file.\nclass Store\n{\n    ostream &amp;os; // ofstream &amp;os; // also correct -\n\npublic:\n    Store(ofstream &amp;o) : os(o) {}\n\n    // Binary output\n    void operator()(const string &amp;str)\n    {\n        size_t len = str.size();\n        os.write((char *)&amp;len, sizeof(size_t));\n        os.write(str.data(), len);\n    }\n};\n\nvoid GetStrs(std::ifstream &amp;is, std::vector&lt;std::string&gt; &amp;vstr) {\n    // The function reads the length of each string as a size_t from the binary file\n    // in any other cases there can be artefacts, because it was written in size_t\n    size_t len; \n    char ch;\n    std::string temp;\n\n    while (is.read((char*)(&amp;len), sizeof(len))) {\n        temp.clear();\n        // reads len characters into a temporary string temp\n        for (size_t i =  0; i &lt; len; ++i) { \n            if (is.read(&amp;ch,  1)) { // byte after byte\n                temp += ch;\n            } else {\n                break;\n            }\n        }\n        if (is) { // Check if the stream is still good\n            vstr.push_back(temp);\n        }\n    }\n}\n\n// function that displays a string object followed by a newline character.\nvoid ShowStr(string &amp;s)\n{\n    cout &lt;&lt; s &lt;&lt; \"\\n\";\n}\n\nint main()\n{\n    using namespace std;\n    vector&lt;string&gt; vostr;\n    string temp;\n\n    // acquire strings\n    cout &lt;&lt; \"Enter strings (empty line to quit):\\n\";\n    while (getline(cin, temp) &amp;&amp; temp[0] != '\\0')\n        vostr.push_back(temp);\n    cout &lt;&lt; \"Here is your input.\\n\";\n    for_each(vostr.begin(), vostr.end(), ShowStr);\n\n    // store in a file\n    ofstream fout(\"strings.dat\", ios_base::out | ios_base::binary);\n    for_each(vostr.begin(), vostr.end(), Store(fout));\n    fout.close();\n\n    // recover file contents\n    vector&lt;string&gt; vistr;\n    ifstream fin(\"strings.dat\", ios_base::in | ios_base::binary);\n    if (!fin.is_open())\n    {\n        cerr &lt;&lt; \"Could not open file for input.\\n\";\n        exit(EXIT_FAILURE);\n    }\n    GetStrs(fin, vistr);\n    cout &lt;&lt; \"\\nHere are the strings read from the file:\\n\";\n    for_each(vistr.begin(), vistr.end(), ShowStr);\n    return 0;\n}\n</code></pre>"},{"location":"exercises/#chapter-18","title":"Chapter 18","text":"<p>1 - Here is part of a short program:</p> <pre><code>int main()\n{\n    using namespace std;\n    // list of double deduced from list contents\n    auto q = average_list({15.4, 10.7, 9.0});\n    cout &lt;&lt; q &lt;&lt; endl;\n    // list of int deduced from list contents\n    cout &lt;&lt; average_list({20, 30, 19, 17, 45, 38}) &lt;&lt; endl;\n    // forced list of double\n    auto ad = average_list&lt;double&gt;({'A', 70, 65.33});\n    cout &lt;&lt; ad &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>Complete the program by supplying the <code>average_list()</code> function. It should be a template function, with the type parameter being used to specify the kind of <code>initialized_list</code> template to be used as the function parameter and also to give the function return type.</p> Code - program <pre><code>#include &lt;iostream&gt;\n#include &lt;initializer_list&gt;\n\ntemplate &lt;typename T&gt;\nT average_list(std::initializer_list&lt;T&gt; tin)\n{\n    T sum{};\n    int i{};\n\n    for(auto a : tin)\n    {\n        sum += a;\n        i++;\n    }\n\n    // Different method\n    /*\n    for (auto p = tin.begin(); p != tin.end(); p++)\n    {\n        sum += *p;\n        i++;\n    }\n    */\n\n    return sum / i;\n}\n\nint main()\n{\n    using namespace std;\n    // list of double deduced from list contents\n    auto q = average_list({15.4, 10.7, 9.0});\n    cout &lt;&lt; q &lt;&lt; endl;\n    // list of int deduced from list contents\n    cout &lt;&lt; average_list({20, 30, 19, 17, 45, 38}) &lt;&lt; endl;\n    // forced list of double\n    auto ad = average_list&lt;double&gt;({'A', 70, 65.33});\n    cout &lt;&lt; ad &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>2 - Here is declaration for the <code>Cpmv</code> class:</p> <pre><code>class Cpmv\n{\npublic:\n    struct Info\n    {\n        std::string qcode;\n        std::string zcode;\n    };\n\nprivate:\n    Info *pi;\n\npublic:\n    Cpmv();\n    Cpmv(std::string q, std::string z);\n    Cpmv(const Cpmv &amp;cp);\n    Cpmv(Cpmv &amp;&amp;mv);\n    ~Cpmv();\n    Cpmv &amp;operator=(const Cpmv &amp;cp);\n    Cpmv &amp;operator=(Cpmv &amp;&amp;mv);\n    Cpmv operator+(const Cpmv &amp;obj) const;\n    void Display() const;\n};\n</code></pre> <p>The <code>operator+()</code> function should create an object whose <code>qcode</code> and <code>zcode</code> members concatenate the corresponding members of the operands. Provide code that implements move semantics for the move constructor and the move assignment operator. Write a program that uses all the methods. For testing purposes, make the various methods verbose so that you can see when they are used.</p> Code - program <pre><code>#include &lt;iostream&gt;\n#include \"ch18_2_cmpv.cpp\"\n\nint main()\n{\n\n    return 0;\n}\n</code></pre> Code - class <pre><code>#ifndef _CMPV_H_\n#define _CMPV_H_\n\n#include &lt;iostream&gt;\n\nclass Cpmv\n{\npublic:\n    struct Info\n    {\n        std::string qcode;\n        std::string zcode;\n    };\n\nprivate:\n    Info *pi;\n\npublic:\n    Cpmv();\n    Cpmv(std::string q, std::string z);\n    Cpmv(const Cpmv &amp;cp);\n    Cpmv(Cpmv &amp;&amp;mv);\n    ~Cpmv();\n    Cpmv &amp;operator=(const Cpmv &amp;cp);\n    Cpmv &amp;operator=(Cpmv &amp;&amp;mv);\n    Cpmv operator+(const Cpmv &amp;obj) const;\n    void Display() const;\n};\n\n#endif\n</code></pre> <p>3 - Write and test a variadic template function <code>sum_values()</code> that accepts an arbitrarily long list of arguments with numeric values (they can be a mixture of types) and returns the sum as a <code>long double</code> value</p> Code - program <pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename... T&gt;\nT sum_values(T... tin)\n{\n\n}\n\nint main()\n{\n\n    return 0;\n}\n</code></pre> <p>4 - Redo Listing 16.5 using lambdas. In particular, replace the <code>outint()</code> function with a named lambda and replace the two uses of a functor with two anonymous lambda expressions.</p>"},{"location":"notes/","title":"Notes","text":"<p>The <code>good()</code> method in C++ is used to check the state of a stream object. It returns true if none of the stream's error state flags (<code>eofbit</code>, <code>failbit</code>, <code>badbit</code>) are set. These flags indicate end-of-file, a logical error on the stream, and a reading or writing error on the stream, respectively. If any of these flags are set, the good() method returns false.</p> <p>It's a good practice to use <code>good()</code> or similar methods (<code>is_open()</code>, <code>fail()</code>, etc.) before writing data into a file. These methods allow you to check the state of your file stream and ensure that it's safe to proceed with writing data. If you don't check the state of the file stream before writing, you might encounter errors or exceptions, especially if the file doesn't exist, can't be accessed, or has been corrupted.</p>"},{"location":"notes/#debug-in-vscode","title":"Debug in VSCode","text":"<p>PATH: <code>.vscode/launch.json</code></p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"(gdb) Launch\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/exercises/chapter11/ch11_2.out\",\n            \"args\": [],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${workspaceFolder}\",\n            \"environment\": [],\n            \"externalConsole\": false,\n            \"MIMode\": \"gdb\",\n            \"setupCommands\": [\n                {\n                    \"description\": \"Enable pretty-printing for gdb\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                }\n            ],\n            \"additionalSOLibSearchPath\": \"/path/to/symbols;/another/path/to/symbols\"\n        }\n    ]\n}\n</code></pre> <p>PATH: <code>.vscode/tasks.json</code></p> <pre><code>{\n    \"tasks\": [\n        {\n            \"type\": \"cppbuild\",\n            \"label\": \"C/C++: g++-11 build active file\",\n            \"command\": \"/usr/bin/g++-11\",\n            \"args\": [\n                \"-fdiagnostics-color=always\",\n                \"-g\",\n                // \"${file}\",\n                \"${workspaceFolder}/exercises/chapter11/ch11_2.cpp\",\n                \"${workspaceFolder}/exercises/chapter11/ch11_2_vect.cpp\",\n                \"-o\",\n                \"${fileDirname}/${fileBasenameNoExtension}\"\n            ],\n            \"options\": {\n                \"cwd\": \"${fileDirname}\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ],\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true\n            },\n            \"detail\": \"Task generated by Debugger.\"\n        }\n    ],\n    \"version\": \"2.0.0\"\n}\n</code></pre> <p><code>Inline</code> keyword tells the compiler to consider function for <code>inlining</code>. If the function is small and called frequently, inlining it can lead to performance improvements because the overhead of a function call is avoided.</p> <p><code>Inlining</code> - mean that the code of the function is inserted at the point where the function is called, instead of performing a regular function call. This can potentially improve performance by avoiding the overhead of a function call, but it might increase the size of the binary file because the function's code could be inserted in multiple places</p>"},{"location":"notes/#classes","title":"Classes","text":"<ul> <li>when <code>designing</code> a <code>class</code>, you need to develop a <code>public interface</code> and a <code>private implementation</code>.</li> </ul>"},{"location":"notes/#is-a-relationship-considerations-public-inheritance-str-772-c-prime-plus","title":"Is-a Relationship Considerations (Public Inheritance) - str. 772 \"C++ Prime Plus\"","text":"<p>\"You should be guided by the <code>is-a</code> relationship. If your proposed derived class is not a particular kind of the base class, you shouldn\u2019t use public derivation. For example, you shouldn\u2019t derive a <code>Programmer</code> class from a <code>Brain</code> class. If you want to represent the belief that a programmer has a brain, you should use a <code>Brain</code> class object as a member of the <code>Programmer</code> class.\"</p>"},{"location":"notes/#inheritance","title":"Inheritance","text":"<ul> <li>\"Private inheritance limits the use of base-class methods to within derived-class methods\" page 800.</li> </ul>"},{"location":"notes/#stl-iterators","title":"STL Iterators","text":"<p>Constant-time complexity operations:</p> <p>Optional Sequence Requirements:</p> Expression Return Type Meaning Container a.front() T&amp; *a.begin() vector, list, deque a.back() T&amp; *--a.end() vector, list, deque a.push_front(t) void a.insert(a.begin(), t) list, deque a.push_back(t) void a.insert(a.end(), t) vector, list, deque a.pop_front(t) void a.erase(a.begin()) list, deque a.pop_back(t) void a.erase(--a.end()) vector, list, deque a[n] T&amp; *(a.begin() + n) vector, deque a.at(n) T&amp; *(a.begin() + n) vector, deque"},{"location":"notes/#rvalue-lvalue-and-stdmove-semantics-transfer-ownership-of-the-data","title":"<code>rvalue</code>, <code>lvalue</code> and <code>std::move</code> semantics (transfer ownership of the data)","text":"<p>\" The traditional C++ reference, now called an lvalue reference, binds an identifier to an lvalue. An lvalue is an expression, such as a variable name or a dereferenced pointer, that represents data for which the program can obtain an address ... C++11 adds the rvalue reference, indicated by using &amp;&amp;, that can bind to rvalues\u2014that is, values that can appear on the right-hand side of an assignment expression but for which one cannot apply the address operator.\" - str. 1162 \"C++ Prime Plus.</p> <pre><code>string one(\"din\"); // C-style string constructor\nstring two(one); // copy constructor \u2013 one is an lvalue\nstring three(one+two); // move constructor, sum is an rvalue\n\nthree = one;        // automatic copy assignment \nfour = one + two;   // automatic copy assignment \nfour = std::move(one); // forced move assignment\n</code></pre> <p><code>move</code> constructor: <pre><code>Useless::Useless(Useless &amp;&amp; f): n(f.n)\n{\n    ++ct;\n    pc = f.pc; // steal address\n    f.pc = nullptr; // give old object nothing in return\n    f.n = 0;\n}\n</code></pre></p> <p>\"...constructor then sets the original pointer to the null pointer because it is not an error to apply <code>delete []</code> to the null pointer This appropriation of ownership often is termed <code>pilfering</code>.\" - str. 1169 \"C++ Prime Plus.</p>"},{"location":"notes/#delegating-constructors","title":"Delegating Constructors","text":"<p>delegation - use of constructor as a part of the definition of another constructor.</p> <pre><code>class Nots{\n    ...\n    Nots();\n    Nots(int, double, std::string);\n}\n\nNots::Nots() : Nots(0, 0.1, \"WOW\"){...} // delegate\nNots::Nots(int ii, double dd, std::string ss){...}\n</code></pre>"},{"location":"notes/#miscleanous","title":"Miscleanous","text":"<p>Three approaches for passing information to an STL algorithm: <code>function pointers</code>, <code>functors</code>, and <code>lambdas</code>.  </p> <p>\"The <code>tuple</code> header file supports the tuple template.A tuple object is a generalization of a pair object. Whereas a pair object can hold two values whose types need not be the same, a tuple can hold an arbitrary number of items of different types.  The compile-time rational arithmetic library, supported by the ratio header file, allows the exact representation of any rational number whose numerator and denominator can be represented by the widest integer type. It also provides arithmetic operations for these numbers. One of the most interesting additions is a regular expression library, supported by the regex header file.A regular expression specifies a pattern that can be used to match contents in a text string. For example, a bracket expression matches any single character in the brackets.Thus, [cCkK] matches a single c, C, k, or K, and [cCkK]at matches the words cat, Cat, kat, and Kat. Other patterns include \\d for a digit, \\w for a word, \\t for a tab, and many, many others.The fact that a backslash has a special meaning in C++ as the first character in an escape sequence requires a pattern like \\d\\t\\w\\d (that is, digit-tab-worddigit) to be written as the string literal \"\\d\\t\\w\\d\", using \\ to represent .This is one reason the raw string was introduced (see Chapter 4); it enables you to write the same pattern as R\"\\d\\t\\w\\t\". Unix utilities such as ed, grep, and awk used regular expressions, and the interpreted language Perl extended their capabilities.The C++ regular expressions library allows you to choose from several flavors of regular expressions. \" - str. 1203 \"C++ Prime Plus.  </p> <p>metaprogramming - creating programs that create or modify other programs or even themselves (C++ this can be done during compile time using templates.)</p>"}]}