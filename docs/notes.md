# Notes

The `good()` method in C++ is used to check the state of a stream object.
It returns true if none of the stream's error state flags (`eofbit`, `failbit`, `badbit`) are set. These flags indicate end-of-file, a logical error
on the stream, and a reading or writing error on the stream, respectively. If any of these flags are set, the good() method returns false.

It's a good practice to use `good()` or similar methods (`is_open()`, `fail()`, etc.) before writing data into a file.
These methods allow you to check the state of your file stream and ensure that it's safe to proceed with writing data.
If you don't check the state of the file stream before writing, you might encounter errors or exceptions, especially if the file doesn't exist, can't
be accessed, or has been corrupted.

## Debug in VSCode

PATH: `.vscode/launch.json`

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "(gdb) Launch",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/exercises/chapter11/ch11_2.out",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ],
            "additionalSOLibSearchPath": "/path/to/symbols;/another/path/to/symbols"
        }
    ]
}
```

PATH: `.vscode/tasks.json`

```json
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: g++-11 build active file",
            "command": "/usr/bin/g++-11",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                // "${file}",
                "${workspaceFolder}/exercises/chapter11/ch11_2.cpp",
                "${workspaceFolder}/exercises/chapter11/ch11_2_vect.cpp",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}
```

`Inline` keyword tells the compiler to consider function for `inlining`. If the function is small and called frequently, inlining it can lead to
performance improvements because the overhead of a function call is avoided.

`Inlining` - mean that the code of the function is inserted at the point where the function is called, instead of performing a regular function call.
This can potentially improve performance by avoiding the overhead of a function call, but it might increase the size of the binary file because the
function's code could be inserted in multiple places

## Classes

- when `designing` a `class`, you need to develop a `public interface` and a `private implementation`.

### Is-a Relationship Considerations (Public Inheritance) - str. 772 "C++ Prime Plus"

"You should be guided by the `is-a` relationship. If your proposed derived class is not a particular
kind of the base class, you shouldn’t use public derivation. For example, you
shouldn’t derive a `Programmer` class from a `Brain` class. If you want to represent the belief
that a programmer has a brain, you should use a `Brain` class object as a member of the
`Programmer` class."

### Inheritance

- "Private inheritance limits the use of base-class methods to within derived-class methods" page 800.

### STL Iterators

Constant-time complexity operations:

Optional Sequence Requirements:

|Expression| Return Type| Meaning| Container|
|---|---|---|---|
|a.front()| T&| *a.begin()| vector, list, deque|
|a.back()| T&| *--a.end()| vector, list, deque|
|a.push_front(t)| void| a.insert(a.begin(), t)| list, deque|
|a.push_back(t)| void| a.insert(a.end(), t)| vector, list, deque|
|a.pop_front(t)| void| a.erase(a.begin())| list, deque|
|a.pop_back(t)| void| a.erase(--a.end())| vector, list, deque|
|a[n]| T&| *(a.begin() + n)| vector, deque|
|a.at(n)| T&| *(a.begin() + n)| vector, deque|