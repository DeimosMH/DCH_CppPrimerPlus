# Notes

The `good()` method in C++ is used to check the state of a stream object.
It returns true if none of the stream's error state flags (`eofbit`, `failbit`, `badbit`) are set. These flags indicate end-of-file, a logical error
on the stream, and a reading or writing error on the stream, respectively. If any of these flags are set, the good() method returns false.

It's a good practice to use `good()` or similar methods (`is_open()`, `fail()`, etc.) before writing data into a file.
These methods allow you to check the state of your file stream and ensure that it's safe to proceed with writing data.
If you don't check the state of the file stream before writing, you might encounter errors or exceptions, especially if the file doesn't exist, can't
be accessed, or has been corrupted.

## Debug in VSCode

PATH: `.vscode/launch.json`

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "(gdb) Launch",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/exercises/chapter11/ch11_2.out",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ],
            "additionalSOLibSearchPath": "/path/to/symbols;/another/path/to/symbols"
        }
    ]
}
```

PATH: `.vscode/tasks.json`

```json
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: g++-11 build active file",
            "command": "/usr/bin/g++-11",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                // "${file}",
                "${workspaceFolder}/exercises/chapter11/ch11_2.cpp",
                "${workspaceFolder}/exercises/chapter11/ch11_2_vect.cpp",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}
```

`Inline` keyword tells the compiler to consider function for `inlining`. If the function is small and called frequently, inlining it can lead to
performance improvements because the overhead of a function call is avoided.

`Inlining` - mean that the code of the function is inserted at the point where the function is called, instead of performing a regular function call.
This can potentially improve performance by avoiding the overhead of a function call, but it might increase the size of the binary file because the
function's code could be inserted in multiple places

## Classes

- when `designing` a `class`, you need to develop a `public interface` and a `private implementation`.

### Is-a Relationship Considerations (Public Inheritance) - str. 772 "C++ Prime Plus"

"You should be guided by the `is-a` relationship. If your proposed derived class is not a particular
kind of the base class, you shouldn’t use public derivation. For example, you
shouldn’t derive a `Programmer` class from a `Brain` class. If you want to represent the belief
that a programmer has a brain, you should use a `Brain` class object as a member of the
`Programmer` class."

### Inheritance

- "Private inheritance limits the use of base-class methods to within derived-class methods" page 800.

### STL Iterators

Constant-time complexity operations:

Optional Sequence Requirements:

|Expression| Return Type| Meaning| Container|
|---|---|---|---|
|a.front()| T&| *a.begin()| vector, list, deque|
|a.back()| T&| *--a.end()| vector, list, deque|
|a.push_front(t)| void| a.insert(a.begin(), t)| list, deque|
|a.push_back(t)| void| a.insert(a.end(), t)| vector, list, deque|
|a.pop_front(t)| void| a.erase(a.begin())| list, deque|
|a.pop_back(t)| void| a.erase(--a.end())| vector, list, deque|
|a[n]| T&| *(a.begin() + n)| vector, deque|
|a.at(n)| T&| *(a.begin() + n)| vector, deque|


### `rvalue`, `lvalue` and `std::move` semantics (transfer ownership of the data)

"
The traditional C++ reference, now called an lvalue reference, binds an identifier to an
lvalue.
An lvalue is an expression, such as a variable name or a dereferenced pointer, that
represents data for which the program can obtain an address
...
C++11 adds the rvalue reference, indicated by using &&, that
can bind to rvalues—that is, values that can appear on the right-hand side of an
assignment expression but for which one cannot apply the address operator." - str. 1162 "C++ Prime Plus.

```cpp
string one("din"); // C-style string constructor
string two(one); // copy constructor – one is an lvalue
string three(one+two); // move constructor, sum is an rvalue

three = one;        // automatic copy assignment 
four = one + two;   // automatic copy assignment 
four = std::move(one); // forced move assignment
```

`move` constructor:
```cpp
Useless::Useless(Useless && f): n(f.n)
{
    ++ct;
    pc = f.pc; // steal address
    f.pc = nullptr; // give old object nothing in return
    f.n = 0;
}
```

"...constructor then sets the original pointer to the null pointer
because it is not an error to apply `delete []` to the null pointer
This appropriation of ownership often is termed `pilfering`." - str. 1169 "C++ Prime Plus.

### Delegating Constructors

delegation - use of constructor as a part of the definition of another constructor.

```cpp
class Nots{
    ...
    Nots();
    Nots(int, double, std::string);
}

Nots::Nots() : Nots(0, 0.1, "WOW"){...} // delegate
Nots::Nots(int ii, double dd, std::string ss){...}
```